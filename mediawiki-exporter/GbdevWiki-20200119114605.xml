<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>GbdevWiki</sitename>
    <dbname>gbdevwiki</dbname>
    <base>https://gbdev.gg8.se/wiki/articles/Main_Page</base>
    <generator>MediaWiki 1.25.1</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">GbdevWiki</namespace>
      <namespace key="5" case="first-letter">GbdevWiki talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Template:Pandocs</title>
    <ns>10</ns>
    <id>17</id>
    <revision>
      <id>81</id>
      <timestamp>2008-03-09T00:30:12Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>New page: &lt;div class=&quot;wikitable&quot; style=&quot;border: 1px solid #ccc; margin:0.5em auto; font-size:95%; text-align: center;&quot;&gt; '''This article is part of [[Pan_Docs]].'''  Please read more about Pan Docs b...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="332">&lt;div class=&quot;wikitable&quot; style=&quot;border: 1px solid #ccc; margin:0.5em auto; font-size:95%; text-align: center;&quot;&gt;
'''This article is part of [[Pan_Docs]].'''

Please read more about Pan Docs by clicking [[Pan_Docs here]].

To view this information in its original context, click here: http://nocash.emubase.de/pandocs.htm#{{{1}}}
&lt;/div&gt;</text>
      <sha1>6p27hjn6mfxxkuu088s6ixl4mf1guec</sha1>
    </revision>
    <revision>
      <id>82</id>
      <parentid>81</parentid>
      <timestamp>2008-03-09T00:30:42Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="332">&lt;div class=&quot;wikitable&quot; style=&quot;border: 1px solid #ccc; margin:0.5em auto; font-size:95%; text-align: center;&quot;&gt;
'''This article is part of [[Pan Docs]].'''

Please read more about Pan Docs by clicking [[Pan Docs|here]].

To view this information in its original context, click here: http://nocash.emubase.de/pandocs.htm#{{{1}}}
&lt;/div&gt;</text>
      <sha1>na3y38x88v6uf1j66zeqf0bzg17oisr</sha1>
    </revision>
    <revision>
      <id>84</id>
      <parentid>82</parentid>
      <timestamp>2008-03-09T00:44:52Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="362">&lt;div class=&quot;wikitable&quot; style=&quot;border: 1px solid #ccc; margin:0.5em auto; font-size:95%; text-align: center;&quot;&gt;
'''This article is part of [[Pan Docs]].'''

Please read more about Pan Docs by clicking [[Pan Docs|here]].

To view this information in its original context, click here: http://nocash.emubase.de/pandocs.htm#{{{1}}}

[[Category:Pandocs Article]]
&lt;/div&gt;</text>
      <sha1>fz35e03e6p3o40p0n4it6xcln04e6ci</sha1>
    </revision>
    <revision>
      <id>89</id>
      <parentid>84</parentid>
      <timestamp>2008-03-09T01:06:00Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="391">&lt;div class=&quot;wikitable&quot; style=&quot;border: 1px solid #ccc; margin:0.5em auto; font-size:95%; text-align: center;&quot;&gt;
'''This article is part of [[Pan Docs]].'''

Please read more about Pan Docs, and what you can do to help by clicking [[Pan Docs|here]].

To view this information in its original context, click here: http://nocash.emubase.de/pandocs.htm#{{{1}}}

[[Category:Pandocs Article]]
&lt;/div&gt;</text>
      <sha1>smantcy5bj049h3hqytyzoe88pmvrqg</sha1>
    </revision>
    <revision>
      <id>90</id>
      <parentid>89</parentid>
      <timestamp>2008-03-09T01:06:18Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="407">&lt;div class=&quot;wikitable&quot; style=&quot;border: 1px solid #ccc; margin:0.5em auto; font-size:95%; text-align: center;&quot;&gt;
'''This article is part of [[Pan Docs]].'''

Please read more about Pan Docs, and what you can do to improve this article by clicking [[Pan Docs|here]].

To view this information in its original context, click here: http://nocash.emubase.de/pandocs.htm#{{{1}}}

[[Category:Pandocs Article]]
&lt;/div&gt;</text>
      <sha1>kqtzn8p3mzx1fitdbq3lfed95yzveuz</sha1>
    </revision>
    <revision>
      <id>434</id>
      <parentid>90</parentid>
      <timestamp>2012-01-13T01:56:15Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="422">&lt;div class=&quot;wikitable&quot; style=&quot;border: 1px solid #ccc; margin:0.5em auto; font-size:95%; text-align: center;&quot;&gt;
'''This article is part of [[Pan Docs]].'''

Please read more about Pan Docs, and what you can do to improve this article by clicking [[Pan Docs|here]].

To view this information in its original context, click here: http://gbdev.gg8.se/files/docs/mirrors/pandocs.html#{{{1}}}

[[Category:Pandocs Article]]
&lt;/div&gt;</text>
      <sha1>4417tvyt0uwhecxcyh4ptzklidl8xol</sha1>
    </revision>
  </page>
  <page>
    <title>Pan Docs</title>
    <ns>0</ns>
    <id>16</id>
    <revision>
      <id>76</id>
      <timestamp>2008-03-08T23:40:02Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>New page: == Pan Docs == === Excerpt === &lt;pre&gt; =================================================================        Everything You Always Wanted To Know About GAMEBOY *  ========================...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="594">== Pan Docs ==
=== Excerpt ===
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Pan Docs Wikification ===</text>
      <sha1>j0bbz0u0cnwpup06sbdc33qi967esg3</sha1>
    </revision>
    <revision>
      <id>77</id>
      <parentid>76</parentid>
      <timestamp>2008-03-08T23:50:03Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="807">== Pan Docs ==
=== Excerpt ===
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Pan Docs Wikification ===
Pan Docs is the most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]].</text>
      <sha1>b9lzcf64fvf812nn2p8fqefwjc619mn</sha1>
    </revision>
    <revision>
      <id>78</id>
      <parentid>77</parentid>
      <timestamp>2008-03-09T00:05:02Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1210">== Pan Docs ==
=== Excerpt ===
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Pan Docs Wikification ===
Pan Docs is the most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource to add to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.</text>
      <sha1>rvomfzktatpkkr0b5bypqm9rxd1egqx</sha1>
    </revision>
    <revision>
      <id>79</id>
      <parentid>78</parentid>
      <timestamp>2008-03-09T00:06:16Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1231">== Pan Docs ==
=== Excerpt ===
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Pan Docs Wikification ===
Pan Docs is the most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.</text>
      <sha1>p2986el9jud3xarm85mws5vloixeb3d</sha1>
    </revision>
    <revision>
      <id>80</id>
      <parentid>79</parentid>
      <timestamp>2008-03-09T00:07:04Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1212">== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
Pan Docs is the most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.</text>
      <sha1>78flt2p9xf0lxoxbih13lj7yw0hw13e</sha1>
    </revision>
    <revision>
      <id>83</id>
      <parentid>80</parentid>
      <timestamp>2008-03-09T00:32:26Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1241">== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
Pan Docs is the most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>ie1dp3wdlf7cwob6rbhmrv9no8m9xd7</sha1>
    </revision>
    <revision>
      <id>91</id>
      <parentid>83</parentid>
      <timestamp>2008-03-09T01:23:49Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1621">== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guide lines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>am501ghzalm767fmtf74o43ycnc5m13</sha1>
    </revision>
    <revision>
      <id>92</id>
      <parentid>91</parentid>
      <timestamp>2008-03-09T01:24:02Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>/* Ways to help */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1620">== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>rmhx4ph3udq5sh128jpi02nzp62nach</sha1>
    </revision>
    <revision>
      <id>119</id>
      <parentid>92</parentid>
      <timestamp>2008-03-10T01:44:38Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2186">== Table of Contents ==
=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]] 
=== Cartridges ===
[[The Cartridge Header]] -  [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]] 
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>cx6qore5nk1ix041c0w6gidyfuv3qsx</sha1>
    </revision>
    <revision>
      <id>124</id>
      <parentid>119</parentid>
      <timestamp>2008-03-11T02:32:27Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>/* Mission */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2193">== Table of Contents ==
=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]] 
=== Cartridges ===
[[The Cartridge Header]] -  [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]] 
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>s12136s71ce92cezqg4vilko845b6vv</sha1>
    </revision>
    <revision>
      <id>148</id>
      <parentid>124</parentid>
      <timestamp>2009-06-28T10:34:46Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2195">== Table of Contents ==
=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]] 
=== Cartridges ===
[[The Cartridge Header]] -  [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]] 
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>6ezdcxrfd1lnxxafbggqurvc37rs52q</sha1>
    </revision>
    <revision>
      <id>284</id>
      <parentid>148</parentid>
      <timestamp>2010-10-08T01:40:46Z</timestamp>
      <contributor>
        <username>TechFalcon</username>
        <id>24</id>
      </contributor>
      <comment>/* Other */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2225">== Table of Contents ==
=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]] 
=== Cartridges ===
[[The Cartridge Header]] -  [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]] 
=== Other ===
[[Game Boy Technical Data]] - [[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>edz8ufv09epfdwp36t8utourx2yensw</sha1>
    </revision>
    <revision>
      <id>286</id>
      <parentid>284</parentid>
      <timestamp>2010-10-08T01:54:16Z</timestamp>
      <contributor>
        <username>TechFalcon</username>
        <id>24</id>
      </contributor>
      <comment>/* Table of Contents */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2282">== Table of Contents ==
=== Overview ===
[[About the Pan Docs]] - [[Game Boy Technical Data]] - [[Memory Map]]
=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]] 
=== Cartridges ===
[[The Cartridge Header]] -  [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]] 
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>3d9m4mfcknwf0bgsllqj9r359ud5xsy</sha1>
    </revision>
    <revision>
      <id>288</id>
      <parentid>286</parentid>
      <timestamp>2010-10-08T02:08:50Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>/* Overview */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2258">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]] 
=== Cartridges ===
[[The Cartridge Header]] -  [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]] 
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>4vriea3yywev608jxry2747yx5sc1vn</sha1>
    </revision>
    <revision>
      <id>289</id>
      <parentid>288</parentid>
      <timestamp>2010-10-08T02:11:32Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>/* Excerpt */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3194">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]] 
=== Cartridges ===
[[The Cartridge Header]] -  [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]] 
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available in [http://www.work.de/nocash/pandocs.txt Text] and [http://www.work.de/nocash/pandocs.htm HTML] format.

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>qzrn0be4y79tiff4q41ut0vtqp4pljk</sha1>
    </revision>
    <revision>
      <id>455</id>
      <parentid>289</parentid>
      <timestamp>2012-05-25T12:23:30Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>/* Table of Contents */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3235">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Gamegenie/Shark Cheats]]
=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MBC3]] - [[MBC5]]
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available in [http://www.work.de/nocash/pandocs.txt Text] and [http://www.work.de/nocash/pandocs.htm HTML] format.

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>omcjltr4lv7hr27y1571zpny5wkjvuf</sha1>
    </revision>
    <revision>
      <id>456</id>
      <parentid>455</parentid>
      <timestamp>2012-05-25T12:24:18Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>/* Cartridges */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3266">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]]

=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MBC3]] - [[MBC5]]
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available in [http://www.work.de/nocash/pandocs.txt Text] and [http://www.work.de/nocash/pandocs.htm HTML] format.

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>tv0tzek5pwe05cut6rqshvjfuhqql5j</sha1>
    </revision>
    <revision>
      <id>527</id>
      <parentid>456</parentid>
      <timestamp>2014-01-30T20:46:20Z</timestamp>
      <contributor>
        <username>MrElephant</username>
        <id>39</id>
      </contributor>
      <comment>/* Mission */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3683">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]]

=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MBC3]] - [[MBC5]]
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available in [http://www.work.de/nocash/pandocs.txt Text] and [http://www.work.de/nocash/pandocs.htm HTML] format.

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.



Update as of 1/30/2014 at 3:41 P.M.

I have provided a link to Pan's old webpage using the wayback machine.  Here you can download some of his old tools that are so hard to find.
I might provide a tutorial or two after I get enough time.

http://web.archive.org/web/19990209030645/http://www.anthrox.com/


Please click on free software to download the tools.
We hold no liability for the tools that you download.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>2ioxw5u7cvg2bi7nz4t5kz2ee291ofj</sha1>
    </revision>
    <revision>
      <id>528</id>
      <parentid>527</parentid>
      <timestamp>2014-01-30T20:54:13Z</timestamp>
      <contributor>
        <username>MrElephant</username>
        <id>39</id>
      </contributor>
      <comment>/* Available Document Formats */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3618">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]]

=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MBC3]] - [[MBC5]]
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available at http://nocash.emubase.de/pandocs.htm

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.



Update as of 1/30/2014 at 3:41 P.M.

I have provided a link to Pan's old webpage using the wayback machine.  Here you can download some of his old tools that are so hard to find.
I might provide a tutorial or two after I get enough time.

http://web.archive.org/web/19990209030645/http://www.anthrox.com/


Please click on free software to download the tools.
We hold no liability for the tools that you download.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>arxgnp73adazmljzzgjnmfi0m0sctpw</sha1>
    </revision>
    <revision>
      <id>610</id>
      <parentid>528</parentid>
      <timestamp>2015-12-15T20:33:18Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* Mission */ Added a notice : the GBC programming section has been removed.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3734">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]]

=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MBC3]] - [[MBC5]]
=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available at http://nocash.emubase.de/pandocs.htm

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.



Update as of 1/30/2014 at 3:41 P.M.

I have provided a link to Pan's old webpage using the wayback machine.  Here you can download some of his old tools that are so hard to find.
I might provide a tutorial or two after I get enough time.

http://web.archive.org/web/19990209030645/http://www.anthrox.com/

Update as of 15/12/2015 at 9:23 P.M.

The Game Boy Color Programming Section was removed from the Wayback Machine.


Please click on free software to download the tools.
We hold no liability for the tools that you download.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>9r9a3ehhwicw196b1hwvkgocybn9dew</sha1>
    </revision>
    <revision>
      <id>741</id>
      <parentid>610</parentid>
      <timestamp>2017-05-09T15:46:45Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Memory Bank Controllers */ Added links to all MBCs. (Including undocumented ones, which adds them to the &quot;wanted&quot; pages)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3813">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]]

=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MMM01]] - [[MBC3]] - [[MBC4]] - [[MBC5]] -[[MBC6]] - [[MBC7]] - [[HuC1]] - [[HuC3]] - [[TAMA5]]

=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available at http://nocash.emubase.de/pandocs.htm

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.



Update as of 1/30/2014 at 3:41 P.M.

I have provided a link to Pan's old webpage using the wayback machine.  Here you can download some of his old tools that are so hard to find.
I might provide a tutorial or two after I get enough time.

http://web.archive.org/web/19990209030645/http://www.anthrox.com/

Update as of 15/12/2015 at 9:23 P.M.

The Game Boy Color Programming Section was removed from the Wayback Machine.


Please click on free software to download the tools.
We hold no liability for the tools that you download.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>93hyhj83splzhy66gyq2dm99u1tolul</sha1>
    </revision>
    <revision>
      <id>749</id>
      <parentid>741</parentid>
      <timestamp>2017-05-09T17:02:05Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* Memory Bank Controllers */ Removed MBC4, which apparently doesn't exist (?)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3879">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Memory Bank Controllers]] - [[Gamegenie/Shark Cheats]]

=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MMM01]] - [[MBC3]]&lt;!-- - [[MBC4]]--&gt; - [[MBC5]] - [[MBC6]] - [[MBC7]] - [[HuC1]] - [[HuC3]] - [[TAMA5]]

(Editor's note : There is apparently no MBC4 controller)

=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available at http://nocash.emubase.de/pandocs.htm

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.



Update as of 1/30/2014 at 3:41 P.M.

I have provided a link to Pan's old webpage using the wayback machine.  Here you can download some of his old tools that are so hard to find.
I might provide a tutorial or two after I get enough time.

http://web.archive.org/web/19990209030645/http://www.anthrox.com/

Update as of 15/12/2015 at 9:23 P.M.

The Game Boy Color Programming Section was removed from the Wayback Machine.


Please click on free software to download the tools.
We hold no liability for the tools that you download.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>rj3h8hi1fv1b2h1tvunhrqb7etcstyt</sha1>
    </revision>
    <revision>
      <id>752</id>
      <parentid>749</parentid>
      <timestamp>2017-05-10T08:11:26Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Table of Contents */ Added a section about the GB's accessories</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3941">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Memory Bank Controllers]]

=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MMM01]] - [[MBC3]]&lt;!-- - [[MBC4]]--&gt; - [[MBC5]] - [[MBC6]] - [[MBC7]] - [[HuC1]] - [[HuC3]] - [[TAMA5]]

(Editor's note : There is apparently no MBC4 controller)

=== Accessories ===
[[Gameboy Printer]] - [[Gameboy Camera]] - [[Gamegenie/Shark Cheats]]

=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available at http://nocash.emubase.de/pandocs.htm

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.



Update as of 1/30/2014 at 3:41 P.M.

I have provided a link to Pan's old webpage using the wayback machine.  Here you can download some of his old tools that are so hard to find.
I might provide a tutorial or two after I get enough time.

http://web.archive.org/web/19990209030645/http://www.anthrox.com/

Update as of 15/12/2015 at 9:23 P.M.

The Game Boy Color Programming Section was removed from the Wayback Machine.


Please click on free software to download the tools.
We hold no liability for the tools that you download.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>9rf9cycw51nsmvwejfb8je9pvbnwmji</sha1>
    </revision>
    <revision>
      <id>810</id>
      <parentid>752</parentid>
      <timestamp>2018-11-15T15:53:59Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* Overview */ Add link to new Terminology page</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3959">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]] - [[Terminology]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Memory Bank Controllers]]

=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MMM01]] - [[MBC3]]&lt;!-- - [[MBC4]]--&gt; - [[MBC5]] - [[MBC6]] - [[MBC7]] - [[HuC1]] - [[HuC3]] - [[TAMA5]]

(Editor's note : There is apparently no MBC4 controller)

=== Accessories ===
[[Gameboy Printer]] - [[Gameboy Camera]] - [[Gamegenie/Shark Cheats]]

=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available at http://nocash.emubase.de/pandocs.htm

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.



Update as of 1/30/2014 at 3:41 P.M.

I have provided a link to Pan's old webpage using the wayback machine.  Here you can download some of his old tools that are so hard to find.
I might provide a tutorial or two after I get enough time.

http://web.archive.org/web/19990209030645/http://www.anthrox.com/

Update as of 15/12/2015 at 9:23 P.M.

The Game Boy Color Programming Section was removed from the Wayback Machine.


Please click on free software to download the tools.
We hold no liability for the tools that you download.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>g4dokngjwv5rffc0jjq8sga5s0tm0bv</sha1>
    </revision>
    <revision>
      <id>824</id>
      <parentid>810</parentid>
      <timestamp>2018-12-22T19:57:26Z</timestamp>
      <contributor>
        <username>Nokia64</username>
        <id>82</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4143">== Table of Contents ==
=== Overview ===
[[Game Boy Technical Data]] - [[Memory Map]] - [[Terminology]]

=== I/O Ports ===
[[Video Display]] - [[Sound Controller]] - [[Joypad Input]] - [[Serial Data Transfer (Link Cable)]] - [[Timer and Divider Registers]] - [[Interrupts]] - [[CGB Registers]] - [[SGB Functions]]
=== CPU Specifications ===
[[CPU Registers and Flags]] - [[CPU Instruction Set]] - [[CPU Comparison with Z80]]
=== Cartridges ===
[[The Cartridge Header]] - [[Memory Bank Controllers]]

=== Memory Bank Controllers ===
[[MBC1]] - [[MBC2]] - [[MMM01]] - [[MBC3]]&lt;!-- - [[MBC4]]--&gt; - [[MBC5]] - [[MBC6]] - [[MBC7]] - [[HuC1]] - [[HuC3]] - [[TAMA5]]

(Editor's note : There is apparently no MBC4 controller)

=== Accessories ===
[[Gameboy Printer]] - [[Gameboy Camera]] - [[Gamegenie/Shark Cheats]]

=== Other ===
[[Power Up Sequence]] - [[Reducing Power Consumption]] - [[Sprite RAM Bug]] - [[External Connectors]]

== Excerpt from Martin's document ==
&lt;pre&gt; =================================================================
       Everything You Always Wanted To Know About GAMEBOY *
 =================================================================

                     * but were afraid to ask

        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth

                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa&lt;/pre&gt;

=== Foreword ===

The following was typed up for informational purposes regarding the inner workings on the hand-held game machine known as GameBoy, manufactured and designed by Nintendo Co., LTD. This info is presented to inform a user on how their Game Boy works and what makes it &quot;tick&quot;. GameBoy is copyrighted by Nintendo Co., LTD. Any reference to copyrighted material is not presented for monetary gain, but for educational purposes and higher learning.

=== Available Document Formats ===
The present version of this document is available at http://nocash.emubase.de/pandocs.htm

Also, a copy of this document is included in the manual of newer versions of the [[no$gmb]] debugger, because of recent piracy attacks (many thanks and best wishes go to hell) I have currently no intention to publish any such or further no$gmb updates though.

== Pan Docs Wikification ==
=== Mission ===
Pan Docs is the single most comprehensive technical reference to Gameboy that is available to the public. It was originally written by Pan of Anthrox, and was later maintained by Martin Korth, also known for [[no$gmb]]. As Pandocs is an important resource, it is a priority to add it to the wiki.

The addition of information from the document is done under the following premises:
* It is thought that the information in the document was meant to be public domain by its authors.
* The document is no longer actively maintained by its original authors.
* Adding the information to a wiki allows people to correct or add information if needed.
* That the information can be presented in such a way that it is more appealing.



Update as of 1/30/2014 at 3:41 P.M.

I have provided a link to Pan's old webpage using the wayback machine.  Here you can download some of his old tools that are so hard to find.
I might provide a tutorial or two after I get enough time.

http://web.archive.org/web/19990209030645/http://www.anthrox.com/

Update as of 22/12/2018 at 11:52 P.M.

The Game Boy Color Programming Section was removed by it's author before the Wayback Machine got all the files there. It can still be accessed at http://web.archive.org/web/20000116003353/http://www.jps.net:80/paninaro/index.html , but it's pretty incomplete.


Please click on free software to download the tools.
We hold no liability for the tools that you download.

=== Ways to help ===
* Add information from Pan Docs. (To do: Formatting guidelines)
* Convert ASCII art into images or tables, or other formatting as appropriate.
* Condense information! Create a parallel article where the most important parts of a Pandocs article are condensed.

{{Pandocs|aboutthepandocs}}</text>
      <sha1>el08qhmwcketkjqjog49f5w3hsa0r1f</sha1>
    </revision>
  </page>
  <page>
    <title>Video Display</title>
    <ns>0</ns>
    <id>18</id>
    <revision>
      <id>85</id>
      <timestamp>2008-03-09T00:50:06Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>New page: == LCD Control Register == === FF40 - LCDC - LCD Control (R/W) ===   Bit 7 - LCD Display Enable             (0=Off, 1=On)   Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4134">== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabeling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) ===
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD contoller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)</text>
      <sha1>60ug0daplhd1e6efam7v768s4a1fnw6</sha1>
    </revision>
    <revision>
      <id>86</id>
      <parentid>85</parentid>
      <timestamp>2008-03-09T00:53:48Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11012">== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabeling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) ===
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD contoller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behinf the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A postion of WX=7, WY=0 locates the window at upper left, it is then completly covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regulary used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?</text>
      <sha1>m5fubdyfbd4vdfckvvlmho6nhiwys41</sha1>
    </revision>
    <revision>
      <id>87</id>
      <parentid>86</parentid>
      <timestamp>2008-03-09T01:04:41Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25236">== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabeling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) ===
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD contoller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behinf the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A postion of WX=7, WY=0 locates the window at upper left, it is then completly covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regulary used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High; FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low; FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High; FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low; FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

=== Bit7=0 - General Purpose DMA ===
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

=== Bit7=1 - H-Blank DMA ===
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
GameBoy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An offscreen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An offscreen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate offscreen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommened method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessable before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranted to be accessable only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessable during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessable during ===
 Mode 0-1  Mode 0 - H-Blank Period, and
  Mode 1 - V-Blank Period

Beside for that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibilty or OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessable at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>ozleda45mgy15dwgqe59bke9llkztj2</sha1>
    </revision>
    <revision>
      <id>88</id>
      <parentid>87</parentid>
      <timestamp>2008-03-09T01:05:37Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25262">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabeling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) ===
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD contoller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behinf the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A postion of WX=7, WY=0 locates the window at upper left, it is then completly covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regulary used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High; FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low; FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High; FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low; FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

=== Bit7=0 - General Purpose DMA ===
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

=== Bit7=1 - H-Blank DMA ===
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
GameBoy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An offscreen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An offscreen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate offscreen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommened method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessable before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranted to be accessable only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessable during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessable during ===
 Mode 0-1  Mode 0 - H-Blank Period, and
  Mode 1 - V-Blank Period

Beside for that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibilty or OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessable at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>68rozgmuxfiszpueubzxe1ww8unf2f3</sha1>
    </revision>
    <revision>
      <id>436</id>
      <parentid>88</parentid>
      <timestamp>2012-05-25T10:24:05Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <minor/>
      <comment>Fixed formatting of bit listing that caused &quot;Bit 0-5&quot; to not be displayed properly.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25263">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabeling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) ===
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD contoller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behinf the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A postion of WX=7, WY=0 locates the window at upper left, it is then completly covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regulary used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High; FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low; FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High; FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low; FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

=== Bit7=0 - General Purpose DMA ===
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

=== Bit7=1 - H-Blank DMA ===
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
GameBoy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An offscreen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An offscreen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate offscreen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommened method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessable before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranted to be accessable only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessable during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessable during ===
 Mode 0-1  Mode 0 - H-Blank Period, and
  Mode 1 - V-Blank Period

Beside for that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibilty or OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessable at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>g47xfmm8ltouxchd51ou1v3fa10mpdx</sha1>
    </revision>
    <revision>
      <id>437</id>
      <parentid>436</parentid>
      <timestamp>2012-05-25T10:25:02Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <minor/>
      <comment>Fixed formatting of bit listing that caused &quot;Bit 0-4&quot; to not be displayed properly.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25264">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabeling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) ===
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD contoller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behinf the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A postion of WX=7, WY=0 locates the window at upper left, it is then completly covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regulary used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High; FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low; FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High; FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low; FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

=== Bit7=0 - General Purpose DMA ===
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

=== Bit7=1 - H-Blank DMA ===
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
GameBoy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An offscreen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An offscreen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate offscreen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommened method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessable before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranted to be accessable only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessable during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessable during ===
 Mode 0-1  Mode 0 - H-Blank Period, and
  Mode 1 - V-Blank Period

Beside for that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibilty or OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessable at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>4n8zuq60g73027yt3hxz0fqf3l5rk5b</sha1>
    </revision>
    <revision>
      <id>438</id>
      <parentid>437</parentid>
      <timestamp>2012-05-25T10:29:07Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <minor/>
      <comment>Changed text in first box to make it easier to read.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25250">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabeling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) ===
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD contoller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behinf the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A postion of WX=7, WY=0 locates the window at upper left, it is then completly covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regulary used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High; FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low; FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High; FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low; FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

=== Bit7=0 - General Purpose DMA ===
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

=== Bit7=1 - H-Blank DMA ===
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
GameBoy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An offscreen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An offscreen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate offscreen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommened method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessable before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranted to be accessable only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessable during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessable during ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Beside for that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibilty or OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessable at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>1635uw9ay0z3ijmsigyheyi4pqv2zab</sha1>
    </revision>
    <revision>
      <id>439</id>
      <parentid>438</parentid>
      <timestamp>2012-05-25T10:32:29Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <minor/>
      <comment>Realized what the text I removed was *supposed* to be, and added it back in at it's proper place. Fixed a few typos.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25260">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabeling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) ===
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD contoller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behinf the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A postion of WX=7, WY=0 locates the window at upper left, it is then completly covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regulary used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High; FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low; FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High; FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low; FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

=== Bit7=0 - General Purpose DMA ===
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

=== Bit7=1 - H-Blank DMA ===
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
GameBoy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An offscreen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An offscreen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate offscreen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommened method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessable before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranted to be accessable only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessable during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessable during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessable at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>5f8b4shi5hzy3bcpdplwe2050lono2z</sha1>
    </revision>
    <revision>
      <id>440</id>
      <parentid>439</parentid>
      <timestamp>2012-05-25T10:38:39Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <minor/>
      <comment>Fixed typos.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25265">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) ===
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High; FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low; FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High; FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low; FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

=== Bit7=0 - General Purpose DMA ===
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

=== Bit7=1 - H-Blank DMA ===
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>dlcfe5bjep59a4j91l1ufmgs4lffyne</sha1>
    </revision>
    <revision>
      <id>503</id>
      <parentid>440</parentid>
      <timestamp>2012-05-25T18:37:56Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>/* FF41 - STAT - LCDC Status (R/W)  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25266">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High; FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low; FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High; FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low; FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

=== Bit7=0 - General Purpose DMA ===
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

=== Bit7=1 - H-Blank DMA ===
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>4swlw9ertvaua3ff98216r5kcdjanao</sha1>
    </revision>
    <revision>
      <id>504</id>
      <parentid>503</parentid>
      <timestamp>2012-05-25T18:52:53Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>/* FF51 - HDMA1 - CGB Mode Only - New DMA Source, High; FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low; FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High; FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low; FF55 - HDMA5 - CGB Mode Onl</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25294">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

=== Bit7=0 - General Purpose DMA ===
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

=== Bit7=1 - H-Blank DMA ===
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>qdkue5sabdedskj8rysuz68rik2j3v3</sha1>
    </revision>
    <revision>
      <id>505</id>
      <parentid>504</parentid>
      <timestamp>2012-05-25T18:54:04Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>/* LCD VRAM DMA Transfers (CGB only) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25290">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>h1dgayqz0d0ygby4w4v9nalvb3fm1gu</sha1>
    </revision>
    <revision>
      <id>559</id>
      <parentid>505</parentid>
      <timestamp>2014-11-22T23:27:42Z</timestamp>
      <contributor>
        <username>AntonioND</username>
        <id>47</id>
      </contributor>
      <comment>/* FF46 - DMA - DMA Transfer and Start Address (W) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25292">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>fltzkqgei865j8d8q6a6v4q8w16abmc</sha1>
    </revision>
    <revision>
      <id>736</id>
      <parentid>559</parentid>
      <timestamp>2017-05-08T20:12:46Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* FF41 - STAT - LCDC Status (R/W) */ Add info about STAT bug.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25454">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)
The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>n83p3ymi6ugbx8v18dfl1s38bugbmxv</sha1>
    </revision>
    <revision>
      <id>737</id>
      <parentid>736</parentid>
      <timestamp>2017-05-08T20:17:06Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) */ Add newline, add WX=0 bug info</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25522">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

If WX is set to 0, the window will &quot;stutter&quot; when SCX is changed.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment Bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, Data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: Initially all background colors are initialized as white.

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value.
Note: Initially all sprite colors are uninitialized.

=== RGB Translation by CGBs ===
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.
The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.
Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware. A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors became visible) it may turn out that the color mixing is different also, anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, This seal is your assurance for excellence in workmanship and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>bm6u6xdza0isw2y27s7o80hjca4kuzl</sha1>
    </revision>
    <revision>
      <id>739</id>
      <parentid>737</parentid>
      <timestamp>2017-05-09T11:17:26Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* LCD Color Palettes (CGB only) */ Misc stuff. Add an image. Add newlines. Also HDMI FTW !</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="25964">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

If WX is set to 0, the window will &quot;stutter&quot; when SCX is changed.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>8i735zsetv8lrtm1pw4k5rpw18ercqx</sha1>
    </revision>
    <revision>
      <id>740</id>
      <parentid>739</parentid>
      <timestamp>2017-05-09T11:24:58Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* FF46 - DMA - DMA Transfer and Start Address (R/W) */ Add more compact transfer procedure.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26200">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

If WX is set to 0, the window will &quot;stutter&quot; when SCX is changed.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites with different x coordinate values overlap, the one with the smaller x coordinate (closer to the left) will have priority and appear above any others. This applies in Non CGB Mode only.
When sprites with the same x coordinate values overlap, they have priority according to table ordering. (i.e. $FE00 - highest, $FE04 - next highest, etc.) In CGB Mode priorities are always assigned like this.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower priority sprites (priorities listed above) won't be displayed. To keep unused sprites from affecting onscreen sprites set their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other sprites sharing the same lines.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>so3d3nz5prwk3fc8p6wwmlh65t02pag</sha1>
    </revision>
    <revision>
      <id>768</id>
      <parentid>740</parentid>
      <timestamp>2017-06-27T14:09:50Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Sprite Priorities and Conflicts */ Correct incorrect info about 10-sprite limit priority, rewrite section.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26422">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==
=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

If WX is set to 0, the window will &quot;stutter&quot; when SCX is changed.

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>mm6gcjyi14t17pjoj15sw22n6xic8cb</sha1>
    </revision>
    <revision>
      <id>769</id>
      <parentid>768</parentid>
      <timestamp>2017-06-27T14:20:20Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* LCD Position and Scrolling */ Added a bit of info.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26664">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>ar5k9iwathufe28fgeuqeaaqxz9g7qz</sha1>
    </revision>
    <revision>
      <id>770</id>
      <parentid>769</parentid>
      <timestamp>2017-06-27T14:23:20Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* INT 48 - LCDC Status Interrupt */ Added an example.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="26901">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===
  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>378omxpad1vmimxec2pdzkj49aqwbur</sha1>
    </revision>
    <revision>
      <id>771</id>
      <parentid>770</parentid>
      <timestamp>2017-06-27T14:28:34Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* FF40 - LCDC - LCD Control (R/W) */ Added some info about writing to it mid-scanline</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="27202">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

=== LCDC.7 - LCD Display Enable ===
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.
V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

--- LCDC.0 has different Meanings depending on Gameboy Type ---

=== LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display ===
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

=== LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority ===
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

=== LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display ===
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>3r50lsk5qtj3u97sd64kiu51rns7smw</sha1>
    </revision>
    <revision>
      <id>772</id>
      <parentid>771</parentid>
      <timestamp>2017-06-27T14:37:37Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* LCD Control Register */ Added info, re-organized sections.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="27337">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy and SGB: BG Display =====
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

===== CGB in Non CGB Mode: BG and Window Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>7sawfi94kmmi7ol414ux3bu5yj5k0vz</sha1>
    </revision>
    <revision>
      <id>774</id>
      <parentid>772</parentid>
      <timestamp>2017-09-01T21:58:52Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* FF40 - LCDC - LCD Control (R/W) */ Detailed all LCDC bits.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="28735">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy and SGB: BG Display =====
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

===== CGB in Non CGB Mode: BG and Window Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>9cjlwi41maxqy8sqlxuiq2htrrzto0a</sha1>
    </revision>
    <revision>
      <id>775</id>
      <parentid>774</parentid>
      <timestamp>2017-09-01T22:02:51Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* INT 48 - LCDC Status Interrupt */ Added a note about the interrupt sometimes failing to fire.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="29055">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy and SGB: BG Display =====
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

===== CGB in Non CGB Mode: BG and Window Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites may have only 3 colors, because color 0 is transparent.

As it was said before, there are two Tile Pattern Tables at $8000-8FFF and at $8800-97FF. The first one can be used for sprites and the background. Its tiles are numbered from 0 to 255. The second table can be used for the background and the window display and its tiles are numbered from -128 to 127.

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>nv0q7ph4s2921hc1ktftz0cz5ozusd5</sha1>
    </revision>
    <revision>
      <id>776</id>
      <parentid>775</parentid>
      <timestamp>2017-09-01T22:16:50Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* VRAM Tile Data */ Revamped explanation on tile tables, added explanation on tile data format, added links to registers.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30514">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy and SGB: BG Display =====
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

===== CGB in Non CGB Mode: BG and Window Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000h-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two [[#VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each : block 0 is $8000-87FF, block 1 is $8800-8FFF, block -1 is $9000-$97FF. Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block -1 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>kddzbta21q3wo8421zqfsw5ezx0hx1e</sha1>
    </revision>
    <revision>
      <id>777</id>
      <parentid>776</parentid>
      <timestamp>2017-09-01T22:19:40Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* BG Map Attributes (CGB Mode only) */ Removed a misplaced line, and added two clarifications.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30549">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy and SGB: BG Display =====
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

===== CGB in Non CGB Mode: BG and Window Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000h-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two [[#VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each : block 0 is $8000-87FF, block 1 is $8800-8FFF, block -1 is $9000-$97FF. Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block -1 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed. Tile patterns are taken from the Tile Data Table located either at $8000-8FFF or $8800-97FF. In the first case, patterns are numbered with unsigned numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the second case, patterns have signed numbers from -128 to 127 (i.e. pattern #0 lies at address $9000). The Tile Data Table address for the background can be selected via LCDC register.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the tile at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>hwxv68eidgvvxa79qju0j0fo8fuydi6</sha1>
    </revision>
    <revision>
      <id>778</id>
      <parentid>777</parentid>
      <timestamp>2017-09-01T22:22:35Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* BG Map Tile Numbers */ Removed some duplicate info and restored a misplaced line in section right after.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30502">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy and SGB: BG Display =====
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

===== CGB in Non CGB Mode: BG and Window Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

== Bit7=0 - General Purpose DMA ==
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

== Bit7=1 - H-Blank DMA ==
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000h-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two [[#VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each : block 0 is $8000-87FF, block 1 is $8800-8FFF, block -1 is $9000-$97FF. Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block -1 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the tile at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>9j4hnhkc3aqvs0s1dpn1n3gc7flugww</sha1>
    </revision>
    <revision>
      <id>779</id>
      <parentid>778</parentid>
      <timestamp>2017-09-01T22:32:57Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>Moved CGB DMA sections to their proper place, and added a section about VBK.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31181">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy and SGB: BG Display =====
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

===== CGB in Non CGB Mode: BG and Window Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000h-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two [[#VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each : block 0 is $8000-87FF, block 1 is $8800-8FFF, block -1 is $9000-$97FF. Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block -1 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the tile at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>j38dq8zy1ls7gwm5iiscnq3nzri4084</sha1>
    </revision>
    <revision>
      <id>780</id>
      <parentid>779</parentid>
      <timestamp>2017-10-03T02:26:12Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* FF46 - DMA - DMA Transfer and Start Address (R/W) */ Added two little bits of info</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31306">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy and SGB: BG Display =====
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

===== CGB in Non CGB Mode: BG and Window Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

Sprites are not displayed while OAM DMA is being performed.


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM, but is slightly slower overall (except in some specific cases).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. And the upper bit of FF55 indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value if FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program may not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed!
Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 may return any value for the lower 7 bits, but Bit 7 will be read as &quot;1&quot;.

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000h-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two [[#VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each : block 0 is $8000-87FF, block 1 is $8800-8FFF, block -1 is $9000-$97FF. Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block -1 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the tile at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>ljndsy69qtwenb8ujf2eusgjitrw7i3</sha1>
    </revision>
    <revision>
      <id>781</id>
      <parentid>780</parentid>
      <timestamp>2017-10-15T02:10:59Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* LCD VRAM DMA Transfers (CGB only) */ Fixed some info about CGB DMA</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="32374">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy and SGB: BG Display =====
When Bit 0 is cleared, the background becomes blank (white). Window and Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

===== CGB in Non CGB Mode: BG and Window Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).
This is a possible compatibility problem - any monochrome games (if any) that disable the background, but still want to display the window wouldn't work properly on CGBs.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

Sprites are not displayed while OAM DMA is being performed.


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM, but is slightly slower overall (except in some specific cases).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address to which the data will be copied. [Note : bits are supposedly ignored so this is in VRAM, but it doesn't seem to actually be the case...]

The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000h-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two [[#VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each : block 0 is $8000-87FF, block 1 is $8800-8FFF, block -1 is $9000-$97FF. Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block -1 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the tile at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>kmipvou1h3qekk5soaj39tqaczro7o3</sha1>
    </revision>
    <revision>
      <id>801</id>
      <parentid>781</parentid>
      <timestamp>2018-09-10T23:59:55Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* LCDC.0 - BG/Window Display/Priority */ Apparently DMG and SGB ignore bit 5 as well when bit 0 is reset. Kinda makes sense.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="32029">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy, SGB and CGB in Non-CGB Mode: BG Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

Sprites are not displayed while OAM DMA is being performed.


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM, but is slightly slower overall (except in some specific cases).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address to which the data will be copied. [Note : bits are supposedly ignored so this is in VRAM, but it doesn't seem to actually be the case...]

The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000h-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two [[#VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each : block 0 is $8000-87FF, block 1 is $8800-8FFF, block -1 is $9000-$97FF. Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block -1 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the tile at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>gs4vne0s3nh5pvpl065qp825yp5zsfr</sha1>
    </revision>
    <revision>
      <id>806</id>
      <parentid>801</parentid>
      <timestamp>2018-11-09T14:58:27Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* FF46 - DMA - DMA Transfer and Start Address (R/W) */ correct cycle count for taken jr</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="32029">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy, SGB and CGB in Non-CGB Mode: BG Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about 169-175 clks. A complete cycle through these states takes 456 clks. VBlank lasts 4560 clks. A complete screen refresh occurs every 70224 clks.)


A hardware bug in the gray Game Boys makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB and ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using video ram so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

Due to a hardware bug, if WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).


=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.


=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|VGA versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors:
The highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display will mix colors quite oddly, increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..0Fh are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). A relative simple method would be using the formula GBA=CGB/2+10h for each R,G,B intensity, probably the result won't be perfect, and (once colors become visible) it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

It takes 160 microseconds until the transfer has completed (80 microseconds in CGB Double Speed Mode), during this time the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160ms
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Most programs are executing this procedure from inside of their VBlank procedure, but it is possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen).

Sprites are not displayed while OAM DMA is being performed.


A more compact procedure is
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, c = 46h, b = 29h. This saves 5 bytes of HRAM, but is slightly slower overall (except in some specific cases).

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address to which the data will be copied. [Note : bits are supposedly ignored so this is in VRAM, but it doesn't seem to actually be the case...]

The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8us to transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode, and 16 'fast' cycles in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000h-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two [[#VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each : block 0 is $8000-87FF, block 1 is $8800-8FFF, block -1 is $9000-$97FF. Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block -1 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Gameboy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also an Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the tile at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable i.e. it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting). In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>nkmpv2phlyw8otopn7yrss0qm0x4oxq</sha1>
    </revision>
    <revision>
      <id>807</id>
      <parentid>806</parentid>
      <timestamp>2018-11-09T20:17:05Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>Use &quot;μs&quot; for microseconds; GBA black level is probably closer to 8 based on my tests using 144p Test Suite</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="33167">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware by burning in a black horizontal line similar to that which appears when the GB is turned off. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing. The first frame after the LCD is reenabled is completely white, though the LCD memory access pattern is as usual.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. This doesn't affect Mode 3 timings, just whether they are rendered or not.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy, SGB and CGB in Non-CGB Mode: BG Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109 μS. 0 is present about 48.6 μS, 2 about 19 μS, and 3 about 41 μS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

A complete cycle through these states takes 456 tstates. Mode 2 is present for 80 tstates, mode 3 about 170-240 tstates depending on where exactly the sprites, window, and fine scroll (SCX modulo 8) are positioned, and mode 0 for the rest of the scanline (up to 200 tstates). VBlank lasts 10 scanlines, or 4560 tstates. A complete screen refresh occurs every 154 lines, or 70224 tstates.)

A hardware bug in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. During this time, the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>4thfu2brwacx8poj0f3ib4mj1txgx71</sha1>
    </revision>
    <revision>
      <id>808</id>
      <parentid>807</parentid>
      <timestamp>2018-11-11T10:36:01Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* LCDC.1 - OBJ Display Enable */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="33295">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware by burning in a black horizontal line similar to that which appears when the GB is turned off. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing. The first frame after the LCD is reenabled is completely white, though the LCD memory access pattern is as usual.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. On DMG, this doesn't affect Mode 3 timings, just whether they are rendered or not; on CGB, timing is still affected.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

(Note: toggling mid-scanline might have funky results on DMG? Investigation needed.)

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy, SGB and CGB in Non-CGB Mode: BG Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109 μS. 0 is present about 48.6 μS, 2 about 19 μS, and 3 about 41 μS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

A complete cycle through these states takes 456 tstates. Mode 2 is present for 80 tstates, mode 3 about 170-240 tstates depending on where exactly the sprites, window, and fine scroll (SCX modulo 8) are positioned, and mode 0 for the rest of the scanline (up to 200 tstates). VBlank lasts 10 scanlines, or 4560 tstates. A complete screen refresh occurs every 154 lines, or 70224 tstates.)

A hardware bug in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. During this time, the CPU can access only HRAM (memory at FF80-FFFE). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>jmexav76itndhqcm47erg0vv9u8reon</sha1>
    </revision>
    <revision>
      <id>809</id>
      <parentid>808</parentid>
      <timestamp>2018-11-11T10:38:30Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* FF46 - DMA - DMA Transfer and Start Address (R/W) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="33451">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware by burning in a black horizontal line similar to that which appears when the GB is turned off. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing. The first frame after the LCD is reenabled is completely white, though the LCD memory access pattern is as usual.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. On DMG, this doesn't affect Mode 3 timings, just whether they are rendered or not; on CGB, timing is still affected.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

(Note: toggling mid-scanline might have funky results on DMG? Investigation needed.)

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy, SGB and CGB in Non-CGB Mode: BG Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109 μS. 0 is present about 48.6 μS, 2 about 19 μS, and 3 about 41 μS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

A complete cycle through these states takes 456 tstates. Mode 2 is present for 80 tstates, mode 3 about 170-240 tstates depending on where exactly the sprites, window, and fine scroll (SCX modulo 8) are positioned, and mode 0 for the rest of the scanline (up to 200 tstates). VBlank lasts 10 scanlines, or 4560 tstates. A complete screen refresh occurs every 154 lines, or 70224 tstates.)

A hardware bug in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>tmd8x6qnrbpyrqrrub76zax2hx4lta7</sha1>
    </revision>
    <revision>
      <id>822</id>
      <parentid>809</parentid>
      <timestamp>2018-12-05T18:57:11Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* LCDC.7 - LCD Display Enable */ Add potential important note about disabling screen on SGB</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="33578">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware by burning in a black horizontal line similar to that which appears when the GB is turned off. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

On SGB, the screen doesn't turn white, it appears that the previous picture sticks to the screen. (TODO: research this more.)

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing. The first frame after the LCD is reenabled is completely white, though the LCD memory access pattern is as usual.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. On DMG, this doesn't affect Mode 3 timings, just whether they are rendered or not; on CGB, timing is still affected.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

(Note: toggling mid-scanline might have funky results on DMG? Investigation needed.)

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy, SGB and CGB in Non-CGB Mode: BG Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109 μS. 0 is present about 48.6 μS, 2 about 19 μS, and 3 about 41 μS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

A complete cycle through these states takes 456 tstates. Mode 2 is present for 80 tstates, mode 3 about 170-240 tstates depending on where exactly the sprites, window, and fine scroll (SCX modulo 8) are positioned, and mode 0 for the rest of the scanline (up to 200 tstates). VBlank lasts 10 scanlines, or 4560 tstates. A complete screen refresh occurs every 154 lines, or 70224 tstates.)

A hardware bug in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>s27wtz51l5yatil04gwopj7yqge2bkb</sha1>
    </revision>
    <revision>
      <id>830</id>
      <parentid>822</parentid>
      <timestamp>2019-01-20T02:29:22Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index */ Add Liji's finding about Mode 3 palette auto-increments</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="33649">{{Pandocs|videodisplay}}

== LCD Control Register ==
=== FF40 - LCDC - LCD Control (R/W) ===

LCDC is special, because it can be written to during Mode 3 (while graphics are being drawn), and '''will''' affect display during the scanline !

This could be used for very complex video effects, but they will probably fail to render properly on most emulators. (They could be pretty sick though)

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

==== LCDC.7 - LCD Display Enable ====
CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed during V-Blank ONLY, disabling the display outside of the V-Blank period may damage the hardware by burning in a black horizontal line similar to that which appears when the GB is turned off. This appears to be a serious issue, Nintendo is reported to reject any games that do not follow this rule.

V-blank can be confirmed when the value of LY is greater than or equal to 144. When the display is disabled the screen is blank (white), and VRAM and OAM can be accessed freely.

On SGB, the screen doesn't turn white, it appears that the previous picture sticks to the screen. (TODO: research this more.)

When re-enabling the LCD, it will immediately start at LY = 0, meaning it will immediately start drawing. The first frame after the LCD is reenabled is completely white, though the LCD memory access pattern is as usual.

==== LCDC.6 - Window Tile Map Display Select ====

This bit controls which [[#VRAM_Background_Maps|background map]] the Window uses for rendering. Note that the window will always use the &quot;top-left&quot; data, ie. the data you'd see at SCY = 0, SCX = 0, as its top-left point.

==== LCDC.5 - Window Display Enable ====

This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this mid-scanline ?)

Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored. (TODO : test this.)

==== LCDC.4 - BG &amp; Window Tile Data Select ====

This bit controls which addressing mode the BG and Window use to pick tiles. (See [[#VRAM_Tile_Data|below]] for details on addressing modes).

==== LCDC.3 - BG Tile Map Display Select ====

This bit works similarly to bit 6 (explained above).

==== LCDC.2 - OBJ Size ====

This bit controls the sprite size (1 tile or 2 stacked vertically).

Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and cause artifacts.

==== LCDC.1 - OBJ Display Enable ====

This bit toggles whether sprites are displayed or not. On DMG, this doesn't affect Mode 3 timings, just whether they are rendered or not; on CGB, timing is still affected.

This can be toggled mid-frame, for example to avoid sprites being displayed above a status bar or text box.

(Note: toggling mid-scanline might have funky results on DMG? Investigation needed.)

==== LCDC.0 - BG/Window Display/Priority ====

LCDC.0 has different meanings depending on Gameboy type and Mode:

===== Monochrome Gameboy, SGB and CGB in Non-CGB Mode: BG Display =====
When Bit 0 is cleared, both background and window become blank (white), ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites may still be displayed (if enabled in Bit 1).

===== CGB in CGB Mode: BG and Window Master Priority =====
When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on top of background and window, independently of the priority flags in OAM and BG Map attributes.

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109 μS. 0 is present about 48.6 μS, 2 about 19 μS, and 3 about 41 μS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

A complete cycle through these states takes 456 tstates. Mode 2 is present for 80 tstates, mode 3 about 170-240 tstates depending on where exactly the sprites, window, and fine scroll (SCX modulo 8) are positioned, and mode 0 for the rest of the scanline (up to 200 tstates). VBlank lasts 10 scanlines, or 4560 tstates. A complete screen refresh occurs every 154 lines, or 70224 tstates.)

A hardware bug in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still causes auto-increment to occur.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>45oknf4gtt6bzka4eqadon7lnsstxmm</sha1>
    </revision>
    <revision>
      <id>847</id>
      <parentid>830</parentid>
      <timestamp>2019-02-02T23:30:51Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>Move LCDC data to its own article. Needs to be done for the rest too, but that'll be later.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="30231">{{Pandocs|videodisplay}}

== LCD Control Register ==
Detailed article: [[LCDC]]

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

  Mode 0: The LCD controller is in the H-Blank period and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
  
  Mode 1: The LCD controller is in the V-Blank period (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
  
  Mode 2: The LCD controller is reading from OAM memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
  
  Mode 3: The LCD controller is reading from both OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____


The Mode Flag goes through the values 0, 2, and 3 at a cycle of about 109 μS. 0 is present about 48.6 μS, 2 about 19 μS, and 3 about 41 μS. This is interrupted every 16.6ms by the VBlank (1). The mode flag stays set at 1 for about 1.08 ms.

A complete cycle through these states takes 456 tstates. Mode 2 is present for 80 tstates, mode 3 about 170-240 tstates depending on where exactly the sprites, window, and fine scroll (SCX modulo 8) are positioned, and mode 0 for the rest of the scanline (up to 200 tstates). VBlank lasts 10 scanlines, or 4560 tstates. A complete screen refresh occurs every 154 lines, or 70224 tstates.)

A hardware bug in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during a H-Blank or V-Blank period.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still causes auto-increment to occur.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>qx53zk7jwj4fv1071jviieuasfmh0vi</sha1>
    </revision>
    <revision>
      <id>853</id>
      <parentid>847</parentid>
      <timestamp>2019-02-14T04:25:50Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* FF41 - STAT - LCDC Status (R/W) */ Reorganize modes as table; add sprite cost formula; &quot;as if&quot; description of STAT bug</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="31835">{{Pandocs|videodisplay}}

== LCD Control Register ==
Detailed article: [[LCDC]]

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

The LCD controller operates on a 2&lt;sup&gt;22&lt;/sup&gt; Hz = 4.194 MHz dot clock. An entire frame is 154 scanlines, 70224 dots, or 16.74 ms. On scanlines 0 through 143, the LCD controller cycles through modes 2, 3, and 0 once every 456 dots. Scanlines 144 through 153 are mode 1.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____

When the LCD controller is reading a particular part of video memory, that memory is inaccessible to the CPU.
* During modes 2 and 3, the CPU cannot access OAM (FE00h-FE9Fh).
* During mode 3, the CPU cannot access VRAM or CGB Palette Data (FF69,FF6B).

&lt;!-- 2, 3, 0, 1 because that's their order in the frame --&gt;
{| class=&quot;wikitable&quot;
|+ Properties of STAT modes
! Mode || Action || Duration || Accessible video memory
|-
| Mode 2
| Scanning OAM for (X, Y) coordinates of sprites that overlap this line
| 80 dots (19 us)
| VRAM, CGB palettes
|-
| Mode 3
| Reading OAM and VRAM to generate the picture
| 168 to 291 cycles (40 to 60 us) depending on sprite count
| None
|-
| Mode 0
| Horizontal blanking
| 85 to 208 dots (20 to 49 us) depending on previous mode 3 duration
| VRAM, OAM, CGB palettes
|-
| Mode 1
| Vertical blanking
| 4560 dots (1087 us, 10 scanlines)
| VRAM, OAM, CGB palettes
|}

Unlike most game consoles, the Game Boy can pause the dot clock briefly. It routinely takes a 6 to 11 dot break to fetch sprite patterns between background tile pattern fetches. On DMG and GBC in DMG mode, mid-scanline writes to &lt;code&gt;BGP&lt;/code&gt; allow observing this behavior, as a sprite delay shifts the effect of a write to the left by that many dots.

Each sprite usually adds &lt;code&gt;11 - min(5, (x + SCX) % 8)&lt;/code&gt; dots to mode 3. Because sprite fetch waits for background fetch to finish, a sprite's cost depends on its position relative to left side of the background tile under it. It's greater if a sprite is directly aligned over the background tile, less if the sprite is to the right. If the sprite's left side is over the window, use &lt;code&gt;255 - WX&lt;/code&gt; for &lt;code&gt;SCX&lt;/code&gt; in the formula. An active window also adds at least 6 dots to mode 3, as the background fetching mechanism starts over at the left side of the window.

VRAM can be written during a period comprising mode 0 on one line and mode 2 on the following line. These sum to 165 to 288 dots. For comparison, at single speed (4 dots per machine cycle), a copy from stack that takes 9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots.

'''Not fully understood:''' The exact timing for window start is not confirmed; it may have the same background fetch finish delay as a sprite. If two sprites' left sides are over the same background or window tile, the second may take fewer cycles.

A hardware bug in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during OAM scan, H-Blank, V-Blank, or LY=LYC. It behaves as if $FF were written for one cycle, and then the written value were written the next cycle. Because the GBC in DMG mode does not have this bug, two games that depend on this bug (Ocean's ''Road Rash'' and Vic Tokai's ''Xerd no Densetsu'') will not run on a GBC.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still causes auto-increment to occur.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the &lt;end&gt; of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns.
In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>l3i9ldrhvy6r2sl69mmqellwtfzhf9z</sha1>
    </revision>
    <revision>
      <id>854</id>
      <parentid>853</parentid>
      <timestamp>2019-02-14T05:03:46Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>Move comment about fitting 8 bytes into mode 0+2 down from hardware description section to programming advice section</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="32040">{{Pandocs|videodisplay}}

== LCD Control Register ==
Detailed article: [[LCDC]]

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

The LCD controller operates on a 2&lt;sup&gt;22&lt;/sup&gt; Hz = 4.194 MHz dot clock. An entire frame is 154 scanlines, 70224 dots, or 16.74 ms. On scanlines 0 through 143, the LCD controller cycles through modes 2, 3, and 0 once every 456 dots. Scanlines 144 through 153 are mode 1.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____

When the LCD controller is reading a particular part of video memory, that memory is inaccessible to the CPU.
* During modes 2 and 3, the CPU cannot access OAM (FE00h-FE9Fh).
* During mode 3, the CPU cannot access VRAM or CGB Palette Data (FF69,FF6B).

&lt;!-- 2, 3, 0, 1 because that's their order in the frame --&gt;
{| class=&quot;wikitable&quot;
|+ Properties of STAT modes
! Mode || Action || Duration || Accessible video memory
|-
| Mode 2
| Scanning OAM for (X, Y) coordinates of sprites that overlap this line
| 80 dots (19 us)
| VRAM, CGB palettes
|-
| Mode 3
| Reading OAM and VRAM to generate the picture
| 168 to 291 cycles (40 to 60 us) depending on sprite count
| None
|-
| Mode 0
| Horizontal blanking
| 85 to 208 dots (20 to 49 us) depending on previous mode 3 duration
| VRAM, OAM, CGB palettes
|-
| Mode 1
| Vertical blanking
| 4560 dots (1087 us, 10 scanlines)
| VRAM, OAM, CGB palettes
|}

Unlike most game consoles, the Game Boy can pause the dot clock briefly. It routinely takes a 6 to 11 dot break to fetch sprite patterns between background tile pattern fetches. On DMG and GBC in DMG mode, mid-scanline writes to &lt;code&gt;BGP&lt;/code&gt; allow observing this behavior, as a sprite delay shifts the effect of a write to the left by that many dots.

Each sprite usually adds &lt;code&gt;11 - min(5, (x + SCX) % 8)&lt;/code&gt; dots to mode 3. Because sprite fetch waits for background fetch to finish, a sprite's cost depends on its position relative to left side of the background tile under it. It's greater if a sprite is directly aligned over the background tile, less if the sprite is to the right. If the sprite's left side is over the window, use &lt;code&gt;255 - WX&lt;/code&gt; for &lt;code&gt;SCX&lt;/code&gt; in the formula. An active window also adds at least 6 dots to mode 3, as the background fetching mechanism starts over at the left side of the window.

'''Not fully understood:''' The exact timing for window start is not confirmed; it may have the same background fetch finish delay as a sprite. If two sprites' left sides are over the same background or window tile, the second may take fewer cycles.

A hardware bug in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during OAM scan, H-Blank, V-Blank, or LY=LYC. It behaves as if $FF were written for one cycle, and then the written value were written the next cycle. Because the GBC in DMG mode does not have this bug, two games that depend on this bug (Ocean's ''Road Rash'' and Vic Tokai's ''Xerd no Densetsu'') will not run on a GBC.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still causes auto-increment to occur.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the ''end'' of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns. In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

If you're not using LCD interrupts, another way to synchronize to the start of mode 0 is to use &lt;code&gt;halt&lt;/code&gt; with IME turned off (&lt;code&gt;di&lt;/code&gt;). This allows use of the entire mode 0 on one line and mode 2 on the following line, which sum to 165 to 288 dots. For comparison, at single speed (4 dots per machine cycle), a [[Popslide|copy from stack]] that takes 9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots, which fits within the worst case timing for mode 0+2.

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>imbu8kqctixoj5pn4j0g2mzxo94nj5x</sha1>
    </revision>
    <revision>
      <id>855</id>
      <parentid>854</parentid>
      <timestamp>2019-02-14T14:27:02Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* FF41 - STAT - LCDC Status (R/W) */ LIJI32 told me I forgot SCX mod 8</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="32350">{{Pandocs|videodisplay}}

== LCD Control Register ==
Detailed article: [[LCDC]]

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

The LCD controller operates on a 2&lt;sup&gt;22&lt;/sup&gt; Hz = 4.194 MHz dot clock. An entire frame is 154 scanlines, 70224 dots, or 16.74 ms. On scanlines 0 through 143, the LCD controller cycles through modes 2, 3, and 0 once every 456 dots. Scanlines 144 through 153 are mode 1.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____

When the LCD controller is reading a particular part of video memory, that memory is inaccessible to the CPU.
* During modes 2 and 3, the CPU cannot access OAM (FE00h-FE9Fh).
* During mode 3, the CPU cannot access VRAM or CGB Palette Data (FF69,FF6B).

&lt;!-- 2, 3, 0, 1 because that's their order in the frame --&gt;
{| class=&quot;wikitable&quot;
|+ Properties of STAT modes
! Mode || Action || Duration || Accessible video memory
|-
| Mode 2
| Scanning OAM for (X, Y) coordinates of sprites that overlap this line
| 80 dots (19 us)
| VRAM, CGB palettes
|-
| Mode 3
| Reading OAM and VRAM to generate the picture
| 168 to 291 cycles (40 to 60 us) depending on sprite count
| None
|-
| Mode 0
| Horizontal blanking
| 85 to 208 dots (20 to 49 us) depending on previous mode 3 duration
| VRAM, OAM, CGB palettes
|-
| Mode 1
| Vertical blanking
| 4560 dots (1087 us, 10 scanlines)
| VRAM, OAM, CGB palettes
|}

Unlike most game consoles, the Game Boy can pause the dot clock briefly, adding dots to mode 3's duration. It routinely takes a 6 to 11 dot break to fetch sprite patterns between background tile pattern fetches. On DMG and GBC in DMG mode, mid-scanline writes to &lt;code&gt;BGP&lt;/code&gt; allow observing this behavior, as a sprite delay shifts the effect of a write to the left by that many dots.

Three things are known to pause the dot clock:
;Background scrolling
:If &lt;code&gt;SCX mod 8&lt;/code&gt; is not zero at the start of the scanline, rendering is paused for that many dots while the shifter discards that many pixels from the leftmost tile.
;Window
:An active window pauses for at least 6 dots, as the background fetching mechanism starts over at the left side of the window.
;Sprites
:Each sprite usually pauses for &lt;code&gt;11 - min(5, (x + SCX) mod 8)&lt;/code&gt; dots. Because sprite fetch waits for background fetch to finish, a sprite's cost depends on its position relative to the left side of the background tile under it. It's greater if a sprite is directly aligned over the background tile, less if the sprite is to the right. If the sprite's left side is over the window, use &lt;code&gt;255 - WX&lt;/code&gt; for &lt;code&gt;SCX&lt;/code&gt; in this formula. 

'''Not fully understood:''' The exact pause duration for window start is not confirmed; it may have the same background fetch finish delay as a sprite. If two sprites' left sides are over the same background or window tile, the second may pause for fewer dots.

A hardware quirk in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during OAM scan, H-Blank, V-Blank, or LY=LYC. It behaves as if $FF were written for one cycle, and then the written value were written the next cycle. Because the GBC in DMG mode does not have this quirk, two games that depend on this quirk (Ocean's ''Road Rash'' and Vic Tokai's ''Xerd no Densetsu'') will not run on a GBC.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still causes auto-increment to occur.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
When sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

Only 10 sprites can be displayed on any one line. When this limit is exceeded, the lower sprites (in their order in OAM, $FE00-$FE03 being the highest) won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the ''end'' of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns. In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

If you're not using LCD interrupts, another way to synchronize to the start of mode 0 is to use &lt;code&gt;halt&lt;/code&gt; with IME turned off (&lt;code&gt;di&lt;/code&gt;). This allows use of the entire mode 0 on one line and mode 2 on the following line, which sum to 165 to 288 dots. For comparison, at single speed (4 dots per machine cycle), a [[Popslide|copy from stack]] that takes 9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots, which fits within the worst case timing for mode 0+2.

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>g2ykwk13noiuk68f7hflni3kl16tx38</sha1>
    </revision>
    <revision>
      <id>856</id>
      <parentid>855</parentid>
      <timestamp>2019-02-14T14:42:59Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* Sprite Priorities and Conflicts */ DMG X sorting is only within the 10 sprites appearing first in OAM</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="32958">{{Pandocs|videodisplay}}

== LCD Control Register ==
Detailed article: [[LCDC]]

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

The LCD controller operates on a 2&lt;sup&gt;22&lt;/sup&gt; Hz = 4.194 MHz dot clock. An entire frame is 154 scanlines, 70224 dots, or 16.74 ms. On scanlines 0 through 143, the LCD controller cycles through modes 2, 3, and 0 once every 456 dots. Scanlines 144 through 153 are mode 1.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____

When the LCD controller is reading a particular part of video memory, that memory is inaccessible to the CPU.
* During modes 2 and 3, the CPU cannot access OAM (FE00h-FE9Fh).
* During mode 3, the CPU cannot access VRAM or CGB Palette Data (FF69,FF6B).

&lt;!-- 2, 3, 0, 1 because that's their order in the frame --&gt;
{| class=&quot;wikitable&quot;
|+ Properties of STAT modes
! Mode || Action || Duration || Accessible video memory
|-
| Mode 2
| Scanning OAM for (X, Y) coordinates of sprites that overlap this line
| 80 dots (19 us)
| VRAM, CGB palettes
|-
| Mode 3
| Reading OAM and VRAM to generate the picture
| 168 to 291 cycles (40 to 60 us) depending on sprite count
| None
|-
| Mode 0
| Horizontal blanking
| 85 to 208 dots (20 to 49 us) depending on previous mode 3 duration
| VRAM, OAM, CGB palettes
|-
| Mode 1
| Vertical blanking
| 4560 dots (1087 us, 10 scanlines)
| VRAM, OAM, CGB palettes
|}

Unlike most game consoles, the Game Boy can pause the dot clock briefly, adding dots to mode 3's duration. It routinely takes a 6 to 11 dot break to fetch sprite patterns between background tile pattern fetches. On DMG and GBC in DMG mode, mid-scanline writes to &lt;code&gt;BGP&lt;/code&gt; allow observing this behavior, as a sprite delay shifts the effect of a write to the left by that many dots.

Three things are known to pause the dot clock:
;Background scrolling
:If &lt;code&gt;SCX mod 8&lt;/code&gt; is not zero at the start of the scanline, rendering is paused for that many dots while the shifter discards that many pixels from the leftmost tile.
;Window
:An active window pauses for at least 6 dots, as the background fetching mechanism starts over at the left side of the window.
;Sprites
:Each sprite usually pauses for &lt;code&gt;11 - min(5, (x + SCX) mod 8)&lt;/code&gt; dots. Because sprite fetch waits for background fetch to finish, a sprite's cost depends on its position relative to the left side of the background tile under it. It's greater if a sprite is directly aligned over the background tile, less if the sprite is to the right. If the sprite's left side is over the window, use &lt;code&gt;255 - WX&lt;/code&gt; for &lt;code&gt;SCX&lt;/code&gt; in this formula. 

'''Not fully understood:''' The exact pause duration for window start is not confirmed; it may have the same background fetch finish delay as a sprite. If two sprites' left sides are over the same background or window tile, the second may pause for fewer dots.

A hardware quirk in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during OAM scan, H-Blank, V-Blank, or LY=LYC. It behaves as if $FF were written for one cycle, and then the written value were written the next cycle. Because the GBC in DMG mode does not have this quirk, two games that depend on this quirk (Ocean's ''Road Rash'' and Vic Tokai's ''Xerd no Densetsu'') will not run on a GBC.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still causes auto-increment to occur.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
During each scanline's OAM scan, the LCD controller compares LY to each sprite's Y position to find the 10 sprites on that line that appear first in OAM ($FE00-$FE03 being the first). It discards the rest, allowing only 10 sprites to be displayed on any one line. When this limit is exceeded, sprites appearing later in OAM won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y =&gt; 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X =&gt; 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

When these 10 sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

The priority calculation between sprites disregards OBJ-to-BG Priority (attribute bit 7). Only the highest-priority sprite is compared against the background. Thus if a sprite with a higher priority (based on OAM index) but with OBJ-to-BG Priority turned on overlaps a sprite with a lower priority and a nonzero background pixel, the background pixel is displayed even if the lower-priority sprite's OBJ-to-BG Priority is on.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the ''end'' of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns. In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

If you're not using LCD interrupts, another way to synchronize to the start of mode 0 is to use &lt;code&gt;halt&lt;/code&gt; with IME turned off (&lt;code&gt;di&lt;/code&gt;). This allows use of the entire mode 0 on one line and mode 2 on the following line, which sum to 165 to 288 dots. For comparison, at single speed (4 dots per machine cycle), a [[Popslide|copy from stack]] that takes 9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots, which fits within the worst case timing for mode 0+2.

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>2abom54en9wv8bn82cezu325ddfhjws</sha1>
    </revision>
    <revision>
      <id>857</id>
      <parentid>856</parentid>
      <timestamp>2019-02-14T14:48:01Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <minor/>
      <comment>/* Sprite Priorities and Conflicts */ &quot;regardless&quot; should work better here</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="32991">{{Pandocs|videodisplay}}

== LCD Control Register ==
Detailed article: [[LCDC]]

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

The LCD controller operates on a 2&lt;sup&gt;22&lt;/sup&gt; Hz = 4.194 MHz dot clock. An entire frame is 154 scanlines, 70224 dots, or 16.74 ms. On scanlines 0 through 143, the LCD controller cycles through modes 2, 3, and 0 once every 456 dots. Scanlines 144 through 153 are mode 1.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____

When the LCD controller is reading a particular part of video memory, that memory is inaccessible to the CPU.
* During modes 2 and 3, the CPU cannot access OAM (FE00h-FE9Fh).
* During mode 3, the CPU cannot access VRAM or CGB Palette Data (FF69,FF6B).

&lt;!-- 2, 3, 0, 1 because that's their order in the frame --&gt;
{| class=&quot;wikitable&quot;
|+ Properties of STAT modes
! Mode || Action || Duration || Accessible video memory
|-
| Mode 2
| Scanning OAM for (X, Y) coordinates of sprites that overlap this line
| 80 dots (19 us)
| VRAM, CGB palettes
|-
| Mode 3
| Reading OAM and VRAM to generate the picture
| 168 to 291 cycles (40 to 60 us) depending on sprite count
| None
|-
| Mode 0
| Horizontal blanking
| 85 to 208 dots (20 to 49 us) depending on previous mode 3 duration
| VRAM, OAM, CGB palettes
|-
| Mode 1
| Vertical blanking
| 4560 dots (1087 us, 10 scanlines)
| VRAM, OAM, CGB palettes
|}

Unlike most game consoles, the Game Boy can pause the dot clock briefly, adding dots to mode 3's duration. It routinely takes a 6 to 11 dot break to fetch sprite patterns between background tile pattern fetches. On DMG and GBC in DMG mode, mid-scanline writes to &lt;code&gt;BGP&lt;/code&gt; allow observing this behavior, as a sprite delay shifts the effect of a write to the left by that many dots.

Three things are known to pause the dot clock:
;Background scrolling
:If &lt;code&gt;SCX mod 8&lt;/code&gt; is not zero at the start of the scanline, rendering is paused for that many dots while the shifter discards that many pixels from the leftmost tile.
;Window
:An active window pauses for at least 6 dots, as the background fetching mechanism starts over at the left side of the window.
;Sprites
:Each sprite usually pauses for &lt;code&gt;11 - min(5, (x + SCX) mod 8)&lt;/code&gt; dots. Because sprite fetch waits for background fetch to finish, a sprite's cost depends on its position relative to the left side of the background tile under it. It's greater if a sprite is directly aligned over the background tile, less if the sprite is to the right. If the sprite's left side is over the window, use &lt;code&gt;255 - WX&lt;/code&gt; for &lt;code&gt;SCX&lt;/code&gt; in this formula. 

'''Not fully understood:''' The exact pause duration for window start is not confirmed; it may have the same background fetch finish delay as a sprite. If two sprites' left sides are over the same background or window tile, the second may pause for fewer dots.

A hardware quirk in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during OAM scan, H-Blank, V-Blank, or LY=LYC. It behaves as if $FF were written for one cycle, and then the written value were written the next cycle. Because the GBC in DMG mode does not have this quirk, two games that depend on this quirk (Ocean's ''Road Rash'' and Vic Tokai's ''Xerd no Densetsu'') will not run on a GBC.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period. Writing will reset the counter.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still causes auto-increment to occur.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
During each scanline's OAM scan, the LCD controller compares LY to each sprite's Y position to find the 10 sprites on that line that appear first in OAM ($FE00-$FE03 being the first). It discards the rest, allowing only 10 sprites to be displayed on any one line. When this limit is exceeded, sprites appearing later in OAM won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y &gt;= 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X &gt;= 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

When these 10 sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

The priority calculation between sprites disregards OBJ-to-BG Priority (attribute bit 7). Only the highest-priority nonzero sprite pixel at any given point is compared against the background. Thus if a sprite with a higher priority (based on OAM index) but with OBJ-to-BG Priority turned on overlaps a sprite with a lower priority and a nonzero background pixel, the background pixel is displayed regardless of the lower-priority sprite's OBJ-to-BG Priority.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the ''end'' of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns. In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

If you're not using LCD interrupts, another way to synchronize to the start of mode 0 is to use &lt;code&gt;halt&lt;/code&gt; with IME turned off (&lt;code&gt;di&lt;/code&gt;). This allows use of the entire mode 0 on one line and mode 2 on the following line, which sum to 165 to 288 dots. For comparison, at single speed (4 dots per machine cycle), a [[Popslide|copy from stack]] that takes 9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots, which fits within the worst case timing for mode 0+2.

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>p4xnaavwwnv81ug7ddfxo4lofgb28hx</sha1>
    </revision>
    <revision>
      <id>902</id>
      <parentid>857</parentid>
      <timestamp>2019-07-26T05:12:36Z</timestamp>
      <contributor>
        <username>Mattcurrie</username>
        <id>85</id>
      </contributor>
      <comment>/* FF44 - LY - LCDC Y-Coordinate (R) */ Writing to LY does not reset the counter. Verified by test ROM.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="32959">{{Pandocs|videodisplay}}

== LCD Control Register ==
Detailed article: [[LCDC]]

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

The LCD controller operates on a 2&lt;sup&gt;22&lt;/sup&gt; Hz = 4.194 MHz dot clock. An entire frame is 154 scanlines, 70224 dots, or 16.74 ms. On scanlines 0 through 143, the LCD controller cycles through modes 2, 3, and 0 once every 456 dots. Scanlines 144 through 153 are mode 1.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____

When the LCD controller is reading a particular part of video memory, that memory is inaccessible to the CPU.
* During modes 2 and 3, the CPU cannot access OAM (FE00h-FE9Fh).
* During mode 3, the CPU cannot access VRAM or CGB Palette Data (FF69,FF6B).

&lt;!-- 2, 3, 0, 1 because that's their order in the frame --&gt;
{| class=&quot;wikitable&quot;
|+ Properties of STAT modes
! Mode || Action || Duration || Accessible video memory
|-
| Mode 2
| Scanning OAM for (X, Y) coordinates of sprites that overlap this line
| 80 dots (19 us)
| VRAM, CGB palettes
|-
| Mode 3
| Reading OAM and VRAM to generate the picture
| 168 to 291 cycles (40 to 60 us) depending on sprite count
| None
|-
| Mode 0
| Horizontal blanking
| 85 to 208 dots (20 to 49 us) depending on previous mode 3 duration
| VRAM, OAM, CGB palettes
|-
| Mode 1
| Vertical blanking
| 4560 dots (1087 us, 10 scanlines)
| VRAM, OAM, CGB palettes
|}

Unlike most game consoles, the Game Boy can pause the dot clock briefly, adding dots to mode 3's duration. It routinely takes a 6 to 11 dot break to fetch sprite patterns between background tile pattern fetches. On DMG and GBC in DMG mode, mid-scanline writes to &lt;code&gt;BGP&lt;/code&gt; allow observing this behavior, as a sprite delay shifts the effect of a write to the left by that many dots.

Three things are known to pause the dot clock:
;Background scrolling
:If &lt;code&gt;SCX mod 8&lt;/code&gt; is not zero at the start of the scanline, rendering is paused for that many dots while the shifter discards that many pixels from the leftmost tile.
;Window
:An active window pauses for at least 6 dots, as the background fetching mechanism starts over at the left side of the window.
;Sprites
:Each sprite usually pauses for &lt;code&gt;11 - min(5, (x + SCX) mod 8)&lt;/code&gt; dots. Because sprite fetch waits for background fetch to finish, a sprite's cost depends on its position relative to the left side of the background tile under it. It's greater if a sprite is directly aligned over the background tile, less if the sprite is to the right. If the sprite's left side is over the window, use &lt;code&gt;255 - WX&lt;/code&gt; for &lt;code&gt;SCX&lt;/code&gt; in this formula. 

'''Not fully understood:''' The exact pause duration for window start is not confirmed; it may have the same background fetch finish delay as a sprite. If two sprites' left sides are over the same background or window tile, the second may pause for fewer dots.

A hardware quirk in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during OAM scan, H-Blank, V-Blank, or LY=LYC. It behaves as if $FF were written for one cycle, and then the written value were written the next cycle. Because the GBC in DMG mode does not have this quirk, two games that depend on this quirk (Ocean's ''Road Rash'' and Vic Tokai's ''Xerd no Densetsu'') will not run on a GBC.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still causes auto-increment to occur.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
During each scanline's OAM scan, the LCD controller compares LY to each sprite's Y position to find the 10 sprites on that line that appear first in OAM ($FE00-$FE03 being the first). It discards the rest, allowing only 10 sprites to be displayed on any one line. When this limit is exceeded, sprites appearing later in OAM won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y &gt;= 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X &gt;= 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

When these 10 sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

The priority calculation between sprites disregards OBJ-to-BG Priority (attribute bit 7). Only the highest-priority nonzero sprite pixel at any given point is compared against the background. Thus if a sprite with a higher priority (based on OAM index) but with OBJ-to-BG Priority turned on overlaps a sprite with a lower priority and a nonzero background pixel, the background pixel is displayed regardless of the lower-priority sprite's OBJ-to-BG Priority.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the ''end'' of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns. In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

If you're not using LCD interrupts, another way to synchronize to the start of mode 0 is to use &lt;code&gt;halt&lt;/code&gt; with IME turned off (&lt;code&gt;di&lt;/code&gt;). This allows use of the entire mode 0 on one line and mode 2 on the following line, which sum to 165 to 288 dots. For comparison, at single speed (4 dots per machine cycle), a [[Popslide|copy from stack]] that takes 9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots, which fits within the worst case timing for mode 0+2.

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>2sj5yvb44bshj9u3gqeon8q4wbdhjbd</sha1>
    </revision>
    <revision>
      <id>932</id>
      <parentid>902</parentid>
      <timestamp>2019-10-12T19:52:46Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* VRAM Tile Data */ Add link to ShantyTown's explanation of the graphics format</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="33055">{{Pandocs|videodisplay}}

== LCD Control Register ==
Detailed article: [[LCDC]]

  Bit 7 - LCD Display Enable             (0=Off, 1=On)
  Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - Window Display Enable          (0=Off, 1=On)
  Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
  Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)

== LCD Status Register ==
=== FF41 - STAT - LCDC Status (R/W) ===
  Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM
            3: During Transferring Data to LCD Driver

The two lower STAT bits show the current status of the LCD controller.

The LCD controller operates on a 2&lt;sup&gt;22&lt;/sup&gt; Hz = 4.194 MHz dot clock. An entire frame is 154 scanlines, 70224 dots, or 16.74 ms. On scanlines 0 through 143, the LCD controller cycles through modes 2, 3, and 0 once every 456 dots. Scanlines 144 through 153 are mode 1.

The following are typical when the display is enabled:
  Mode 2  2_____2_____2_____2_____2_____2___________________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____

When the LCD controller is reading a particular part of video memory, that memory is inaccessible to the CPU.
* During modes 2 and 3, the CPU cannot access OAM (FE00h-FE9Fh).
* During mode 3, the CPU cannot access VRAM or CGB Palette Data (FF69,FF6B).

&lt;!-- 2, 3, 0, 1 because that's their order in the frame --&gt;
{| class=&quot;wikitable&quot;
|+ Properties of STAT modes
! Mode || Action || Duration || Accessible video memory
|-
| Mode 2
| Scanning OAM for (X, Y) coordinates of sprites that overlap this line
| 80 dots (19 us)
| VRAM, CGB palettes
|-
| Mode 3
| Reading OAM and VRAM to generate the picture
| 168 to 291 cycles (40 to 60 us) depending on sprite count
| None
|-
| Mode 0
| Horizontal blanking
| 85 to 208 dots (20 to 49 us) depending on previous mode 3 duration
| VRAM, OAM, CGB palettes
|-
| Mode 1
| Vertical blanking
| 4560 dots (1087 us, 10 scanlines)
| VRAM, OAM, CGB palettes
|}

Unlike most game consoles, the Game Boy can pause the dot clock briefly, adding dots to mode 3's duration. It routinely takes a 6 to 11 dot break to fetch sprite patterns between background tile pattern fetches. On DMG and GBC in DMG mode, mid-scanline writes to &lt;code&gt;BGP&lt;/code&gt; allow observing this behavior, as a sprite delay shifts the effect of a write to the left by that many dots.

Three things are known to pause the dot clock:
;Background scrolling
:If &lt;code&gt;SCX mod 8&lt;/code&gt; is not zero at the start of the scanline, rendering is paused for that many dots while the shifter discards that many pixels from the leftmost tile.
;Window
:An active window pauses for at least 6 dots, as the background fetching mechanism starts over at the left side of the window.
;Sprites
:Each sprite usually pauses for &lt;code&gt;11 - min(5, (x + SCX) mod 8)&lt;/code&gt; dots. Because sprite fetch waits for background fetch to finish, a sprite's cost depends on its position relative to the left side of the background tile under it. It's greater if a sprite is directly aligned over the background tile, less if the sprite is to the right. If the sprite's left side is over the window, use &lt;code&gt;255 - WX&lt;/code&gt; for &lt;code&gt;SCX&lt;/code&gt; in this formula. 

'''Not fully understood:''' The exact pause duration for window start is not confirmed; it may have the same background fetch finish delay as a sprite. If two sprites' left sides are over the same background or window tile, the second may pause for fewer dots.

A hardware quirk in the monochrome Game Boy makes the LCD interrupt sometimes trigger when writing to STAT (including writing $00) during OAM scan, H-Blank, V-Blank, or LY=LYC. It behaves as if $FF were written for one cycle, and then the written value were written the next cycle. Because the GBC in DMG mode does not have this quirk, two games that depend on this quirk (Ocean's ''Road Rash'' and Vic Tokai's ''Xerd no Densetsu'') will not run on a GBC.

==  LCD Interrupts ==

=== INT 40 - V-Blank Interrupt ===
The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a Super Game Boy (SGB). This interrupt occurs at the beginning of the V-Blank period (LY=144).
During this period video hardware is not using VRAM so it may be freely accessed. This period lasts approximately 1.1 milliseconds.

=== INT 48 - LCDC Status Interrupt ===
There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to perform special video effects.

Example application : set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.

The interrupt is triggered when transitioning from &quot;No conditions met&quot; to &quot;Any condition met&quot;, which can cause the interrupt to not fire. Example : the Mode 0 and LY=LYC interrupts are enabled ; since the latter triggers during Mode 2 (right after Mode 0), the interrupt will trigger for Mode 0 but fail to for LY=LYC.

== LCD Position and Scrolling ==

These registers can be accessed even during Mode 3, but they have no effect until the end of the current scanline.

=== FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W) ===
Specifies the position in the 256x256 pixels BG map (32x32 tiles) which is to be displayed at the upper/left LCD display position.
Values in range from 0-255 may be used for X/Y each, the video controller automatically wraps back to the upper (left) position in BG map when drawing exceeds the lower (right) border of the BG map area.

=== FF44 - LY - LCDC Y-Coordinate (R) ===
The LY indicates the vertical line to which the present data is transferred to the LCD Driver. The LY can take on any value between 0 through 153. The values between 144 and 153 indicate the V-Blank period.

=== FF45 - LYC - LY Compare (R/W) ===
The Gameboy permanently compares the value of the LYC and LY registers. When both values are identical, the coincident bit in the STAT register becomes set, and (if enabled) a STAT interrupt is requested.

=== FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W) ===
Specifies the upper/left positions of the Window area. (The window is an alternate background area which can be displayed above of the normal background. OBJs (sprites) may be still displayed above or behind the window, just as for normal BG.)

The window becomes visible (if enabled) when positions are set in range WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at upper left, it is then completely covering normal background.

WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set to 0, the window will &quot;stutter&quot; horizontally when SCX changes. (Depending on SCX modulo 8, behavior is a little complicated so you should try it yourself.)

== LCD Monochrome Palettes ==
=== FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades to the color numbers of the BG and Window tiles.
  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0

The four possible gray shades are:
  0  White
  1  Light gray
  2  Dark gray
  3  Black

In CGB Mode the Color Palettes are taken from CGB Palette Memory instead.

=== FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 0. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

=== FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only ===
This register assigns gray shades for sprite palette 1. It works exactly as BGP (FF47), except that the lower two bits aren't used because sprite data 00 is transparent.

== LCD Color Palettes (CGB only) ==
=== FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index ===
This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)

Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still causes auto-increment to occur.

Unlike the following, this register can be accessed outside V-Blank and H-Blank.

=== FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data ===
This register allows to read/write data to the CGBs Background Palette Memory, addressed through Register FF68.
Each color is defined by two bytes (Bit 0-7 in first byte).
  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)

Much like VRAM, data in Palette Memory cannot be read/written during the time when the LCD Controller is reading from it. (That is when the STAT register indicates Mode 3).
Note: All background colors are initialized as white by the boot ROM, but it's a good idea to initialize at least one color yourself (for example if you include a soft-reset mechanic).

=== FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data ===
These registers are used to initialize the Sprite Palettes OBP0-7, identically as described above for Background Palettes. Note that four colors may be defined for each OBP Palettes - but only Color 1-3 of each Sprite Palette can be displayed, Color 0 is always transparent, and can be initialized to a don't care value or plain never initialized.

Note: All sprite colors are left uninitialized by the boot ROM, and are somewhat random.

=== RGB Translation by CGBs ===
[[File:VGA_versus_CGB.png|150px|thumb|right|sRGB versus CGB color mixing]]
When developing graphics on PCs, note that the RGB values will have different appearance on CGB displays as on VGA/HDMI monitors calibrated to sRGB color.
Because the GBC is not lit, the highest intensity will produce Light Gray color rather than White. The intensities are not linear; the values 10h-1Fh will all appear very bright, while medium and darker colors are ranged at 00h-0Fh.

The CGB display's pigments aren't perfectly saturated. This means the colors mix quite oddly; increasing intensity of only one R,G,B color will also influence the other two R,G,B colors.
For example, a color setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green on VGA displays, but on the CGB it'll produce a decently washed out Yellow. See image on the right.

=== RGB Translation by GBAs ===
Even though GBA is described to be compatible to CGB games, most CGB games are completely unplayable on older GBAs because most colors are invisible (black). Of course, colors such like Black and White will appear the same on both CGB and GBA, but medium intensities are arranged completely different.
Intensities in range 00h..07h are invisible/black (unless eventually under best sunlight circumstances, and when gazing at the screen under obscure viewing angles), unfortunately, these intensities are regularly used by most existing CGB games for medium and darker colors.

Newer CGB games may avoid this effect by changing palette data when detecting GBA hardware ([[CGB_Registers#Detecting_CGB_.28and_GBA.29_functions|see how]]). Based on measurement of GBC and GBA palettes using the &quot;144p Test Suite&quot; ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for each R,G,B intensity. The result isn't quite perfect, and it may turn out that the color mixing is different also; anyways, it'd be still ways better than no conversion.
Asides, this translation method should have been VERY easy to implement in GBA hardware directly, even though Nintendo obviously failed to do so. How did they say, &quot;This seal is your assurance for excellence in workmanship&quot; and so on?

This problem with low brightness levels does not affect later GBA SP units and Game Boy Player. Thus ideally, the player should have control of this brightness correction.

== LCD OAM DMA Transfers ==
=== FF46 - DMA - DMA Transfer and Start Address (R/W) ===
Writing to this register launches a DMA transfer from ROM or RAM to OAM memory (sprite attribute table). The written value specifies the transfer source address divided by 100h, ie. source &amp; destination are:
  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F

The transfer takes 160 machine cycles: 152 microseconds in normal speed or 76 microseconds in CGB Double Speed Mode. On DMG, during this time, the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used by the source area cannot be used (this isn't understood well at the moment, it's recommended to assume same behavior as DMG). For this reason, the programmer must copy a short procedure into HRAM, and use this procedure to start the transfer from inside HRAM, and wait until the transfer has finished:

  run_dma:
   ld a, start address / 100h
   ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
   ld  a,28h      ;delay...
  wait:           ;total 4x40 cycles, approx 160 μs
   dec a          ;1 cycle
   jr  nz,wait    ;3 cycles
   ret

Because sprites are not displayed while OAM DMA is in progress, most programs are executing this procedure from inside of their VBlank procedure. But it is also possible to execute it during display redraw also, allowing to display more than 40 sprites on the screen (ie. for example 40 sprites in upper half, and other 40 sprites in lower half of the screen), at the cost of a couple lines that lack sprites.

A more compact procedure is

  run_dma:  ; This part is in ROM
   ld a, start address / 100h
   ld bc, 2946h  ; B: wait time; C: OAM trigger
   jp run_dma_hrampart

  run_dma_hrampart:
   ldh ($FF00+c), a
  wait:
   dec b
   jr nz,wait
   ret
which should be called with a = start address / 100h, bc = 2946h. This saves 5 bytes of HRAM, but is slightly slower in most cases because of the jump into the HRAM part.

== LCD VRAM DMA Transfers (CGB only) ==
=== FF51 - HDMA1 - CGB Mode Only - New DMA Source, High ===
=== FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low ===
These two registers specify the address at which the transfer will read data from. Normally, this should be either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.

The four lower bits of this address will be ignored and treated as 0.

=== FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High ===
=== FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low ===
These two registers specify the address within 8000-9FF0 to which the data will be copied.
Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.

=== FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start ===
These registers are used to initiate a DMA transfer from ROM or RAM to VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0, the lower four bits of the address are ignored (treated as zero). The Destination Start Address may be located at 8000-9FF0, the lower four bits of the address are ignored (treated as zero), the upper 3 bits are ignored either (destination is always in VRAM).

Writing to this register starts the transfer, the lower 7 bits of which specify the Transfer Length (divided by 10h, minus 1), ie. lengths of 10h-800h bytes can be defined by the values 00h-7Fh. The upper bit indicates the Transfer Mode:

==== Bit7=0 - General Purpose DMA ====
When using this transfer method, all data is transferred at once. The execution of the program is halted until the transfer has completed. Note that the General Purpose DMA blindly attempts to copy the data, even if the LCD controller is currently accessing VRAM. So General Purpose DMA should be used only if the Display is disabled, or during V-Blank, or (for rather short blocks) during H-Blank.
The execution of the program continues when the transfer has been completed, and FF55 then contains a value of FFh.

==== Bit7=1 - H-Blank DMA ====
The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at LY=0-143, no data is transferred during V-Blank (LY=144-153), but the transfer will then continue at LY=00. The execution of the program is halted during the separate transfers, but the program execution continues during the 'spaces' between each data block.
Note that the program should not change the Destination VRAM bank (FF4F), or the Source ROM/RAM bank (in case data is transferred from bankable memory) until the transfer has completed! (The transfer should be paused as described below while the banks are switched)

Reading from Register FF55 returns the remaining length (divided by 10h, minus 1), a value of 0FFh indicates that the transfer has completed. It is also possible to terminate an active H-Blank transfer by writing zero to Bit 7 of FF55. In that case reading from FF55 will return how many $10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.

=== Precautions ===
H-Blank DMA should not be started (write to FF55) during a H-Blank period (STAT mode 0).

If the transfer's destination address overflows, the transfer stops prematurely. [Note : what's the state of the registers if this happens ?]

=== Confirming if the DMA Transfer is Active ===
Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is active (1=Not Active, 0=Active). This works under any circumstances - after completion of General Purpose, or H-Blank Transfer, and after manually terminating a H-Blank Transfer.

=== Transfer Timings ===
In both Normal Speed and Double Speed Mode it takes about 8 μs to transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode, and 16 'fast' tstates in Double Speed Mode.
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed to support General Purpose or H-Blank DMA, that's because there are always 2 bytes transferred per microsecond (even if the itself program runs it Normal Speed Mode).

== VRAM Tile Data ==
Tile Data is stored in VRAM at addresses $8000-97FF; with one tile being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode, this is doubled (768 tiles) because of the two VRAM banks.

Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray shades. Tiles can be displayed as part of the Background/Window map, and/or as OAM tiles (foreground sprites). Note that foreground sprites don't use color 0 - it's transparent instead.

There are three &quot;blocks&quot; of 128 tiles each:

* Block 0 is $8000-87FF
* Block 1 is $8800-8FFF
* Block 2 is $9000-97FF

Tiles are always indexed using a 8-bit integer, but the addressing method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer and uses an unsigned addressing, meaning that tiles 0-127 are in block 0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as its base pointer and uses a signed addressing. To put it differently, &quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255 from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2 and tiles 128-255 from block 1. (You can notice that block 1 is shared by both addressing methods)

Sprites always use 8000 addressing, but the BG and Window can use either mode, controlled by [[#LCDC.4_-_BG_.26_Window_Tile_Data_Select|LCDC bit 4]]. 

Each Tile occupies 16 bytes, where each 2 bytes represent a line:
  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.

For each line, the first byte defines the least significant bits of the color numbers for each pixel, and the second byte defines the upper bits of the color numbers. In either case, Bit 7 is the leftmost pixel, and Bit 0 the rightmost. For example : let's say you have $57 $36 (in this order in memory). To obtain the color index for the leftmost pixel, you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b = 1 (remember to flip the order of the bits !). If you repeat the operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3 3 1.

A more visual explanation can be found [https://www.huderlem.com/demos/gameboy2bpp.html here].

So, each pixel is having a color number in range from 0-3. The color numbers are translated into real colors (or gray shades) depending on the current palettes. The palettes are defined through registers [[#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|BGP]], [[#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP0]] and [[#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only|OBP1]] (Non CGB Mode), and [[#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index|BCPS/BGPI]], [[#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data|BCPD/BGPD]], [[#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data|OCPS/OBPI and OCPD/OBPD]] (CGB Mode).

== VRAM Background Maps ==
The Game Boy contains two 32x32 tile background maps in VRAM at addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display &quot;normal&quot; background, or &quot;window&quot; background.

=== BG Map Tile Numbers ===
An area of VRAM known as Background Tile Map contains the numbers of tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each byte contains a number of a tile to be displayed.

Tile patterns are taken from the Tile Data Table using either of the two addressing modes (described [[#VRAM_Tile_Data|above]]), which can be selected via LCDC register.

As one background tile has a size of 8x8 pixels, the BG maps may hold a picture of 256x256 pixels, and an area of 160x144 pixels of this picture can be displayed on the LCD screen.

=== BG Map Attributes (CGB Mode only) ===
In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1 (each byte defines attributes for the corresponding tile-number map entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at 0:9800):
  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
  Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
  Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)

When Bit 7 is set, the corresponding BG tile will have priority above all OBJs (regardless of the priority bits in OAM memory). There's also a Master Priority flag in LCDC register Bit 0 which overrides all other priority bits when cleared.

Note that, if the map entry at 0:9800 is tile $2A, the attribute at 1:9800 doesn't define properties for ALL tiles $2A on-screen, but only the one at 0:9800 !

=== Normal Background (BG) ===
The SCY and SCX registers can be used to scroll the background, allowing to select the origin of the visible 160x144 pixel area within the total 256x256 pixel background map. Background wraps around the screen (i.e. when part of it goes off the screen, it appears on the opposite side.)

=== The Window ===
Besides background, there is also a &quot;window&quot; overlaying the background. The window is not scrollable, that is, it is always displayed starting from its left upper corner. The location of a window on the screen can be adjusted via WX and WY registers. Screen coordinates of the top left corner of a window are WX-7,WY. The tiles for the window are stored in the Tile Data Table. Both the Background and the window share the same Tile Data Table.

Both background and window can be disabled or enabled separately via bits in the LCDC register.

== VRAM Banks (CGB only) ==
The CGB has twice the VRAM of the DMG, but it is banked and either bank has a different purpose.

=== FF4F - VBK - CGB Mode Only - VRAM Bank (R/W) ===
This register can be written to to change VRAM banks. Only bit 0 matters, all other bits are ignored.

=== VRAM bank 1 ===
VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles (just like in bank 0), which can be accessed the same way as (and at the same time as) bank 0 tiles. 9800-9FFF contains the attributes for the corresponding Tile Maps.

Reading from this register will return the number of the currently loaded VRAM bank in bit 0, and all other bits will be set to 1.

== VRAM Sprite Attribute Table (OAM) ==
Gameboy video controller can display up to 40 sprites either in 8x8 or in 8x16 pixels. Because of a limitation of hardware, only ten sprites can be displayed per scan line. Sprite patterns have the same format as BG tiles, but they are taken from the Sprite Pattern Table located at $8000-8FFF and have unsigned numbering.

Sprite attributes reside in the Sprite Attribute Table (OAM - Object Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four bytes with the following meanings:

=== Byte0 - Y Position ===
Specifies the sprites vertical position on the screen (minus 16).
An off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.

=== Byte1 - X Position ===
Specifies the sprites horizontal position on the screen (minus 8).
An off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite
still affects the priority ordering - a better way to hide a sprite is to set its Y-coordinate off-screen.

=== Byte2 - Tile/Pattern Number ===
Specifies the sprites Tile Number (00-FF). This (unsigned) value selects a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in VRAM Bank 0 or 1, depending on Bit 3 of the following byte.
In 8x16 mode, the lower bit of the tile number is ignored. IE: the upper 8x8 tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.

=== Byte3 - Attributes/Flags: ===
  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)


=== Sprite Priorities and Conflicts ===
During each scanline's OAM scan, the LCD controller compares LY to each sprite's Y position to find the 10 sprites on that line that appear first in OAM ($FE00-$FE03 being the first). It discards the rest, allowing only 10 sprites to be displayed on any one line. When this limit is exceeded, sprites appearing later in OAM won't be displayed. To keep unused sprites from affecting onscreen sprites, set their Y coordinate to Y = 0 or Y &gt;= 160 (144 + 16) (Note : Y &lt;= 8 also works if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or X &gt;= 168 (160 + 8) on a sprite will hide it, but it will still affect other sprites sharing the same lines.

If using [[BGB]], in the VRAM viewer - OAM tab, hover your mouse over the small screen to highlight the sprites on a line. Sprites hidden due to the limitation will be highlighted in red.

When these 10 sprites overlap, the highest priority one will appear above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In Non-CGB mode, the smaller the X coordinate, the higher the priority. The tie breaker (same X coordinates) is the same priority as in CGB mode.

The priority calculation between sprites disregards OBJ-to-BG Priority (attribute bit 7). Only the highest-priority nonzero sprite pixel at any given point is compared against the background. Thus if a sprite with a higher priority (based on OAM index) but with OBJ-to-BG Priority turned on overlaps a sprite with a lower priority and a nonzero background pixel, the background pixel is displayed regardless of the lower-priority sprite's OBJ-to-BG Priority.

=== Writing Data to OAM Memory ===
The recommended method is to write the data to normal RAM first, and to copy that RAM to OAM by using the DMA transfer function, initiated through DMA register (FF46).
Beside for that, it is also possible to write data directly to the OAM area by using normal LD commands, this works only during the H-Blank and V-Blank periods. The current state of the LCD controller can be read out from the STAT register (FF41).

== Accessing VRAM and OAM ==
=== CAUTION ===
When the LCD Controller is drawing the screen it is directly reading from Video Memory (VRAM) and from the Sprite Attribute Table (OAM). During these periods the Gameboy CPU may not access the VRAM and OAM. That means, any attempts to write to VRAM/OAM are ignored (the data remains unchanged). And any attempts to read from VRAM/OAM will return undefined data (typically a value of FFh).

For this reason the program should verify if VRAM/OAM is accessible before actually reading or writing to it. This is usually done by reading the Mode Bits from the STAT Register (FF41). When doing this (as described in the examples below) you should take care that no interrupts occur between the wait loops and the following memory access - the memory is guaranteed to be accessible only for a few cycles directly after the wait loops have completed.

=== VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2 ===
  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period

A typical procedure that waits for accessibility of VRAM would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/

Even if the procedure gets executed at the ''end'' of Mode 0 or 1, it is still proof to assume that VRAM can be accessed for a few more cycles because in either case the following period is Mode 2 which allows access to VRAM either. However, be careful about STAT LCD interrupts or other interrupts that could cause the LCD to be back in mode 3 by the time it returns. In CGB Mode an alternate method to write data to VRAM is to use the HDMA Function (FF51-FF55).

If you're not using LCD interrupts, another way to synchronize to the start of mode 0 is to use &lt;code&gt;halt&lt;/code&gt; with IME turned off (&lt;code&gt;di&lt;/code&gt;). This allows use of the entire mode 0 on one line and mode 2 on the following line, which sum to 165 to 288 dots. For comparison, at single speed (4 dots per machine cycle), a [[Popslide|copy from stack]] that takes 9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots, which fits within the worst case timing for mode 0+2.

=== OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1 ===
  Mode 0 - H-Blank Period
  Mode 1 - V-Blank Period

Aside from that, OAM can be accessed at any time by using the DMA Function (FF46). When directly reading or writing to OAM, a typical procedure that waits for accessibility of OAM Memory would be:
  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/

The two wait loops ensure that Mode 0 or 1 will last for a few clock cycles after completion of the procedure. In V-Blank period it might be recommended to skip the whole procedure - and in most cases using the above mentioned DMA function would be more recommended anyways.

=== Note ===
When the display is disabled, both VRAM and OAM are accessible at any time. The downside is that the screen is blank (white) during this period, so that disabling the display would be recommended only during initialization.</text>
      <sha1>6m3uedzstyv0lh26aqdimy3o9m6p7tv</sha1>
    </revision>
  </page>
  <page>
    <title>Sound Controller</title>
    <ns>0</ns>
    <id>51</id>
    <revision>
      <id>155</id>
      <timestamp>2009-06-28T10:53:47Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: == Sound Overview ==  There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either ...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9097">== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

FF18 - NR23 - Channel 2 Frequency lo data (W)
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the gameboys internal four channels. As far as I know this feature isn't used by any existing games.

===FF25 - NR51 - Selection of Sound output terminal (R/W)===

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.</text>
      <sha1>6v4q6vacmhuvkt3y8nytt0lyn6zf2mf</sha1>
    </revision>
    <revision>
      <id>166</id>
      <parentid>155</parentid>
      <timestamp>2009-06-28T12:44:01Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9126">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

FF18 - NR23 - Channel 2 Frequency lo data (W)
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the gameboys internal four channels. As far as I know this feature isn't used by any existing games.

===FF25 - NR51 - Selection of Sound output terminal (R/W)===

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.</text>
      <sha1>0l7avti691xt46jlqn5vqqz3dziajnq</sha1>
    </revision>
    <revision>
      <id>600</id>
      <parentid>166</parentid>
      <timestamp>2015-08-10T01:23:28Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <minor/>
      <comment>/* FF17 - NR22 - Channel 2 Volume Envelope (R/W) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9132">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the gameboys internal four channels. As far as I know this feature isn't used by any existing games.

===FF25 - NR51 - Selection of Sound output terminal (R/W)===

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.</text>
      <sha1>sgzw79sishav918624ntwbw3t9feih9</sha1>
    </revision>
    <revision>
      <id>746</id>
      <parentid>600</parentid>
      <timestamp>2017-05-09T16:51:07Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>Link to two orphaned documents. Second should be merged here.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9199">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the gameboys internal four channels. As far as I know this feature isn't used by any existing games.

===FF25 - NR51 - Selection of Sound output terminal (R/W)===

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.


== Read more ==
[[Wavetable Archive]]
[[Gameboy sound hardware]]</text>
      <sha1>sizxekw5kd5mm2vm27elhqxnvpmj5cv</sha1>
    </revision>
    <revision>
      <id>747</id>
      <parentid>746</parentid>
      <timestamp>2017-05-09T16:51:37Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Read more */ Add newline. I really need to click &quot;Preview&quot; more.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9200">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the gameboys internal four channels. As far as I know this feature isn't used by any existing games.

===FF25 - NR51 - Selection of Sound output terminal (R/W)===

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.


== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]</text>
      <sha1>518ypnxkgo1ellgi4bklh3ve5m9s7su</sha1>
    </revision>
    <revision>
      <id>748</id>
      <parentid>747</parentid>
      <timestamp>2017-05-09T16:52:41Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* Read more */ Add another orphaned article, which should also be merged.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9220">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the gameboys internal four channels. As far as I know this feature isn't used by any existing games.

===FF25 - NR51 - Selection of Sound output terminal (R/W)===

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.


== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>prc94bi8qklz7t3yzcwrfychr01fvhz</sha1>
    </revision>
    <revision>
      <id>793</id>
      <parentid>748</parentid>
      <timestamp>2018-07-29T01:48:12Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* Sound Control Registers */ Clarify based on my tests: SO2 = left</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9339">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output. SO2 goes to the left headphone, and SO1 goes to the right.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the gameboys internal four channels. As far as I know this feature isn't used by any existing games.

===FF25 - NR51 - Selection of Sound output terminal (R/W)===
Each channel can be panned hard left, center, or hard right.

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>7v912a6f12kbczrx5gwd1m57yco70y9</sha1>
    </revision>
    <revision>
      <id>868</id>
      <parentid>793</parentid>
      <timestamp>2019-04-18T02:15:39Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* FF24 - NR50 - Channel control / ON-OFF / Volume (R/W) */ No licensed games use this, not even Pocket Music, and it's not on GBA</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9577">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output. SO2 goes to the left headphone, and SO1 goes to the right.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is an analog signal received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the Game Boy's internal four channels. No licensed games used this feature, and it was omitted from the Game Boy Advance.

(Despite rumors, ''Pocket Music'' does not use Vin. It blocks use on the GBA for a different reason: the developer couldn't figure out how to silence buzzing associated with the wave channel's DAC.)

===FF25 - NR51 - Selection of Sound output terminal (R/W)===
Each channel can be panned hard left, center, or hard right.

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>ou9jxg216t3us8myj4vcvq8qddecfcm</sha1>
    </revision>
    <revision>
      <id>879</id>
      <parentid>868</parentid>
      <timestamp>2019-05-31T19:59:53Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>Add sections about technical explanations</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12341">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output. SO2 goes to the left headphone, and SO1 goes to the right.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is an analog signal received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the Game Boy's internal four channels. No licensed games used this feature, and it was omitted from the Game Boy Advance.

(Despite rumors, ''Pocket Music'' does not use Vin. It blocks use on the GBA for a different reason: the developer couldn't figure out how to silence buzzing associated with the wave channel's DAC.)

===FF25 - NR51 - Selection of Sound output terminal (R/W)===
Each channel can be panned hard left, center, or hard right.

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

==Pitfalls==
Enabling or disabling a DAC (resetting NR30 bit 7 or writing %0000 0XXX to NRx2 for other channels), adding or removing it using NR51, will cause an audio pop. (This causes a change in DC offset, which is smoothed out by a high-pass circuit over time, but still creates a pop)

When first starting up a pulse channel, it will ''always'' output a (digital) zero.

The pulse channels' &quot;duty step&quot; (at which position in the duty cycle they are) can't be reset. The exception to this is turning off the APU, which causes them to start over from 0 when turning it on.

Restarting a pulse channel causes its &quot;duty step timer&quot; to reset, meaning that &quot;tickling&quot; a pulse channel regularly enough will cause its &quot;duty step&quot; to never advance.

When turning off CH3, the nibble being played is latched, but may become a 0 over time (TODO: this needs to be researched. Do individual bits decay?). When turning the channel on again, that value is played first, then the second nibble (lower 4 bits of $FF30) plays.


==APU technical explanation==
===Game Boy, Game Boy Color===
Each of the 4 channels work pretty identically. First, there's a &quot;generation&quot; circuit, which usually outputs either a 0 or another value (CH3 differs in that it can output multiple values, but regardless). That value is digital, and can range between 0 and 7. This is then fed to a [https://en.wikipedia.org/wiki/Digital-to-analog_converter DAC], which maps this to an analog value; 7 maps to the lowest (negative) voltage, 0 to the highest (positive) one. Finally, all channels are mixed through NR51, scaled through NR50, and sent to the output.

Each DAC is controlled independently from the generation circuit. For CH3, the DAC is controlled by NR30 bit 7; for other channels, the DAC is turned on unless bits 3-7 of NRx2 are reset, and the values output will be 0 and &lt;code&gt;[NRx2] &gt;&gt; 4&lt;/code&gt;. The generation circuits are turned on by restarting them for the first time, and this is what sets the corresponding bit in NR52. Yes, it's possible to turn on a DAC but not the generation circuit. Finally, disabling a DAC also kills the generation circuit.

Note that each DAC has a DC offset, so enabling, disabling, adding to or removing from NR51, will all cause an audio pop.

Finally, all the output goes through a high-pass filter to remove the DC offsets from the DACs.

===Game Boy Advance===
The APU was reworked pretty heavily for the GBA. Instead of mixing being done analogically, it's instead done digitally; then, sound is converted to an analog signal and an offset is added (see SOUNDBIAS in [http://problemkaputt.de/gbatek.htm#gbasoundcontrolregisters GBATEK] for more details.

This means that the APU has no DACs, or if modelling the GBA as a GB, they're always on.


== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>k87a7fabpawtc3jyy6jq5l3ix4euyiy</sha1>
    </revision>
    <revision>
      <id>880</id>
      <parentid>879</parentid>
      <timestamp>2019-05-31T20:10:38Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Pitfalls */ Add another condition under which a pop my be heard</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12372">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output. SO2 goes to the left headphone, and SO1 goes to the right.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is an analog signal received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the Game Boy's internal four channels. No licensed games used this feature, and it was omitted from the Game Boy Advance.

(Despite rumors, ''Pocket Music'' does not use Vin. It blocks use on the GBA for a different reason: the developer couldn't figure out how to silence buzzing associated with the wave channel's DAC.)

===FF25 - NR51 - Selection of Sound output terminal (R/W)===
Each channel can be panned hard left, center, or hard right.

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

==Pitfalls==
Enabling or disabling a DAC (resetting NR30 bit 7 or writing %0000 0XXX to NRx2 for other channels), adding or removing it using NR51, or changing the volume in NR50, will cause an audio pop. (This causes a change in DC offset, which is smoothed out by a high-pass circuit over time, but still creates a pop)

When first starting up a pulse channel, it will ''always'' output a (digital) zero.

The pulse channels' &quot;duty step&quot; (at which position in the duty cycle they are) can't be reset. The exception to this is turning off the APU, which causes them to start over from 0 when turning it on.

Restarting a pulse channel causes its &quot;duty step timer&quot; to reset, meaning that &quot;tickling&quot; a pulse channel regularly enough will cause its &quot;duty step&quot; to never advance.

When turning off CH3, the nibble being played is latched, but may become a 0 over time (TODO: this needs to be researched. Do individual bits decay?). When turning the channel on again, that value is played first, then the second nibble (lower 4 bits of $FF30) plays.

==APU technical explanation==
===Game Boy, Game Boy Color===
Each of the 4 channels work pretty identically. First, there's a &quot;generation&quot; circuit, which usually outputs either a 0 or another value (CH3 differs in that it can output multiple values, but regardless). That value is digital, and can range between 0 and 7. This is then fed to a [https://en.wikipedia.org/wiki/Digital-to-analog_converter DAC], which maps this to an analog value; 7 maps to the lowest (negative) voltage, 0 to the highest (positive) one. Finally, all channels are mixed through NR51, scaled through NR50, and sent to the output.

Each DAC is controlled independently from the generation circuit. For CH3, the DAC is controlled by NR30 bit 7; for other channels, the DAC is turned on unless bits 3-7 of NRx2 are reset, and the values output will be 0 and &lt;code&gt;[NRx2] &gt;&gt; 4&lt;/code&gt;. The generation circuits are turned on by restarting them for the first time, and this is what sets the corresponding bit in NR52. Yes, it's possible to turn on a DAC but not the generation circuit. Finally, disabling a DAC also kills the generation circuit.

Note that each DAC has a DC offset, so enabling, disabling, adding to or removing from NR51, will all cause an audio pop.

Finally, all the output goes through a high-pass filter to remove the DC offsets from the DACs.

===Game Boy Advance===
The APU was reworked pretty heavily for the GBA. Instead of mixing being done analogically, it's instead done digitally; then, sound is converted to an analog signal and an offset is added (see SOUNDBIAS in [http://problemkaputt.de/gbatek.htm#gbasoundcontrolregisters GBATEK] for more details.

This means that the APU has no DACs, or if modelling the GBA as a GB, they're always on.


== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>4y2sraoh4fbalzro1koli1aydmzk88v</sha1>
    </revision>
    <revision>
      <id>881</id>
      <parentid>880</parentid>
      <timestamp>2019-05-31T20:15:38Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Pitfalls */ Reword and fix CH3 latching explanation (credits go to PinoBatch), add note about output level</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12621">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output. SO2 goes to the left headphone, and SO1 goes to the right.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is an analog signal received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the Game Boy's internal four channels. No licensed games used this feature, and it was omitted from the Game Boy Advance.

(Despite rumors, ''Pocket Music'' does not use Vin. It blocks use on the GBA for a different reason: the developer couldn't figure out how to silence buzzing associated with the wave channel's DAC.)

===FF25 - NR51 - Selection of Sound output terminal (R/W)===
Each channel can be panned hard left, center, or hard right.

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

==Pitfalls==
Enabling or disabling a DAC (resetting NR30 bit 7 or writing %0000 0XXX to NRx2 for other channels), adding or removing it using NR51, or changing the volume in NR50, will cause an audio pop. (This causes a change in DC offset, which is smoothed out by a high-pass circuit over time, but still creates a pop)

When first starting up a pulse channel, it will ''always'' output a (digital) zero.

The pulse channels' &quot;duty step&quot; (at which position in the duty cycle they are) can't be reset. The exception to this is turning off the APU, which causes them to start over from 0 when turning it on.

Restarting a pulse channel causes its &quot;duty step timer&quot; to reset, meaning that &quot;tickling&quot; a pulse channel regularly enough will cause its &quot;duty step&quot; to never advance.

When restarting CH3, it resumes playing the last 4-bit sample it read from wave RAM, or 0 if no sample has been read since APU reset. (Sample latching is independent of output level control in NR32.) After the latched sample completes, it starts with the second sample in wave RAM (low 4 bits of $FF30). The first sample (high 4 bits of $FF30) is played last.

CH3 output level control does not, in fact, alter the output level. It shifts the '''digital''' value CH3 is outputting (read below), not the analog value.

==APU technical explanation==
===Game Boy, Game Boy Color===
Each of the 4 channels work pretty identically. First, there's a &quot;generation&quot; circuit, which usually outputs either a 0 or another value (CH3 differs in that it can output multiple values, but regardless). That value is digital, and can range between 0 and 7. This is then fed to a [https://en.wikipedia.org/wiki/Digital-to-analog_converter DAC], which maps this to an analog value; 7 maps to the lowest (negative) voltage, 0 to the highest (positive) one. Finally, all channels are mixed through NR51, scaled through NR50, and sent to the output.

Each DAC is controlled independently from the generation circuit. For CH3, the DAC is controlled by NR30 bit 7; for other channels, the DAC is turned on unless bits 3-7 of NRx2 are reset, and the values output will be 0 and &lt;code&gt;[NRx2] &gt;&gt; 4&lt;/code&gt;. The generation circuits are turned on by restarting them for the first time, and this is what sets the corresponding bit in NR52. Yes, it's possible to turn on a DAC but not the generation circuit. Finally, disabling a DAC also kills the generation circuit.

Note that each DAC has a DC offset, so enabling, disabling, adding to or removing from NR51, will all cause an audio pop.

Finally, all the output goes through a high-pass filter to remove the DC offsets from the DACs.

===Game Boy Advance===
The APU was reworked pretty heavily for the GBA. Instead of mixing being done analogically, it's instead done digitally; then, sound is converted to an analog signal and an offset is added (see SOUNDBIAS in [http://problemkaputt.de/gbatek.htm#gbasoundcontrolregisters GBATEK] for more details.

This means that the APU has no DACs, or if modelling the GBA as a GB, they're always on.


== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>2wfjcxd5t73b3ld55g65h0pj48xrj1l</sha1>
    </revision>
    <revision>
      <id>882</id>
      <parentid>881</parentid>
      <timestamp>2019-05-31T20:16:10Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* APU technical explanation */ Fix mistakes</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12779">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output. SO2 goes to the left headphone, and SO1 goes to the right.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is an analog signal received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the Game Boy's internal four channels. No licensed games used this feature, and it was omitted from the Game Boy Advance.

(Despite rumors, ''Pocket Music'' does not use Vin. It blocks use on the GBA for a different reason: the developer couldn't figure out how to silence buzzing associated with the wave channel's DAC.)

===FF25 - NR51 - Selection of Sound output terminal (R/W)===
Each channel can be panned hard left, center, or hard right.

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

==Pitfalls==
Enabling or disabling a DAC (resetting NR30 bit 7 or writing %0000 0XXX to NRx2 for other channels), adding or removing it using NR51, or changing the volume in NR50, will cause an audio pop. (This causes a change in DC offset, which is smoothed out by a high-pass circuit over time, but still creates a pop)

When first starting up a pulse channel, it will ''always'' output a (digital) zero.

The pulse channels' &quot;duty step&quot; (at which position in the duty cycle they are) can't be reset. The exception to this is turning off the APU, which causes them to start over from 0 when turning it on.

Restarting a pulse channel causes its &quot;duty step timer&quot; to reset, meaning that &quot;tickling&quot; a pulse channel regularly enough will cause its &quot;duty step&quot; to never advance.

When restarting CH3, it resumes playing the last 4-bit sample it read from wave RAM, or 0 if no sample has been read since APU reset. (Sample latching is independent of output level control in NR32.) After the latched sample completes, it starts with the second sample in wave RAM (low 4 bits of $FF30). The first sample (high 4 bits of $FF30) is played last.

CH3 output level control does not, in fact, alter the output level. It shifts the '''digital''' value CH3 is outputting (read below), not the analog value.

==APU technical explanation==
===Game Boy, Game Boy Color===
Each of the 4 channels work pretty identically. First, there's a &quot;generation&quot; circuit, which usually outputs either a 0 or another value (CH3 differs in that it can output multiple values, but regardless). That value is digital, and can range between 0 and 0xF. This is then fed to a [https://en.wikipedia.org/wiki/Digital-to-analog_converter DAC], which maps this to an analog value; 7 maps to the lowest (negative) voltage, 0 to the highest (positive) one. Finally, all channels are mixed through NR51, scaled through NR50, and sent to the output.

Each DAC is controlled independently from the generation circuit. For CH3, the DAC is controlled by NR30 bit 7; for other channels, the DAC is turned on unless bits 3-7 of NRx2 are reset, and the envelope will be set to &lt;code&gt;[NRx2] &gt;&gt; 4&lt;/code&gt;. (Note: the envelope sweep function changes the envelope, but not the value in NRx2! It won't disable the DAC, either.) The generation circuits are turned on by restarting them for the first time, and this is what sets the corresponding bit in NR52. Yes, it's possible to turn on a DAC but not the generation circuit. Finally, disabling a DAC also kills the generation circuit.

Note that each DAC has a DC offset, so enabling, disabling, adding to or removing from NR51, will all cause an audio pop; changing the volume in NR50 will as well.

Finally, all the output goes through a high-pass filter to remove the DC offsets from the DACs.

===Game Boy Advance===
The APU was reworked pretty heavily for the GBA. Instead of mixing being done analogically, it's instead done digitally; then, sound is converted to an analog signal and an offset is added (see SOUNDBIAS in [http://problemkaputt.de/gbatek.htm#gbasoundcontrolregisters GBATEK] for more details.

This means that the APU has no DACs, or if modelling the GBA as a GB, they're always on.

== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>ozve9q9zzzxw6dubgg4t632fv33bxwx</sha1>
    </revision>
    <revision>
      <id>883</id>
      <parentid>882</parentid>
      <timestamp>2019-06-01T15:13:18Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Pitfalls */ Add discovery on CH3 being inverted. To quote Liji: This is idiotic / It's intentional, but why would they do it</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12946">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output. SO2 goes to the left headphone, and SO1 goes to the right.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is an analog signal received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the Game Boy's internal four channels. No licensed games used this feature, and it was omitted from the Game Boy Advance.

(Despite rumors, ''Pocket Music'' does not use Vin. It blocks use on the GBA for a different reason: the developer couldn't figure out how to silence buzzing associated with the wave channel's DAC.)

===FF25 - NR51 - Selection of Sound output terminal (R/W)===
Each channel can be panned hard left, center, or hard right.

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

==Pitfalls==
Enabling or disabling a DAC (resetting NR30 bit 7 or writing %0000 0XXX to NRx2 for other channels), adding or removing it using NR51, or changing the volume in NR50, will cause an audio pop. (This causes a change in DC offset, which is smoothed out by a high-pass circuit over time, but still creates a pop)

When first starting up a pulse channel, it will ''always'' output a (digital) zero.

The pulse channels' &quot;duty step&quot; (at which position in the duty cycle they are) can't be reset. The exception to this is turning off the APU, which causes them to start over from 0 when turning it on.

Restarting a pulse channel causes its &quot;duty step timer&quot; to reset, meaning that &quot;tickling&quot; a pulse channel regularly enough will cause its &quot;duty step&quot; to never advance.

When restarting CH3, it resumes playing the last 4-bit sample it read from wave RAM, or 0 if no sample has been read since APU reset. (Sample latching is independent of output level control in NR32.) After the latched sample completes, it starts with the second sample in wave RAM (low 4 bits of $FF30). The first sample (high 4 bits of $FF30) is played last.

CH3 output level control does not, in fact, alter the output level. It shifts the '''digital''' value CH3 is outputting (read below), not the analog value.

On GBA, CH3 is inverted. This causes the channel to output a loud spike when disabled; it's a good idea to &quot;remove&quot; the channel using NR51 while refreshing wave RAM.

==APU technical explanation==
===Game Boy, Game Boy Color===
Each of the 4 channels work pretty identically. First, there's a &quot;generation&quot; circuit, which usually outputs either a 0 or another value (CH3 differs in that it can output multiple values, but regardless). That value is digital, and can range between 0 and 0xF. This is then fed to a [https://en.wikipedia.org/wiki/Digital-to-analog_converter DAC], which maps this to an analog value; 7 maps to the lowest (negative) voltage, 0 to the highest (positive) one. Finally, all channels are mixed through NR51, scaled through NR50, and sent to the output.

Each DAC is controlled independently from the generation circuit. For CH3, the DAC is controlled by NR30 bit 7; for other channels, the DAC is turned on unless bits 3-7 of NRx2 are reset, and the envelope will be set to &lt;code&gt;[NRx2] &gt;&gt; 4&lt;/code&gt;. (Note: the envelope sweep function changes the envelope, but not the value in NRx2! It won't disable the DAC, either.) The generation circuits are turned on by restarting them for the first time, and this is what sets the corresponding bit in NR52. Yes, it's possible to turn on a DAC but not the generation circuit. Finally, disabling a DAC also kills the generation circuit.

Note that each DAC has a DC offset, so enabling, disabling, adding to or removing from NR51, will all cause an audio pop; changing the volume in NR50 will as well.

Finally, all the output goes through a high-pass filter to remove the DC offsets from the DACs.

===Game Boy Advance===
The APU was reworked pretty heavily for the GBA. Instead of mixing being done analogically, it's instead done digitally; then, sound is converted to an analog signal and an offset is added (see SOUNDBIAS in [http://problemkaputt.de/gbatek.htm#gbasoundcontrolregisters GBATEK] for more details.

This means that the APU has no DACs, or if modelling the GBA as a GB, they're always on.

== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>r46thtd993ugbja9kwtog5ox0piv3ag</sha1>
    </revision>
    <revision>
      <id>884</id>
      <parentid>883</parentid>
      <timestamp>2019-06-01T15:27:30Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Pitfalls */ Make pitfalls section into a list, add note about CH3 being inverted on GBA</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13198">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back upper 4 bits first.


== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output. SO2 goes to the left headphone, and SO1 goes to the right.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is an analog signal received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the Game Boy's internal four channels. No licensed games used this feature, and it was omitted from the Game Boy Advance.

(Despite rumors, ''Pocket Music'' does not use Vin. It blocks use on the GBA for a different reason: the developer couldn't figure out how to silence buzzing associated with the wave channel's DAC.)

===FF25 - NR51 - Selection of Sound output terminal (R/W)===
Each channel can be panned hard left, center, or hard right.

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

==Pitfalls==
* Enabling or disabling a DAC (resetting NR30 bit 7 or writing %0000 0XXX to NRx2 for other channels), adding or removing it using NR51, or changing the volume in NR50, will cause an audio pop. (This causes a change in DC offset, which is smoothed out by a high-pass circuit over time, but still creates a pop)

* The final output goes through a high-pass filter, which is more aggressive on GBA than on GBC, which is more aggressive than on DMG. (What this means is that the output is &quot;pulled&quot; towards 0V with various degrees of &quot;aggressiveness&quot;)

* When first starting up a pulse channel, it will ''always'' output a (digital) zero.

* The pulse channels' &quot;duty step&quot; (at which position in the duty cycle they are) can't be reset. The exception to this is turning off the APU, which causes them to start over from 0 when turning it on.

* Restarting a pulse channel causes its &quot;duty step timer&quot; to reset, meaning that &quot;tickling&quot; a pulse channel regularly enough will cause its &quot;duty step&quot; to never advance.

* When restarting CH3, it resumes playing the last 4-bit sample it read from wave RAM, or 0 if no sample has been read since APU reset. (Sample latching is independent of output level control in NR32.) After the latched sample completes, it starts with the second sample in wave RAM (low 4 bits of $FF30). The first sample (high 4 bits of $FF30) is played last.

* CH3 output level control does not, in fact, alter the output level. It shifts the '''digital''' value CH3 is outputting (read below), not the analog value.

* On GBA, CH3 is inverted. This causes the channel to output a loud spike when disabled; it's a good idea to &quot;remove&quot; the channel using NR51 before refreshing wave RAM.

==APU technical explanation==
===Game Boy, Game Boy Color===
Each of the 4 channels work pretty identically. First, there's a &quot;generation&quot; circuit, which usually outputs either a 0 or another value (CH3 differs in that it can output multiple values, but regardless). That value is digital, and can range between 0 and 0xF. This is then fed to a [https://en.wikipedia.org/wiki/Digital-to-analog_converter DAC], which maps this to an analog value; 7 maps to the lowest (negative) voltage, 0 to the highest (positive) one. Finally, all channels are mixed through NR51, scaled through NR50, and sent to the output.

Each DAC is controlled independently from the generation circuit. For CH3, the DAC is controlled by NR30 bit 7; for other channels, the DAC is turned on unless bits 3-7 of NRx2 are reset, and the envelope will be set to &lt;code&gt;[NRx2] &gt;&gt; 4&lt;/code&gt;. (Note: the envelope sweep function changes the envelope, but not the value in NRx2! It won't disable the DAC, either.) The generation circuits are turned on by restarting them for the first time, and this is what sets the corresponding bit in NR52. Yes, it's possible to turn on a DAC but not the generation circuit. Finally, disabling a DAC also kills the generation circuit.

Note that each DAC has a DC offset, so enabling, disabling, adding to or removing from NR51, will all cause an audio pop; changing the volume in NR50 will as well.

Finally, all the output goes through a high-pass filter to remove the DC offsets from the DACs.

===Game Boy Advance===
The APU was reworked pretty heavily for the GBA. Instead of mixing being done analogically, it's instead done digitally; then, sound is converted to an analog signal and an offset is added (see SOUNDBIAS in [http://problemkaputt.de/gbatek.htm#gbasoundcontrolregisters GBATEK] for more details.

This means that the APU has no DACs, or if modelling the GBA as a GB, they're always on.

== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>exofmlcs2p9ntt7wvv9e5th9xu7df2w</sha1>
    </revision>
    <revision>
      <id>905</id>
      <parentid>884</parentid>
      <timestamp>2019-08-26T23:40:31Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* FF30-FF3F - Wave Pattern RAM */ Add notice about byte</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13447">{{Pandocs|soundcontroller}}

== Sound Overview ==

There are two sound channels connected to the output terminals SO1 and SO2. There is also a input terminal Vin connected to the cartridge. It can be routed to either of both output terminals. GameBoy circuitry allows producing sound in four different ways:

   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.


These four sounds can be controlled independantly and then mixed separately for each of the output terminals.

Sound registers may be set at all times while producing sound.

(Sounds will have a 2.4% higher frequency on Super GB.)


== Sound Channel 1 - Tone &amp; Sweep ==

===FF10 - NR10 - Channel 1 Sweep register (R/W)===

  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)

Sweep Time:

  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)


The change of frequency (NR13,NR14) at each shift is calculated by the following formula where X(0) is initial freq &amp; X(t-1) is last freq:

  X(t) = X(t-1) +/- X(t-1)/2^n


===FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR14 is set.

===FF12 - NR12 - Channel 1 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF13 - NR13 - Channel 1 Frequency lo (Write Only)===

Lower 8 bits of 11 bit frequency (x).
Next 3 bit are in NR14 ($FF14)

===FF14 - NR14 - Channel 1 Frequency hi (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 2 - Tone ==

This sound channel works exactly as channel 1, except that it doesn't have a Tone Envelope/Sweep Register.

===FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)===

  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)

Wave Duty:

  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR24 is set.

===FF17 - NR22 - Channel 2 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF18 - NR23 - Channel 2 Frequency lo data (W)===
Frequency's lower 8 bits of 11 bit data (x).
Next 3 bits are in NR24 ($FF19).

===FF19 - NR24 - Channel 2 Frequency hi data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 131072/(2048-x) Hz


== Sound Channel 3 - Wave Output ==

This channel can be used to output digital sound, the length of the sample buffer (Wave RAM) is limited to 32 digits. This sound channel can be also used to output normal tones when initializing the Wave RAM by a square wave. This channel doesn't have a volume envelope register.

===FF1A - NR30 - Channel 3 Sound on/off (R/W)===

  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)


===FF1B - NR31 - Channel 3 Sound Length===

  Bit 7-0 - Sound length (t1: 0 - 255)

Sound Length = (256-t1)*(1/256) seconds
This value is used only if Bit 6 in NR34 is set.

===FF1C - NR32 - Channel 3 Select output level (R/W)===

  Bit 6-5 - Select output level (Read/Write)

Possible Output levels are:

  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)


===FF1D - NR33 - Channel 3 Frequency's lower data (W)===
Lower 8 bits of an 11 bit frequency (x).

===FF1E - NR34 - Channel 3 Frequency's higher data (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)

Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz

===FF30-FF3F - Wave Pattern RAM===
  Contents - Waveform storage for arbitrary sound data

This storage area holds 32 4-bit samples that are played back, upper 4 bits first.


Wave RAM should only be accessed while CH3 is disabled (NR30 bit 7 reset), otherwise accesses will behave weirdly.

On almost all models, the byte will be written at the offset CH3 is currently reading. On GBA, the write will simply be ignored.

== Sound Channel 4 - Noise ==

This channel is used to output white noise. This is done by randomly switching the amplitude between high and low at a given frequency. Depending on the frequency the noise will appear 'harder' or 'softer'.

It is also possible to influence the function of the random generator, so the that the output becomes more regular, resulting in a limited ability to output Tone instead of Noise.

===FF20 - NR41 - Channel 4 Sound Length (R/W)===

  Bit 5-0 - Sound length data (t1: 0-63)

Sound Length = (64-t1)*(1/256) seconds
The Length value is used only if Bit 6 in NR44 is set.

===FF21 - NR42 - Channel 4 Volume Envelope (R/W)===

  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)

Length of 1 step = n*(1/64) seconds

===FF22 - NR43 - Channel 4 Polynomial Counter (R/W)===
The amplitude is randomly switched between high and low at the given frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some frequencies will sound more like Tone than Noise.

  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)

Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead

===FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)===

  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)



== Sound Control Registers ==

===FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)===
The volume bits specify the &quot;Master Volume&quot; for Left/Right sound output. SO2 goes to the left headphone, and SO1 goes to the right.

  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)

The Vin signal is an analog signal received from the game cartridge bus, allowing external hardware in the cartridge to supply a fifth sound channel, additionally to the Game Boy's internal four channels. No licensed games used this feature, and it was omitted from the Game Boy Advance.

(Despite rumors, ''Pocket Music'' does not use Vin. It blocks use on the GBA for a different reason: the developer couldn't figure out how to silence buzzing associated with the wave channel's DAC.)

===FF25 - NR51 - Selection of Sound output terminal (R/W)===
Each channel can be panned hard left, center, or hard right.

  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal


===FF26 - NR52 - Sound on/off===
If your GB programs don't use sound then write 00h to this register to save 16% or more on GB power consumption. Disabeling the sound controller by clearing Bit 7 destroys the contents of all sound registers. Also, it is not possible to access any sound registers (execpt FF26) while the sound controller is disabled.

  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)

Bits 0-3 of this register are read only status bits, writing to these bits does NOT enable/disable sound. The flags get set when sound output is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag remains set until the sound length has expired (if enabled). A volume envelopes which has decreased to zero volume will NOT cause the sound flag to go off.

==Pitfalls==
* Enabling or disabling a DAC (resetting NR30 bit 7 or writing %0000 0XXX to NRx2 for other channels), adding or removing it using NR51, or changing the volume in NR50, will cause an audio pop. (This causes a change in DC offset, which is smoothed out by a high-pass circuit over time, but still creates a pop)

* The final output goes through a high-pass filter, which is more aggressive on GBA than on GBC, which is more aggressive than on DMG. (What this means is that the output is &quot;pulled&quot; towards 0V with various degrees of &quot;aggressiveness&quot;)

* When first starting up a pulse channel, it will ''always'' output a (digital) zero.

* The pulse channels' &quot;duty step&quot; (at which position in the duty cycle they are) can't be reset. The exception to this is turning off the APU, which causes them to start over from 0 when turning it on.

* Restarting a pulse channel causes its &quot;duty step timer&quot; to reset, meaning that &quot;tickling&quot; a pulse channel regularly enough will cause its &quot;duty step&quot; to never advance.

* When restarting CH3, it resumes playing the last 4-bit sample it read from wave RAM, or 0 if no sample has been read since APU reset. (Sample latching is independent of output level control in NR32.) After the latched sample completes, it starts with the second sample in wave RAM (low 4 bits of $FF30). The first sample (high 4 bits of $FF30) is played last.

* CH3 output level control does not, in fact, alter the output level. It shifts the '''digital''' value CH3 is outputting (read below), not the analog value.

* On GBA, CH3 is inverted. This causes the channel to output a loud spike when disabled; it's a good idea to &quot;remove&quot; the channel using NR51 before refreshing wave RAM.

==APU technical explanation==
===Game Boy, Game Boy Color===
Each of the 4 channels work pretty identically. First, there's a &quot;generation&quot; circuit, which usually outputs either a 0 or another value (CH3 differs in that it can output multiple values, but regardless). That value is digital, and can range between 0 and 0xF. This is then fed to a [https://en.wikipedia.org/wiki/Digital-to-analog_converter DAC], which maps this to an analog value; 7 maps to the lowest (negative) voltage, 0 to the highest (positive) one. Finally, all channels are mixed through NR51, scaled through NR50, and sent to the output.

Each DAC is controlled independently from the generation circuit. For CH3, the DAC is controlled by NR30 bit 7; for other channels, the DAC is turned on unless bits 3-7 of NRx2 are reset, and the envelope will be set to &lt;code&gt;[NRx2] &gt;&gt; 4&lt;/code&gt;. (Note: the envelope sweep function changes the envelope, but not the value in NRx2! It won't disable the DAC, either.) The generation circuits are turned on by restarting them for the first time, and this is what sets the corresponding bit in NR52. Yes, it's possible to turn on a DAC but not the generation circuit. Finally, disabling a DAC also kills the generation circuit.

Note that each DAC has a DC offset, so enabling, disabling, adding to or removing from NR51, will all cause an audio pop; changing the volume in NR50 will as well.

Finally, all the output goes through a high-pass filter to remove the DC offsets from the DACs.

===Game Boy Advance===
The APU was reworked pretty heavily for the GBA. Instead of mixing being done analogically, it's instead done digitally; then, sound is converted to an analog signal and an offset is added (see SOUNDBIAS in [http://problemkaputt.de/gbatek.htm#gbasoundcontrolregisters GBATEK] for more details.

This means that the APU has no DACs, or if modelling the GBA as a GB, they're always on.

== Read more ==
[[Wavetable Archive]]

[[Gameboy sound hardware]]

[[Sound tutorial]]</text>
      <sha1>p6tvc9j93b9k0ya52ihgrabvbthzkwr</sha1>
    </revision>
  </page>
  <page>
    <title>Joypad Input</title>
    <ns>0</ns>
    <id>45</id>
    <revision>
      <id>147</id>
      <timestamp>2009-06-28T10:34:13Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: ===FF00 - P1/JOYP - Joypad (R/W)=== The eight gameboy buttons/direction keys are arranged in form of a 2x4 matrix. Select either button or direction keys by writing to this register, then ...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2052">===FF00 - P1/JOYP - Joypad (R/W)===
The eight gameboy buttons/direction keys are arranged in form of a 2x4 matrix. Select either button or direction keys by writing to this register, then read-out bit 0-3.

  Bit 7 - Not used
  Bit 6 - Not used
  Bit 5 - P15 Select Button Keys      (0=Select)
  Bit 4 - P14 Select Direction Keys   (0=Select)
  Bit 3 - P13 Input Down  or Start    (0=Pressed) (Read Only)
  Bit 2 - P12 Input Up    or Select   (0=Pressed) (Read Only)
  Bit 1 - P11 Input Left  or Button B (0=Pressed) (Read Only)
  Bit 0 - P10 Input Right or Button A (0=Pressed) (Read Only)

Note: Most programs are repeatedly reading from this port several times (the first reads used as short delay, allowing the inputs to stabilize, and only the value from the last read actually used).

===Usage in SGB software===
Beside for normal joypad input, SGB games mis-use the joypad register to output SGB command packets to the SNES, also, SGB programs may read out gamepad states from up to four different joypads which can be connected to the SNES.
See SGB description for details.

===INT 60 - Joypad Interrupt===
Joypad interrupt is requested when any of the above Input lines changes from High to Low. Generally this should happen when a key becomes pressed (provided that the button/direction key is enabled by above Bit4/5), however, because of switch bounce, one or more High to Low transitions are usually produced both when pressing or releasing a key.

===Using the Joypad Interrupt===
It's more or less useless for programmers, even when selecting both buttons and direction keys simultaneously it still cannot recognize all keystrokes, because in that case a bit might be already held low by a button key, and pressing the corresponding direction key would thus cause no difference. The only meaningful purpose of the keystroke interrupt would be to terminate STOP (low power) standby state.
Also, the joypad interrupt does not appear to work with CGB and GBA hardware (the STOP function can be still terminated by joypad keystrokes though).</text>
      <sha1>g5g23thcfb4ydx013zsc7z4gsucyxk4</sha1>
    </revision>
    <revision>
      <id>167</id>
      <parentid>147</parentid>
      <timestamp>2009-06-28T12:44:45Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2076">{{Pandocs|joypadinput}}
===FF00 - P1/JOYP - Joypad (R/W)===
The eight gameboy buttons/direction keys are arranged in form of a 2x4 matrix. Select either button or direction keys by writing to this register, then read-out bit 0-3.

  Bit 7 - Not used
  Bit 6 - Not used
  Bit 5 - P15 Select Button Keys      (0=Select)
  Bit 4 - P14 Select Direction Keys   (0=Select)
  Bit 3 - P13 Input Down  or Start    (0=Pressed) (Read Only)
  Bit 2 - P12 Input Up    or Select   (0=Pressed) (Read Only)
  Bit 1 - P11 Input Left  or Button B (0=Pressed) (Read Only)
  Bit 0 - P10 Input Right or Button A (0=Pressed) (Read Only)

Note: Most programs are repeatedly reading from this port several times (the first reads used as short delay, allowing the inputs to stabilize, and only the value from the last read actually used).

===Usage in SGB software===
Beside for normal joypad input, SGB games mis-use the joypad register to output SGB command packets to the SNES, also, SGB programs may read out gamepad states from up to four different joypads which can be connected to the SNES.
See SGB description for details.

===INT 60 - Joypad Interrupt===
Joypad interrupt is requested when any of the above Input lines changes from High to Low. Generally this should happen when a key becomes pressed (provided that the button/direction key is enabled by above Bit4/5), however, because of switch bounce, one or more High to Low transitions are usually produced both when pressing or releasing a key.

===Using the Joypad Interrupt===
It's more or less useless for programmers, even when selecting both buttons and direction keys simultaneously it still cannot recognize all keystrokes, because in that case a bit might be already held low by a button key, and pressing the corresponding direction key would thus cause no difference. The only meaningful purpose of the keystroke interrupt would be to terminate STOP (low power) standby state.
Also, the joypad interrupt does not appear to work with CGB and GBA hardware (the STOP function can be still terminated by joypad keystrokes though).</text>
      <sha1>l1lopg84vdtffoeee2ajczrmucladeb</sha1>
    </revision>
    <revision>
      <id>570</id>
      <parentid>167</parentid>
      <timestamp>2014-11-23T13:29:38Z</timestamp>
      <contributor>
        <username>AntonioND</username>
        <id>47</id>
      </contributor>
      <comment>/* Using the Joypad Interrupt */ Joy int happens in all models, tested on hardware.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2016">{{Pandocs|joypadinput}}
===FF00 - P1/JOYP - Joypad (R/W)===
The eight gameboy buttons/direction keys are arranged in form of a 2x4 matrix. Select either button or direction keys by writing to this register, then read-out bit 0-3.

  Bit 7 - Not used
  Bit 6 - Not used
  Bit 5 - P15 Select Button Keys      (0=Select)
  Bit 4 - P14 Select Direction Keys   (0=Select)
  Bit 3 - P13 Input Down  or Start    (0=Pressed) (Read Only)
  Bit 2 - P12 Input Up    or Select   (0=Pressed) (Read Only)
  Bit 1 - P11 Input Left  or Button B (0=Pressed) (Read Only)
  Bit 0 - P10 Input Right or Button A (0=Pressed) (Read Only)

Note: Most programs are repeatedly reading from this port several times (the first reads used as short delay, allowing the inputs to stabilize, and only the value from the last read actually used).

===Usage in SGB software===
Beside for normal joypad input, SGB games mis-use the joypad register to output SGB command packets to the SNES, also, SGB programs may read out gamepad states from up to four different joypads which can be connected to the SNES.
See SGB description for details.

===INT 60 - Joypad Interrupt===
Joypad interrupt is requested when any of the above Input lines changes from High to Low. Generally this should happen when a key becomes pressed (provided that the button/direction key is enabled by above Bit4/5), however, because of switch bounce, one or more High to Low transitions are usually produced both when pressing or releasing a key.

===Using the Joypad Interrupt===
It's more or less useless for programmers, even when selecting both buttons and direction keys simultaneously it still cannot recognize all keystrokes, because in that case a bit might be already held low by a button key, and pressing the corresponding direction key would thus cause no difference. The only meaningful purpose of the keystroke interrupt would be to terminate STOP (low power) standby state. GBA SP, because of the different buttons used, seems to not be affected by switch bounce.</text>
      <sha1>lptnj92oqruz8jj29byic3gyu8h1d0f</sha1>
    </revision>
  </page>
  <page>
    <title>Serial Data Transfer (Link Cable)</title>
    <ns>0</ns>
    <id>46</id>
    <revision>
      <id>149</id>
      <timestamp>2009-06-28T10:37:30Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: ===F01 - SB - Serial transfer data (R/W)=== 8 Bits of data to be read/written  ===FF02 - SC - Serial Transfer Control (R/W)===    Bit 7 - Transfer Start Flag (0=No Transfer, 1=Start)   Bit...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4196">===F01 - SB - Serial transfer data (R/W)===
8 Bits of data to be read/written

===FF02 - SC - Serial Transfer Control (R/W)===

  Bit 7 - Transfer Start Flag (0=No Transfer, 1=Start)
  Bit 1 - Clock Speed (0=Normal, 1=Fast) ** CGB Mode Only **
  Bit 0 - Shift Clock (0=External Clock, 1=Internal Clock)

The clock signal specifies the rate at which the eight data bits in SB (FF01) are transferred. When the gameboy is communicating with another gameboy (or other computer) then either one must supply internal clock, and the other one must use external clock.

===Internal Clock===
In Non-CGB Mode the gameboy supplies an internal clock of 8192Hz only (allowing to transfer about 1 KByte per second). In CGB Mode four internal clock rates are available, depending on Bit 1 of the SC register, and on whether the CGB Double Speed Mode is used:

    8192Hz -  1KB/s - Bit 1 cleared, Normal
   16384Hz -  2KB/s - Bit 1 cleared, Double Speed Mode
  262144Hz - 32KB/s - Bit 1 set,     Normal
  524288Hz - 64KB/s - Bit 1 set,     Double Speed Mode


===External Clock===
The external clock is typically supplied by another gameboy, but might be supplied by another computer (for example if connected to a PCs parallel port), in that case the external clock may have any speed. Even the old/monochrome gameboy is reported to recognizes external clocks of up to 500KHz. And there is no limitiation into the other direction - even when suppling an external clock speed of &quot;1 bit per month&quot;, then the gameboy will still eagerly wait for the next bit(s) to be transferred. It isn't required that the clock pulses are sent at an regular interval either.

===Timeouts===
When using external clock then the transfer will not complete until the last bit is received. In case that the second gameboy isn't supplying a clock signal, if it gets turned off, or if there is no second gameboy connected at all) then transfer will never complete. For this reason the transfer procedure should use a timeout counter, and abort the communication if no response has been received during the timeout interval.

===Delays and Synchronization===
The gameboy that is using internal clock should always execute a small delay between each transfer, in order to ensure that the opponent gameboy has enough time to prepare itself for the next transfer, ie. the gameboy with external clock must have set its transfer start bit before the gameboy with internal clock starts the transfer. Alternately, the two gameboys could switch between internal and external clock for each transferred byte to ensure synchronization.

Transfer is initiated by setting the Transfer Start Flag. This bit is automatically set to 0 at the end of Transfer. Reading this bit can be used to determine if the transfer is still active.

===INT 58 - Serial Interrupt===
When the transfer has completed (ie. after sending/receiving 8 bits, if any) then an interrupt is requested by setting Bit 3 of the IF Register (FF0F). When that interrupt is enabled, then the Serial Interrupt vector at 0058 is called.

'''XXXXXX...'''

Transmitting and receiving serial data is done simultaneously. The received data is automatically stored in SB.

The serial I/O port on the Gameboy is a very simple setup and is crude compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports. There are no start or stop bits.

During a transfer, a byte is shifted in at the same time that a byte is shifted out. The rate of the shift is determined by whether the clock source is internal or external.
The most significant bit is shifted in and out first.

When the internal clock is selected, it drives the clock pin on the game link port and it stays high when not used. During a transfer it will go low eight times to clock in/out each bit.

The state of the last bit shifted out determines the state of the output line until another transfer takes place.

If a serial transfer with internal clock is performed and no external GameBoy is present, a value of $FF will be received in the transfer.

The following code causes $75 to be shifted out the serial port and a byte to be shifted into $FF01:

    ld   a,$75
    ld  ($FF01),a
    ld   a,$81
    ld  ($FF02),a</text>
      <sha1>9ewn5qjumyr83kmst0017ph4osze88x</sha1>
    </revision>
    <revision>
      <id>170</id>
      <parentid>149</parentid>
      <timestamp>2009-06-28T12:50:14Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4236">{{Pandocs|serialdatatransferlinkcable}}
===F01 - SB - Serial transfer data (R/W)===
8 Bits of data to be read/written

===FF02 - SC - Serial Transfer Control (R/W)===

  Bit 7 - Transfer Start Flag (0=No Transfer, 1=Start)
  Bit 1 - Clock Speed (0=Normal, 1=Fast) ** CGB Mode Only **
  Bit 0 - Shift Clock (0=External Clock, 1=Internal Clock)

The clock signal specifies the rate at which the eight data bits in SB (FF01) are transferred. When the gameboy is communicating with another gameboy (or other computer) then either one must supply internal clock, and the other one must use external clock.

===Internal Clock===
In Non-CGB Mode the gameboy supplies an internal clock of 8192Hz only (allowing to transfer about 1 KByte per second). In CGB Mode four internal clock rates are available, depending on Bit 1 of the SC register, and on whether the CGB Double Speed Mode is used:

    8192Hz -  1KB/s - Bit 1 cleared, Normal
   16384Hz -  2KB/s - Bit 1 cleared, Double Speed Mode
  262144Hz - 32KB/s - Bit 1 set,     Normal
  524288Hz - 64KB/s - Bit 1 set,     Double Speed Mode


===External Clock===
The external clock is typically supplied by another gameboy, but might be supplied by another computer (for example if connected to a PCs parallel port), in that case the external clock may have any speed. Even the old/monochrome gameboy is reported to recognizes external clocks of up to 500KHz. And there is no limitiation into the other direction - even when suppling an external clock speed of &quot;1 bit per month&quot;, then the gameboy will still eagerly wait for the next bit(s) to be transferred. It isn't required that the clock pulses are sent at an regular interval either.

===Timeouts===
When using external clock then the transfer will not complete until the last bit is received. In case that the second gameboy isn't supplying a clock signal, if it gets turned off, or if there is no second gameboy connected at all) then transfer will never complete. For this reason the transfer procedure should use a timeout counter, and abort the communication if no response has been received during the timeout interval.

===Delays and Synchronization===
The gameboy that is using internal clock should always execute a small delay between each transfer, in order to ensure that the opponent gameboy has enough time to prepare itself for the next transfer, ie. the gameboy with external clock must have set its transfer start bit before the gameboy with internal clock starts the transfer. Alternately, the two gameboys could switch between internal and external clock for each transferred byte to ensure synchronization.

Transfer is initiated by setting the Transfer Start Flag. This bit is automatically set to 0 at the end of Transfer. Reading this bit can be used to determine if the transfer is still active.

===INT 58 - Serial Interrupt===
When the transfer has completed (ie. after sending/receiving 8 bits, if any) then an interrupt is requested by setting Bit 3 of the IF Register (FF0F). When that interrupt is enabled, then the Serial Interrupt vector at 0058 is called.

'''XXXXXX...'''

Transmitting and receiving serial data is done simultaneously. The received data is automatically stored in SB.

The serial I/O port on the Gameboy is a very simple setup and is crude compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports. There are no start or stop bits.

During a transfer, a byte is shifted in at the same time that a byte is shifted out. The rate of the shift is determined by whether the clock source is internal or external.
The most significant bit is shifted in and out first.

When the internal clock is selected, it drives the clock pin on the game link port and it stays high when not used. During a transfer it will go low eight times to clock in/out each bit.

The state of the last bit shifted out determines the state of the output line until another transfer takes place.

If a serial transfer with internal clock is performed and no external GameBoy is present, a value of $FF will be received in the transfer.

The following code causes $75 to be shifted out the serial port and a byte to be shifted into $FF01:

    ld   a,$75
    ld  ($FF01),a
    ld   a,$81
    ld  ($FF02),a</text>
      <sha1>hmr96pww6yjb1lz6zza5wbfkx8eaiv4</sha1>
    </revision>
    <revision>
      <id>523</id>
      <parentid>170</parentid>
      <timestamp>2012-12-09T23:03:34Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4237">{{Pandocs|serialdatatransferlinkcable}}
===FF01 - SB - Serial transfer data (R/W)===
8 Bits of data to be read/written

===FF02 - SC - Serial Transfer Control (R/W)===

  Bit 7 - Transfer Start Flag (0=No Transfer, 1=Start)
  Bit 1 - Clock Speed (0=Normal, 1=Fast) ** CGB Mode Only **
  Bit 0 - Shift Clock (0=External Clock, 1=Internal Clock)

The clock signal specifies the rate at which the eight data bits in SB (FF01) are transferred. When the gameboy is communicating with another gameboy (or other computer) then either one must supply internal clock, and the other one must use external clock.

===Internal Clock===
In Non-CGB Mode the gameboy supplies an internal clock of 8192Hz only (allowing to transfer about 1 KByte per second). In CGB Mode four internal clock rates are available, depending on Bit 1 of the SC register, and on whether the CGB Double Speed Mode is used:

    8192Hz -  1KB/s - Bit 1 cleared, Normal
   16384Hz -  2KB/s - Bit 1 cleared, Double Speed Mode
  262144Hz - 32KB/s - Bit 1 set,     Normal
  524288Hz - 64KB/s - Bit 1 set,     Double Speed Mode


===External Clock===
The external clock is typically supplied by another gameboy, but might be supplied by another computer (for example if connected to a PCs parallel port), in that case the external clock may have any speed. Even the old/monochrome gameboy is reported to recognizes external clocks of up to 500KHz. And there is no limitiation into the other direction - even when suppling an external clock speed of &quot;1 bit per month&quot;, then the gameboy will still eagerly wait for the next bit(s) to be transferred. It isn't required that the clock pulses are sent at an regular interval either.

===Timeouts===
When using external clock then the transfer will not complete until the last bit is received. In case that the second gameboy isn't supplying a clock signal, if it gets turned off, or if there is no second gameboy connected at all) then transfer will never complete. For this reason the transfer procedure should use a timeout counter, and abort the communication if no response has been received during the timeout interval.

===Delays and Synchronization===
The gameboy that is using internal clock should always execute a small delay between each transfer, in order to ensure that the opponent gameboy has enough time to prepare itself for the next transfer, ie. the gameboy with external clock must have set its transfer start bit before the gameboy with internal clock starts the transfer. Alternately, the two gameboys could switch between internal and external clock for each transferred byte to ensure synchronization.

Transfer is initiated by setting the Transfer Start Flag. This bit is automatically set to 0 at the end of Transfer. Reading this bit can be used to determine if the transfer is still active.

===INT 58 - Serial Interrupt===
When the transfer has completed (ie. after sending/receiving 8 bits, if any) then an interrupt is requested by setting Bit 3 of the IF Register (FF0F). When that interrupt is enabled, then the Serial Interrupt vector at 0058 is called.

'''XXXXXX...'''

Transmitting and receiving serial data is done simultaneously. The received data is automatically stored in SB.

The serial I/O port on the Gameboy is a very simple setup and is crude compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports. There are no start or stop bits.

During a transfer, a byte is shifted in at the same time that a byte is shifted out. The rate of the shift is determined by whether the clock source is internal or external.
The most significant bit is shifted in and out first.

When the internal clock is selected, it drives the clock pin on the game link port and it stays high when not used. During a transfer it will go low eight times to clock in/out each bit.

The state of the last bit shifted out determines the state of the output line until another transfer takes place.

If a serial transfer with internal clock is performed and no external GameBoy is present, a value of $FF will be received in the transfer.

The following code causes $75 to be shifted out the serial port and a byte to be shifted into $FF01:

    ld   a,$75
    ld  ($FF01),a
    ld   a,$81
    ld  ($FF02),a</text>
      <sha1>eya9yn2kjotgdkwmk6n7m4i7r539vp5</sha1>
    </revision>
    <revision>
      <id>735</id>
      <parentid>523</parentid>
      <timestamp>2017-04-09T22:57:36Z</timestamp>
      <contributor>
        <username>Raldi</username>
        <id>71</id>
      </contributor>
      <comment>Added notes from https://www.reddit.com/r/emulation/comments/64a7kl/cant_make_heads_or_tails_of_gameboy_video_link/</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5944">{{Pandocs|serialdatatransferlinkcable}}

Communication between two Gameboys happens one byte at a time. One Gameboy acts as the master, uses its internal clock, and thus controls when the exchange happens. The other one uses an external clock (i.e., the one inside the other Gameboy) and has no control over when the transfer happens. If it hasn't gotten around to loading up the  next data byte at the time the transfer begins, the last one will go out again. Alternately, if it's ready to send the next byte but the last one hasn't gone out yet, it has no choice but to wait.

===FF01 - SB - Serial transfer data (R/W)===

Before a transfer, it holds the next byte that will go out.

During a transfer, it has a blend of the outgoing and incoming bytes. Each cycle, the leftmost bit is shifted out (and over the wire) and the incoming bit is shifted in from the other side:

&lt;code&gt;&lt;br/&gt;
o7 o6 o5 o4 o3 o2 o1 o0&lt;br/&gt;
o6 o5 o4 o3 o2 o1 o0 i7&lt;br/&gt;
o5 o4 o3 o2 o1 o0 i7 i6&lt;br/&gt;
o4 o3 o2 o1 o0 i7 i6 i5&lt;br/&gt;
o3 o2 o1 o0 i7 i6 i5 i4&lt;br/&gt;
o2 o1 o0 i7 i6 i5 i4 i3&lt;br/&gt;
o1 o0 i7 i6 i5 i4 i3 i2&lt;br/&gt;
o0 i7 i6 i5 i4 i3 i2 i1&lt;br/&gt;
i7 i6 i5 i4 i3 i2 i1 i0&lt;br/&gt;
&lt;/code&gt;


===FF02 - SC - Serial Transfer Control (R/W)===

  Bit 7 - Transfer Start Flag (0=No transfer is in progress or requested, 1=Transfer in progress, or requested)
  Bit 1 - Clock Speed (0=Normal, 1=Fast) ** CGB Mode Only **
  Bit 0 - Shift Clock (0=External Clock, 1=Internal Clock)

The gameboy acting as master will load up a data byte in SB and then set SC to 0x81 (Transfer requested, use internal clock). It will be notified that the transfer is complete in two ways: SC's Bit 7 will be cleared (i.e., SC will be set up 0x01), and also the Serial Interrupt handler will be called (i.e., the CPU will jump to 0x0058).

The other gameboy will load up a data byte and can optionally set SC's Bit 7 (i.e., SC=0x80). Regardless of whether or not it has done this, if and when the master gameboy wants to conduct a transfer, it will happen (pulling whatever happens to be in SB at that time). The passive gameboy will have its serial interrupt handler called at the end of the transfer, and if it bothered to set SC's Bit 7, it will be cleared.

===Internal Clock===
In Non-CGB Mode the gameboy supplies an internal clock of 8192Hz only (allowing to transfer about 1 KByte per second). In CGB Mode four internal clock rates are available, depending on Bit 1 of the SC register, and on whether the CGB Double Speed Mode is used:

    8192Hz -  1KB/s - Bit 1 cleared, Normal
   16384Hz -  2KB/s - Bit 1 cleared, Double Speed Mode
  262144Hz - 32KB/s - Bit 1 set,     Normal
  524288Hz - 64KB/s - Bit 1 set,     Double Speed Mode


===External Clock===
The external clock is typically supplied by another gameboy, but might be supplied by another computer (for example if connected to a PCs parallel port), in that case the external clock may have any speed. Even the old/monochrome gameboy is reported to recognizes external clocks of up to 500KHz. And there is no limitation into the other direction - even when suppling an external clock speed of &quot;1 bit per month&quot;, then the gameboy will still eagerly wait for the next bit(s) to be transferred. It isn't required that the clock pulses are sent at an regular interval either.

===Timeouts===
When using external clock then the transfer will not complete until the last bit is received. In case that the second gameboy isn't supplying a clock signal, if it gets turned off, or if there is no second gameboy connected at all) then transfer will never complete. For this reason the transfer procedure should use a timeout counter, and abort the communication if no response has been received during the timeout interval.

===Delays and Synchronization===
The gameboy that is using internal clock should always execute a small delay between each transfer, in order to ensure that the opponent gameboy has enough time to prepare itself for the next transfer, ie. the gameboy with external clock must have set its transfer start bit before the gameboy with internal clock starts the transfer. Alternately, the two gameboys could switch between internal and external clock for each transferred byte to ensure synchronization.

Transfer is initiated by setting the master Gameboy setting its Transfer Start Flag, regardless of the value of this flag on the other device. This bit is automatically set to 0 (on both) at the end of Transfer. Reading this bit can be used to determine if the transfer is still active.

===INT 58 - Serial Interrupt===
When the transfer has completed (ie. after sending/receiving 8 bits, if any) then an interrupt is requested by setting Bit 3 of the IF Register (FF0F). When that interrupt is enabled, then the Serial Interrupt vector at 0058 is called.

'''XXXXXX...'''

Transmitting and receiving serial data is done simultaneously. The received data is automatically stored in SB.

The serial I/O port on the Gameboy is a very simple setup and is crude compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports. There are no start or stop bits.

During a transfer, a byte is shifted in at the same time that a byte is shifted out. The rate of the shift is determined by whether the clock source is internal or external.
The most significant bit is shifted in and out first.

When the internal clock is selected, it drives the clock pin on the game link port and it stays high when not used. During a transfer it will go low eight times to clock in/out each bit.

The state of the last bit shifted out determines the state of the output line until another transfer takes place.

If a serial transfer with internal clock is performed and no external GameBoy is present, a value of $FF will be received in the transfer.

The following code initiates the process of shifting $75 out the serial port and a byte to be shifted into $FF01:

    ld   a,$75
    ld  ($FF01),a
    ld   a,$81
    ld  ($FF02),a</text>
      <sha1>h0c9dm1se43je03kutce7zucxx2gafc</sha1>
    </revision>
    <revision>
      <id>885</id>
      <parentid>735</parentid>
      <timestamp>2019-06-02T20:40:42Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* INT 58 - Serial Interrupt */ No wake-on-LAN, per gekkio</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6065">{{Pandocs|serialdatatransferlinkcable}}

Communication between two Gameboys happens one byte at a time. One Gameboy acts as the master, uses its internal clock, and thus controls when the exchange happens. The other one uses an external clock (i.e., the one inside the other Gameboy) and has no control over when the transfer happens. If it hasn't gotten around to loading up the  next data byte at the time the transfer begins, the last one will go out again. Alternately, if it's ready to send the next byte but the last one hasn't gone out yet, it has no choice but to wait.

===FF01 - SB - Serial transfer data (R/W)===

Before a transfer, it holds the next byte that will go out.

During a transfer, it has a blend of the outgoing and incoming bytes. Each cycle, the leftmost bit is shifted out (and over the wire) and the incoming bit is shifted in from the other side:

&lt;code&gt;&lt;br/&gt;
o7 o6 o5 o4 o3 o2 o1 o0&lt;br/&gt;
o6 o5 o4 o3 o2 o1 o0 i7&lt;br/&gt;
o5 o4 o3 o2 o1 o0 i7 i6&lt;br/&gt;
o4 o3 o2 o1 o0 i7 i6 i5&lt;br/&gt;
o3 o2 o1 o0 i7 i6 i5 i4&lt;br/&gt;
o2 o1 o0 i7 i6 i5 i4 i3&lt;br/&gt;
o1 o0 i7 i6 i5 i4 i3 i2&lt;br/&gt;
o0 i7 i6 i5 i4 i3 i2 i1&lt;br/&gt;
i7 i6 i5 i4 i3 i2 i1 i0&lt;br/&gt;
&lt;/code&gt;


===FF02 - SC - Serial Transfer Control (R/W)===

  Bit 7 - Transfer Start Flag (0=No transfer is in progress or requested, 1=Transfer in progress, or requested)
  Bit 1 - Clock Speed (0=Normal, 1=Fast) ** CGB Mode Only **
  Bit 0 - Shift Clock (0=External Clock, 1=Internal Clock)

The gameboy acting as master will load up a data byte in SB and then set SC to 0x81 (Transfer requested, use internal clock). It will be notified that the transfer is complete in two ways: SC's Bit 7 will be cleared (i.e., SC will be set up 0x01), and also the Serial Interrupt handler will be called (i.e., the CPU will jump to 0x0058).

The other gameboy will load up a data byte and can optionally set SC's Bit 7 (i.e., SC=0x80). Regardless of whether or not it has done this, if and when the master gameboy wants to conduct a transfer, it will happen (pulling whatever happens to be in SB at that time). The passive gameboy will have its serial interrupt handler called at the end of the transfer, and if it bothered to set SC's Bit 7, it will be cleared.

===Internal Clock===
In Non-CGB Mode the gameboy supplies an internal clock of 8192Hz only (allowing to transfer about 1 KByte per second). In CGB Mode four internal clock rates are available, depending on Bit 1 of the SC register, and on whether the CGB Double Speed Mode is used:

    8192Hz -  1KB/s - Bit 1 cleared, Normal
   16384Hz -  2KB/s - Bit 1 cleared, Double Speed Mode
  262144Hz - 32KB/s - Bit 1 set,     Normal
  524288Hz - 64KB/s - Bit 1 set,     Double Speed Mode


===External Clock===
The external clock is typically supplied by another gameboy, but might be supplied by another computer (for example if connected to a PCs parallel port), in that case the external clock may have any speed. Even the old/monochrome gameboy is reported to recognizes external clocks of up to 500KHz. And there is no limitation into the other direction - even when suppling an external clock speed of &quot;1 bit per month&quot;, then the gameboy will still eagerly wait for the next bit(s) to be transferred. It isn't required that the clock pulses are sent at an regular interval either.

===Timeouts===
When using external clock then the transfer will not complete until the last bit is received. In case that the second gameboy isn't supplying a clock signal, if it gets turned off, or if there is no second gameboy connected at all) then transfer will never complete. For this reason the transfer procedure should use a timeout counter, and abort the communication if no response has been received during the timeout interval.

===Delays and Synchronization===
The gameboy that is using internal clock should always execute a small delay between each transfer, in order to ensure that the opponent gameboy has enough time to prepare itself for the next transfer, ie. the gameboy with external clock must have set its transfer start bit before the gameboy with internal clock starts the transfer. Alternately, the two gameboys could switch between internal and external clock for each transferred byte to ensure synchronization.

Transfer is initiated by setting the master Gameboy setting its Transfer Start Flag, regardless of the value of this flag on the other device. This bit is automatically set to 0 (on both) at the end of Transfer. Reading this bit can be used to determine if the transfer is still active.

===INT 58 - Serial Interrupt===
When the transfer has completed (ie. after sending/receiving 8 bits, if any) then an interrupt is requested by setting Bit 3 of the IF Register (FF0F). When that interrupt is enabled, then the Serial Interrupt vector at 0058 is called.

'''XXXXXX...'''

Transmitting and receiving serial data is done simultaneously. The received data is automatically stored in SB.

The serial I/O port on the Gameboy is a very simple setup and is crude compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports. There are no start or stop bits.

During a transfer, a byte is shifted in at the same time that a byte is shifted out. The rate of the shift is determined by whether the clock source is internal or external.
The most significant bit is shifted in and out first.

When the internal clock is selected, it drives the clock pin on the game link port and it stays high when not used. During a transfer it will go low eight times to clock in/out each bit.

The state of the last bit shifted out determines the state of the output line until another transfer takes place.

If a serial transfer with internal clock is performed and no external GameBoy is present, a value of $FF will be received in the transfer.

The following code initiates the process of shifting $75 out the serial port and a byte to be shifted into $FF01:

    ld   a,$75
    ld  ($FF01),a
    ld   a,$81
    ld  ($FF02),a

The Game Boy does not support wake-on-LAN. Completion of an externally clocked serial transfer does not exit STOP mode.</text>
      <sha1>bm1cijs1e6vulc7d2rs3n2hjtz9ve06</sha1>
    </revision>
  </page>
  <page>
    <title>Timer and Divider Registers</title>
    <ns>0</ns>
    <id>47</id>
    <revision>
      <id>150</id>
      <timestamp>2009-06-28T10:38:31Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: ===FF04 - DIV - Divider Register (R/W)=== This register is incremented at rate of 16384Hz (~16779Hz on SGB). In CGB Double Speed Mode it is incremented twice as fast, ie. at 32768Hz. Writi...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1445">===FF04 - DIV - Divider Register (R/W)===
This register is incremented at rate of 16384Hz (~16779Hz on SGB). In CGB Double Speed Mode it is incremented twice as fast, ie. at 32768Hz. Writing any value to this register resets it to 00h.

===FF05 - TIMA - Timer counter (R/W)===
This timer is incremented by a clock frequency specified by the TAC register ($FF07). When the value overflows (gets bigger than FFh) then it will be reset to the value specified in TMA (FF06), and an interrupt will be requested, as described below.

===FF06 - TMA - Timer Modulo (R/W)===
When the TIMA overflows, this data will be loaded.

===FF07 - TAC - Timer Control (R/W)===

  Bit 2    - Timer Stop  (0=Stop, 1=Start)
  Bits 1-0 - Input Clock Select
             00:   4096 Hz    (~4194 Hz SGB)
             01: 262144 Hz  (~268400 Hz SGB)
             10:  65536 Hz   (~67110 Hz SGB)
             11:  16384 Hz   (~16780 Hz SGB)


===INT 50 - Timer Interrupt===
Each time when the timer overflows (ie. when TIMA gets bigger than FFh), then an interrupt is requested by setting Bit 2 in the IF Register (FF0F). When that interrupt is enabled, then the CPU will execute it by calling the timer interrupt vector at 0050h.

'''Note'''
The above described Timer is the built-in timer in the gameboy. It has nothing to do with the MBC3s battery buffered Real Time Clock - that's a completely different thing, described in the chapter about Memory Banking Controllers.</text>
      <sha1>nuasvygnkpdjmp4wkt90zaps24mv486</sha1>
    </revision>
    <revision>
      <id>151</id>
      <parentid>150</parentid>
      <timestamp>2009-06-28T10:39:42Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>/* INT 50 - Timer Interrupt */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1445">===FF04 - DIV - Divider Register (R/W)===
This register is incremented at rate of 16384Hz (~16779Hz on SGB). In CGB Double Speed Mode it is incremented twice as fast, ie. at 32768Hz. Writing any value to this register resets it to 00h.

===FF05 - TIMA - Timer counter (R/W)===
This timer is incremented by a clock frequency specified by the TAC register ($FF07). When the value overflows (gets bigger than FFh) then it will be reset to the value specified in TMA (FF06), and an interrupt will be requested, as described below.

===FF06 - TMA - Timer Modulo (R/W)===
When the TIMA overflows, this data will be loaded.

===FF07 - TAC - Timer Control (R/W)===

  Bit 2    - Timer Stop  (0=Stop, 1=Start)
  Bits 1-0 - Input Clock Select
             00:   4096 Hz    (~4194 Hz SGB)
             01: 262144 Hz  (~268400 Hz SGB)
             10:  65536 Hz   (~67110 Hz SGB)
             11:  16384 Hz   (~16780 Hz SGB)


===INT 50 - Timer Interrupt===
Each time when the timer overflows (ie. when TIMA gets bigger than FFh), then an interrupt is requested by setting Bit 2 in the IF Register (FF0F). When that interrupt is enabled, then the CPU will execute it by calling the timer interrupt vector at 0050h.

== Note ==
The above described Timer is the built-in timer in the gameboy. It has nothing to do with the MBC3s battery buffered Real Time Clock - that's a completely different thing, described in the chapter about Memory Banking Controllers.</text>
      <sha1>3dxkr78ptgszm1uxo17z5xoumbftpaa</sha1>
    </revision>
    <revision>
      <id>171</id>
      <parentid>151</parentid>
      <timestamp>2009-06-28T12:50:54Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1482">{{Pandocs|timeranddividerregisters}}
===FF04 - DIV - Divider Register (R/W)===
This register is incremented at rate of 16384Hz (~16779Hz on SGB). In CGB Double Speed Mode it is incremented twice as fast, ie. at 32768Hz. Writing any value to this register resets it to 00h.

===FF05 - TIMA - Timer counter (R/W)===
This timer is incremented by a clock frequency specified by the TAC register ($FF07). When the value overflows (gets bigger than FFh) then it will be reset to the value specified in TMA (FF06), and an interrupt will be requested, as described below.

===FF06 - TMA - Timer Modulo (R/W)===
When the TIMA overflows, this data will be loaded.

===FF07 - TAC - Timer Control (R/W)===

  Bit 2    - Timer Stop  (0=Stop, 1=Start)
  Bits 1-0 - Input Clock Select
             00:   4096 Hz    (~4194 Hz SGB)
             01: 262144 Hz  (~268400 Hz SGB)
             10:  65536 Hz   (~67110 Hz SGB)
             11:  16384 Hz   (~16780 Hz SGB)


===INT 50 - Timer Interrupt===
Each time when the timer overflows (ie. when TIMA gets bigger than FFh), then an interrupt is requested by setting Bit 2 in the IF Register (FF0F). When that interrupt is enabled, then the CPU will execute it by calling the timer interrupt vector at 0050h.

== Note ==
The above described Timer is the built-in timer in the gameboy. It has nothing to do with the MBC3s battery buffered Real Time Clock - that's a completely different thing, described in the chapter about Memory Banking Controllers.</text>
      <sha1>4h07wcwdote79onrq74verqqvy72bmh</sha1>
    </revision>
    <revision>
      <id>444</id>
      <parentid>171</parentid>
      <timestamp>2012-05-25T11:54:14Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>/* FF07 - TAC - Timer Control (R/W) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1601">{{Pandocs|timeranddividerregisters}}
===FF04 - DIV - Divider Register (R/W)===
This register is incremented at rate of 16384Hz (~16779Hz on SGB). In CGB Double Speed Mode it is incremented twice as fast, ie. at 32768Hz. Writing any value to this register resets it to 00h.

===FF05 - TIMA - Timer counter (R/W)===
This timer is incremented by a clock frequency specified by the TAC register ($FF07). When the value overflows (gets bigger than FFh) then it will be reset to the value specified in TMA (FF06), and an interrupt will be requested, as described below.

===FF06 - TMA - Timer Modulo (R/W)===
When the TIMA overflows, this data will be loaded.

===FF07 - TAC - Timer Control (R/W)===

  Bit 2    - Timer Stop  (0=Stop, 1=Start)
  Bits 1-0 - Input Clock Select
             00:   4096 Hz    (~4194 Hz SGB)
             01: 262144 Hz  (~268400 Hz SGB)
             10:  65536 Hz   (~67110 Hz SGB)
             11:  16384 Hz   (~16780 Hz SGB)
  
  Note: The FF07.2 only affects the timer. The divider is *ALWAYS* counting, regardless of if the timer is or isn't.

===INT 50 - Timer Interrupt===
Each time when the timer overflows (ie. when TIMA gets bigger than FFh), then an interrupt is requested by setting Bit 2 in the IF Register (FF0F). When that interrupt is enabled, then the CPU will execute it by calling the timer interrupt vector at 0050h.

== Note ==
The above described Timer is the built-in timer in the gameboy. It has nothing to do with the MBC3s battery buffered Real Time Clock - that's a completely different thing, described in the chapter about Memory Banking Controllers.</text>
      <sha1>hjnkkzje6avv8cvql8kh14314vpr3ld</sha1>
    </revision>
    <revision>
      <id>445</id>
      <parentid>444</parentid>
      <timestamp>2012-05-25T12:02:18Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>/* FF07 - TAC - Timer Control (R/W) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1672">{{Pandocs|timeranddividerregisters}}
===FF04 - DIV - Divider Register (R/W)===
This register is incremented at rate of 16384Hz (~16779Hz on SGB). In CGB Double Speed Mode it is incremented twice as fast, ie. at 32768Hz. Writing any value to this register resets it to 00h.

===FF05 - TIMA - Timer counter (R/W)===
This timer is incremented by a clock frequency specified by the TAC register ($FF07). When the value overflows (gets bigger than FFh) then it will be reset to the value specified in TMA (FF06), and an interrupt will be requested, as described below.

===FF06 - TMA - Timer Modulo (R/W)===
When the TIMA overflows, this data will be loaded.

===FF07 - TAC - Timer Control (R/W)===

  Bit  2   - Timer Enable
  Bits 1-0 - Input Clock Select
             00: CPU Clock / 1024 (DMG, CGB:   4096 Hz, SGB:   ~4194 Hz)
             01: CPU Clock / 16   (DMG, CGB: 262144 Hz, SGB: ~268400 Hz)
             10: CPU Clock / 64   (DMG, CGB:  65536 Hz, SGB:  ~67110 Hz)
             11: CPU Clock / 256  (DMG, CGB:  16384 Hz, SGB:  ~16780 Hz)
  
  Note: The &quot;Timer Enable&quot; bit only affects the timer, the divider is '''ALWAYS''' counting.

===INT 50 - Timer Interrupt===
Each time when the timer overflows (ie. when TIMA gets bigger than FFh), then an interrupt is requested by setting Bit 2 in the IF Register (FF0F). When that interrupt is enabled, then the CPU will execute it by calling the timer interrupt vector at 0050h.

== Note ==
The above described Timer is the built-in timer in the gameboy. It has nothing to do with the MBC3s battery buffered Real Time Clock - that's a completely different thing, described in the chapter about Memory Banking Controllers.</text>
      <sha1>lim4of5lic1nzlm5bwbxw1r9vm6xu1m</sha1>
    </revision>
    <revision>
      <id>446</id>
      <parentid>445</parentid>
      <timestamp>2012-05-25T12:07:44Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>/* FF04 - DIV - Divider Register (R/W) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1702">{{Pandocs|timeranddividerregisters}}
===FF04 - DIV - Divider Register (R/W)===
This register is incremented at rate of 16384Hz (~16779Hz on SGB). Writing any value to this register resets it to 00h.

Note: The divider is affected by CGB double speed mode, and will increment at 32768Hz in double speed.

===FF05 - TIMA - Timer counter (R/W)===
This timer is incremented by a clock frequency specified by the TAC register ($FF07). When the value overflows (gets bigger than FFh) then it will be reset to the value specified in TMA (FF06), and an interrupt will be requested, as described below.

===FF06 - TMA - Timer Modulo (R/W)===
When the TIMA overflows, this data will be loaded.

===FF07 - TAC - Timer Control (R/W)===

  Bit  2   - Timer Enable
  Bits 1-0 - Input Clock Select
             00: CPU Clock / 1024 (DMG, CGB:   4096 Hz, SGB:   ~4194 Hz)
             01: CPU Clock / 16   (DMG, CGB: 262144 Hz, SGB: ~268400 Hz)
             10: CPU Clock / 64   (DMG, CGB:  65536 Hz, SGB:  ~67110 Hz)
             11: CPU Clock / 256  (DMG, CGB:  16384 Hz, SGB:  ~16780 Hz)
  
  Note: The &quot;Timer Enable&quot; bit only affects the timer, the divider is '''ALWAYS''' counting.

===INT 50 - Timer Interrupt===
Each time when the timer overflows (ie. when TIMA gets bigger than FFh), then an interrupt is requested by setting Bit 2 in the IF Register (FF0F). When that interrupt is enabled, then the CPU will execute it by calling the timer interrupt vector at 0050h.

== Note ==
The above described Timer is the built-in timer in the gameboy. It has nothing to do with the MBC3s battery buffered Real Time Clock - that's a completely different thing, described in the chapter about Memory Banking Controllers.</text>
      <sha1>7h3xfwtcjqhbuo8wfznk0gbp32my5mt</sha1>
    </revision>
    <revision>
      <id>560</id>
      <parentid>446</parentid>
      <timestamp>2014-11-22T23:43:05Z</timestamp>
      <contributor>
        <username>AntonioND</username>
        <id>47</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1805">{{Pandocs|timeranddividerregisters}}

Read this page for a more detailed description of what the registers do: [[Timer Obscure Behaviour]]

===FF04 - DIV - Divider Register (R/W)===
This register is incremented at rate of 16384Hz (~16779Hz on SGB). Writing any value to this register resets it to 00h.

Note: The divider is affected by CGB double speed mode, and will increment at 32768Hz in double speed.

===FF05 - TIMA - Timer counter (R/W)===
This timer is incremented by a clock frequency specified by the TAC register ($FF07). When the value overflows (gets bigger than FFh) then it will be reset to the value specified in TMA (FF06), and an interrupt will be requested, as described below.

===FF06 - TMA - Timer Modulo (R/W)===
When the TIMA overflows, this data will be loaded.

===FF07 - TAC - Timer Control (R/W)===

  Bit  2   - Timer Enable
  Bits 1-0 - Input Clock Select
             00: CPU Clock / 1024 (DMG, CGB:   4096 Hz, SGB:   ~4194 Hz)
             01: CPU Clock / 16   (DMG, CGB: 262144 Hz, SGB: ~268400 Hz)
             10: CPU Clock / 64   (DMG, CGB:  65536 Hz, SGB:  ~67110 Hz)
             11: CPU Clock / 256  (DMG, CGB:  16384 Hz, SGB:  ~16780 Hz)
  
  Note: The &quot;Timer Enable&quot; bit only affects the timer, the divider is '''ALWAYS''' counting.

===INT 50 - Timer Interrupt===
Each time when the timer overflows (ie. when TIMA gets bigger than FFh), then an interrupt is requested by setting Bit 2 in the IF Register (FF0F). When that interrupt is enabled, then the CPU will execute it by calling the timer interrupt vector at 0050h.

== Note ==
The above described Timer is the built-in timer in the gameboy. It has nothing to do with the MBC3s battery buffered Real Time Clock - that's a completely different thing, described in the chapter about Memory Banking Controllers.</text>
      <sha1>jz1jcshyegqivza5ratfu7tdcauqif3</sha1>
    </revision>
    <revision>
      <id>562</id>
      <parentid>560</parentid>
      <timestamp>2014-11-22T23:44:47Z</timestamp>
      <contributor>
        <username>AntonioND</username>
        <id>47</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1835">{{Pandocs|timeranddividerregisters}}

===FF04 - DIV - Divider Register (R/W)===
This register is incremented at rate of 16384Hz (~16779Hz on SGB). Writing any value to this register resets it to 00h.

Note: The divider is affected by CGB double speed mode, and will increment at 32768Hz in double speed.

===FF05 - TIMA - Timer counter (R/W)===
This timer is incremented by a clock frequency specified by the TAC register ($FF07). When the value overflows (gets bigger than FFh) then it will be reset to the value specified in TMA (FF06), and an interrupt will be requested, as described below.

===FF06 - TMA - Timer Modulo (R/W)===
When the TIMA overflows, this data will be loaded.

===FF07 - TAC - Timer Control (R/W)===

  Bit  2   - Timer Enable
  Bits 1-0 - Input Clock Select
             00: CPU Clock / 1024 (DMG, CGB:   4096 Hz, SGB:   ~4194 Hz)
             01: CPU Clock / 16   (DMG, CGB: 262144 Hz, SGB: ~268400 Hz)
             10: CPU Clock / 64   (DMG, CGB:  65536 Hz, SGB:  ~67110 Hz)
             11: CPU Clock / 256  (DMG, CGB:  16384 Hz, SGB:  ~16780 Hz)
  
  Note: The &quot;Timer Enable&quot; bit only affects the timer, the divider is '''ALWAYS''' counting.

===INT 50 - Timer Interrupt===
Each time when the timer overflows (ie. when TIMA gets bigger than FFh), then an interrupt is requested by setting Bit 2 in the IF Register (FF0F). When that interrupt is enabled, then the CPU will execute it by calling the timer interrupt vector at 0050h.

===Timer Obscure Behaviour===
Read this page for a more detailed description of what the registers do: [[Timer Obscure Behaviour]]

== Note ==
The above described Timer is the built-in timer in the gameboy. It has nothing to do with the MBC3s battery buffered Real Time Clock - that's a completely different thing, described in the chapter about Memory Banking Controllers.</text>
      <sha1>4xs5der8gay0c263894v7fopefsbcql</sha1>
    </revision>
  </page>
  <page>
    <title>Interrupts</title>
    <ns>0</ns>
    <id>48</id>
    <revision>
      <id>152</id>
      <timestamp>2009-06-28T10:41:05Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: ===IME - Interrupt Master Enable Flag (Write Only)===    0 - Disable all Interrupts   1 - Enable all Interrupts that are enabled in IE Register (FFFF)  The IME flag is used to disable all ...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3961">===IME - Interrupt Master Enable Flag (Write Only)===

  0 - Disable all Interrupts
  1 - Enable all Interrupts that are enabled in IE Register (FFFF)

The IME flag is used to disable all interrupts, overriding any enabled bits in the IE Register. It isn't possible to access the IME flag by using a I/O address, instead IME is accessed directly from the CPU, by the following opcodes/operations:

  EI     ;Enable Interrupts  (ie. IME=1)
  DI     ;Disable Interrupts (ie. IME=0)
  RETI   ;Enable Ints &amp; Return (same as the opcode combination EI, RET)
  &lt;INT&gt;  ;Disable Ints &amp; Call to Interrupt Vector

Whereas &lt;INT&gt; means the operation which is automatically executed by the CPU when it executes an interrupt.

===FFFF - IE - Interrupt Enable (R/W)===

  Bit 0: V-Blank  Interrupt Enable  (INT 40h)  (1=Enable)
  Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=Enable)
  Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=Enable)
  Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=Enable)
  Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=Enable)


===FF0F - IF - Interrupt Flag (R/W)===

  Bit 0: V-Blank  Interrupt Request (INT 40h)  (1=Request)
  Bit 1: LCD STAT Interrupt Request (INT 48h)  (1=Request)
  Bit 2: Timer    Interrupt Request (INT 50h)  (1=Request)
  Bit 3: Serial   Interrupt Request (INT 58h)  (1=Request)
  Bit 4: Joypad   Interrupt Request (INT 60h)  (1=Request)

When an interrupt signal changes from low to high, then the corresponding bit in the IF register becomes set. For example, Bit 0 becomes set when the LCD controller enters into the V-Blank period.

===Interrupt Requests===
Any set bits in the IF register are only &lt;requesting&gt; an interrupt to be executed. The actual &lt;execution&gt; happens only if both the IME flag, and the corresponding bit in the IE register are set, otherwise the interrupt 'waits' until both IME and IE allow its execution.

===Interrupt Execution===
When an interrupt gets executed, the corresponding bit in the IF register becomes automatically reset by the CPU, and the IME flag becomes cleared (disabeling any further interrupts until the program re-enables the interrupts, typically by using the RETI instruction), and the corresponding Interrupt Vector (that are the addresses in range 0040h-0060h, as shown in IE and IF register decriptions above) becomes called.

===Manually Requesting/Discarding Interrupts===
As the CPU automatically sets and cleares the bits in the IF register it is usually not required to write to the IF register. However, the user may still do that in order to manually request (or discard) interrupts. As for real interrupts, a manually requested interrupt isn't executed unless/until IME and IE allow its execution.

===Interrupt Priorities===
In the following three situations it might happen that more than 1 bit in the IF register are set, requesting more than one interrupt at once:

  1) More than one interrupt signal changed from Low
     to High at the same time.
  2) Several interrupts have been requested during a
     time in which IME/IE didn't allow these interrupts
     to be executed directly.
  3) The user has written a value with several &quot;1&quot; bits
     (for example 1Fh) to the IF register.

Provided that IME and IE allow the execution of more than one of the requested interrupts, then the interrupt with the highest priority becomes executed first. The priorities are ordered as the bits in the IE and IF registers, Bit 0 (V-Blank) having the highest priority, and Bit 4 (Joypad) having the lowest priority.

===Nested Interrupts===
The CPU automatically disables all other interrupts by setting IME=0 when it executes an interrupt. Usually IME remains zero until the interrupt procedure returns (and sets IME=1 by the RETI instruction). However, if you want any other interrupts of lower or higher (or same) priority to be allowed to be executed from inside of the interrupt procedure, then you can place an EI instruction into the interrupt procedure.</text>
      <sha1>fswjazpq8lb5w3k3ya7v9hlr5n9mxvt</sha1>
    </revision>
    <revision>
      <id>172</id>
      <parentid>152</parentid>
      <timestamp>2009-06-28T12:56:23Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3984">{{Pandocs|interrupts}}
===IME - Interrupt Master Enable Flag (Write Only)===

  0 - Disable all Interrupts
  1 - Enable all Interrupts that are enabled in IE Register (FFFF)

The IME flag is used to disable all interrupts, overriding any enabled bits in the IE Register. It isn't possible to access the IME flag by using a I/O address, instead IME is accessed directly from the CPU, by the following opcodes/operations:

  EI     ;Enable Interrupts  (ie. IME=1)
  DI     ;Disable Interrupts (ie. IME=0)
  RETI   ;Enable Ints &amp; Return (same as the opcode combination EI, RET)
  &lt;INT&gt;  ;Disable Ints &amp; Call to Interrupt Vector

Whereas &lt;INT&gt; means the operation which is automatically executed by the CPU when it executes an interrupt.

===FFFF - IE - Interrupt Enable (R/W)===

  Bit 0: V-Blank  Interrupt Enable  (INT 40h)  (1=Enable)
  Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=Enable)
  Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=Enable)
  Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=Enable)
  Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=Enable)


===FF0F - IF - Interrupt Flag (R/W)===

  Bit 0: V-Blank  Interrupt Request (INT 40h)  (1=Request)
  Bit 1: LCD STAT Interrupt Request (INT 48h)  (1=Request)
  Bit 2: Timer    Interrupt Request (INT 50h)  (1=Request)
  Bit 3: Serial   Interrupt Request (INT 58h)  (1=Request)
  Bit 4: Joypad   Interrupt Request (INT 60h)  (1=Request)

When an interrupt signal changes from low to high, then the corresponding bit in the IF register becomes set. For example, Bit 0 becomes set when the LCD controller enters into the V-Blank period.

===Interrupt Requests===
Any set bits in the IF register are only &lt;requesting&gt; an interrupt to be executed. The actual &lt;execution&gt; happens only if both the IME flag, and the corresponding bit in the IE register are set, otherwise the interrupt 'waits' until both IME and IE allow its execution.

===Interrupt Execution===
When an interrupt gets executed, the corresponding bit in the IF register becomes automatically reset by the CPU, and the IME flag becomes cleared (disabeling any further interrupts until the program re-enables the interrupts, typically by using the RETI instruction), and the corresponding Interrupt Vector (that are the addresses in range 0040h-0060h, as shown in IE and IF register decriptions above) becomes called.

===Manually Requesting/Discarding Interrupts===
As the CPU automatically sets and cleares the bits in the IF register it is usually not required to write to the IF register. However, the user may still do that in order to manually request (or discard) interrupts. As for real interrupts, a manually requested interrupt isn't executed unless/until IME and IE allow its execution.

===Interrupt Priorities===
In the following three situations it might happen that more than 1 bit in the IF register are set, requesting more than one interrupt at once:

  1) More than one interrupt signal changed from Low
     to High at the same time.
  2) Several interrupts have been requested during a
     time in which IME/IE didn't allow these interrupts
     to be executed directly.
  3) The user has written a value with several &quot;1&quot; bits
     (for example 1Fh) to the IF register.

Provided that IME and IE allow the execution of more than one of the requested interrupts, then the interrupt with the highest priority becomes executed first. The priorities are ordered as the bits in the IE and IF registers, Bit 0 (V-Blank) having the highest priority, and Bit 4 (Joypad) having the lowest priority.

===Nested Interrupts===
The CPU automatically disables all other interrupts by setting IME=0 when it executes an interrupt. Usually IME remains zero until the interrupt procedure returns (and sets IME=1 by the RETI instruction). However, if you want any other interrupts of lower or higher (or same) priority to be allowed to be executed from inside of the interrupt procedure, then you can place an EI instruction into the interrupt procedure.</text>
      <sha1>8x5nbrngel7qj8bzzfqvjc9b3z2fg8i</sha1>
    </revision>
    <revision>
      <id>442</id>
      <parentid>172</parentid>
      <timestamp>2012-05-25T11:50:26Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4628">{{Pandocs|interrupts}}
===IME - Interrupt Master Enable Flag (Write Only)===

  0 - Disable all Interrupts
  1 - Enable all Interrupts that are enabled in IE Register (FFFF)

The IME flag is used to disable all interrupts, overriding any enabled bits in the IE Register. It isn't possible to access the IME flag by using a I/O address, instead IME is accessed directly from the CPU, by the following opcodes/operations:

  EI     ;Enable Interrupts  (ie. IME=1)
  DI     ;Disable Interrupts (ie. IME=0)
  RETI   ;Enable Ints &amp; Return (same as the opcode combination EI, RET)
  &lt;INT&gt;  ;Disable Ints &amp; Call to Interrupt Vector

Whereas &lt;INT&gt; means the operation which is automatically executed by the CPU when it executes an interrupt.

===FFFF - IE - Interrupt Enable (R/W)===

  Bit 0: V-Blank  Interrupt Enable  (INT 40h)  (1=Enable)
  Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=Enable)
  Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=Enable)
  Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=Enable)
  Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=Enable)


===FF0F - IF - Interrupt Flag (R/W)===

  Bit 0: V-Blank  Interrupt Request (INT 40h)  (1=Request)
  Bit 1: LCD STAT Interrupt Request (INT 48h)  (1=Request)
  Bit 2: Timer    Interrupt Request (INT 50h)  (1=Request)
  Bit 3: Serial   Interrupt Request (INT 58h)  (1=Request)
  Bit 4: Joypad   Interrupt Request (INT 60h)  (1=Request)

When an interrupt signal changes from low to high, then the corresponding bit in the IF register becomes set. For example, Bit 0 becomes set when the LCD controller enters into the V-Blank period.

===Interrupt Requests===
Any set bits in the IF register are only &lt;requesting&gt; an interrupt to be executed. The actual &lt;execution&gt; happens only if both the IME flag, and the corresponding bit in the IE register are set, otherwise the interrupt 'waits' until both IME and IE allow its execution.

===Interrupt Execution===
When an interrupt gets executed, the corresponding bit in the IF register becomes automatically reset by the CPU, and the IME flag becomes cleared (disabeling any further interrupts until the program re-enables the interrupts, typically by using the RETI instruction), and the corresponding Interrupt Vector (that are the addresses in range 0040h-0060h, as shown in IE and IF register decriptions above) becomes called.

===Manually Requesting/Discarding Interrupts===
As the CPU automatically sets and cleares the bits in the IF register it is usually not required to write to the IF register. However, the user may still do that in order to manually request (or discard) interrupts. As for real interrupts, a manually requested interrupt isn't executed unless/until IME and IE allow its execution.

===Interrupt Priorities===
In the following three situations it might happen that more than 1 bit in the IF register are set, requesting more than one interrupt at once:

  1) More than one interrupt signal changed from Low
     to High at the same time.
  2) Several interrupts have been requested during a
     time in which IME/IE didn't allow these interrupts
     to be executed directly.
  3) The user has written a value with several &quot;1&quot; bits
     (for example 1Fh) to the IF register.

Provided that IME and IE allow the execution of more than one of the requested interrupts, then the interrupt with the highest priority becomes executed first. The priorities are ordered as the bits in the IE and IF registers, Bit 0 (V-Blank) having the highest priority, and Bit 4 (Joypad) having the lowest priority.

===Nested Interrupts===
The CPU automatically disables all other interrupts by setting IME=0 when it executes an interrupt. Usually IME remains zero until the interrupt procedure returns (and sets IME=1 by the RETI instruction). However, if you want any other interrupts of lower or higher (or same) priority to be allowed to be executed from inside of the interrupt procedure, then you can place an EI instruction into the interrupt procedure.

===Interrupt Service Routine===
According to Z80 datasheets, the following occurs when control is being transferred to an interrupt handler:

1. Two wait states are executed (2 machine cycles pass while nothing occurs, presumably the CPU is executing NOPs during this time).
2. The current PC is pushed onto the stack, this process consumes 2 more machine cycles.
3. The high byte of the PC is set to 0, the low byte is set to the address of the handler ($40,$48,$50,$58,$60). This consumes one last machine cycle.

The entire ISR *should* consume a total of 5 machine cycles. This has yet to be tested, but is what the Z80 datasheet implies.</text>
      <sha1>jdzcgf8k3irokebljhwbmxyt8f1ulh8</sha1>
    </revision>
    <revision>
      <id>443</id>
      <parentid>442</parentid>
      <timestamp>2012-05-25T11:51:35Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>/* Interrupt Service Routine */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4644">{{Pandocs|interrupts}}
===IME - Interrupt Master Enable Flag (Write Only)===

  0 - Disable all Interrupts
  1 - Enable all Interrupts that are enabled in IE Register (FFFF)

The IME flag is used to disable all interrupts, overriding any enabled bits in the IE Register. It isn't possible to access the IME flag by using a I/O address, instead IME is accessed directly from the CPU, by the following opcodes/operations:

  EI     ;Enable Interrupts  (ie. IME=1)
  DI     ;Disable Interrupts (ie. IME=0)
  RETI   ;Enable Ints &amp; Return (same as the opcode combination EI, RET)
  &lt;INT&gt;  ;Disable Ints &amp; Call to Interrupt Vector

Whereas &lt;INT&gt; means the operation which is automatically executed by the CPU when it executes an interrupt.

===FFFF - IE - Interrupt Enable (R/W)===

  Bit 0: V-Blank  Interrupt Enable  (INT 40h)  (1=Enable)
  Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=Enable)
  Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=Enable)
  Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=Enable)
  Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=Enable)


===FF0F - IF - Interrupt Flag (R/W)===

  Bit 0: V-Blank  Interrupt Request (INT 40h)  (1=Request)
  Bit 1: LCD STAT Interrupt Request (INT 48h)  (1=Request)
  Bit 2: Timer    Interrupt Request (INT 50h)  (1=Request)
  Bit 3: Serial   Interrupt Request (INT 58h)  (1=Request)
  Bit 4: Joypad   Interrupt Request (INT 60h)  (1=Request)

When an interrupt signal changes from low to high, then the corresponding bit in the IF register becomes set. For example, Bit 0 becomes set when the LCD controller enters into the V-Blank period.

===Interrupt Requests===
Any set bits in the IF register are only &lt;requesting&gt; an interrupt to be executed. The actual &lt;execution&gt; happens only if both the IME flag, and the corresponding bit in the IE register are set, otherwise the interrupt 'waits' until both IME and IE allow its execution.

===Interrupt Execution===
When an interrupt gets executed, the corresponding bit in the IF register becomes automatically reset by the CPU, and the IME flag becomes cleared (disabeling any further interrupts until the program re-enables the interrupts, typically by using the RETI instruction), and the corresponding Interrupt Vector (that are the addresses in range 0040h-0060h, as shown in IE and IF register decriptions above) becomes called.

===Manually Requesting/Discarding Interrupts===
As the CPU automatically sets and cleares the bits in the IF register it is usually not required to write to the IF register. However, the user may still do that in order to manually request (or discard) interrupts. As for real interrupts, a manually requested interrupt isn't executed unless/until IME and IE allow its execution.

===Interrupt Priorities===
In the following three situations it might happen that more than 1 bit in the IF register are set, requesting more than one interrupt at once:

  1) More than one interrupt signal changed from Low
     to High at the same time.
  2) Several interrupts have been requested during a
     time in which IME/IE didn't allow these interrupts
     to be executed directly.
  3) The user has written a value with several &quot;1&quot; bits
     (for example 1Fh) to the IF register.

Provided that IME and IE allow the execution of more than one of the requested interrupts, then the interrupt with the highest priority becomes executed first. The priorities are ordered as the bits in the IE and IF registers, Bit 0 (V-Blank) having the highest priority, and Bit 4 (Joypad) having the lowest priority.

===Nested Interrupts===
The CPU automatically disables all other interrupts by setting IME=0 when it executes an interrupt. Usually IME remains zero until the interrupt procedure returns (and sets IME=1 by the RETI instruction). However, if you want any other interrupts of lower or higher (or same) priority to be allowed to be executed from inside of the interrupt procedure, then you can place an EI instruction into the interrupt procedure.

===Interrupt Service Routine===
According to Z80 datasheets, the following occurs when control is being transferred to an interrupt handler:

1. Two wait states are executed (2 machine cycles pass while nothing occurs, presumably the CPU is executing NOPs during this time).&lt;br&gt;
2. The current PC is pushed onto the stack, this process consumes 2 more machine cycles.&lt;br&gt;
3. The high byte of the PC is set to 0, the low byte is set to the address of the handler ($40,$48,$50,$58,$60). This consumes one last machine cycle.&lt;br&gt;

The entire ISR '''should''' consume a total of 5 machine cycles. This has yet to be tested, but is what the Z80 datasheet implies.</text>
      <sha1>75fds26ominfn461z1w3x9igcj24n1l</sha1>
    </revision>
    <revision>
      <id>862</id>
      <parentid>443</parentid>
      <timestamp>2019-03-16T23:27:57Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* IME - Interrupt Master Enable Flag (Write Only) */ EI DI does not allow interrupts</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4792">{{Pandocs|interrupts}}
===IME - Interrupt Master Enable Flag (Write Only)===

  0 - Disable all Interrupts
  1 - Enable all Interrupts that are enabled in IE Register (FFFF)

The IME flag is used to disable all interrupts, overriding any enabled bits in the IE Register. It isn't possible to access the IME flag by using a I/O address, instead IME is accessed directly from the CPU, by the following opcodes/operations:

  EI     ;Enable Interrupts  (ie. IME=1)
  DI     ;Disable Interrupts (ie. IME=0)
  RETI   ;Enable Ints &amp; Return (same as the opcode combination EI, RET)
  &lt;INT&gt;  ;Disable Ints &amp; Call to Interrupt Vector

Whereas &lt;INT&gt; means the operation which is automatically executed by the CPU when it executes an interrupt.

The effect of EI is delayed by one instruction. This means that EI followed immediately by DI does not allow interrupts between the EI and the DI.

===FFFF - IE - Interrupt Enable (R/W)===

  Bit 0: V-Blank  Interrupt Enable  (INT 40h)  (1=Enable)
  Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=Enable)
  Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=Enable)
  Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=Enable)
  Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=Enable)


===FF0F - IF - Interrupt Flag (R/W)===

  Bit 0: V-Blank  Interrupt Request (INT 40h)  (1=Request)
  Bit 1: LCD STAT Interrupt Request (INT 48h)  (1=Request)
  Bit 2: Timer    Interrupt Request (INT 50h)  (1=Request)
  Bit 3: Serial   Interrupt Request (INT 58h)  (1=Request)
  Bit 4: Joypad   Interrupt Request (INT 60h)  (1=Request)

When an interrupt signal changes from low to high, then the corresponding bit in the IF register becomes set. For example, Bit 0 becomes set when the LCD controller enters into the V-Blank period.

===Interrupt Requests===
Any set bits in the IF register are only &lt;requesting&gt; an interrupt to be executed. The actual &lt;execution&gt; happens only if both the IME flag, and the corresponding bit in the IE register are set, otherwise the interrupt 'waits' until both IME and IE allow its execution.

===Interrupt Execution===
When an interrupt gets executed, the corresponding bit in the IF register becomes automatically reset by the CPU, and the IME flag becomes cleared (disabeling any further interrupts until the program re-enables the interrupts, typically by using the RETI instruction), and the corresponding Interrupt Vector (that are the addresses in range 0040h-0060h, as shown in IE and IF register decriptions above) becomes called.

===Manually Requesting/Discarding Interrupts===
As the CPU automatically sets and cleares the bits in the IF register it is usually not required to write to the IF register. However, the user may still do that in order to manually request (or discard) interrupts. As for real interrupts, a manually requested interrupt isn't executed unless/until IME and IE allow its execution.

===Interrupt Priorities===
In the following three situations it might happen that more than 1 bit in the IF register are set, requesting more than one interrupt at once:

  1) More than one interrupt signal changed from Low
     to High at the same time.
  2) Several interrupts have been requested during a
     time in which IME/IE didn't allow these interrupts
     to be executed directly.
  3) The user has written a value with several &quot;1&quot; bits
     (for example 1Fh) to the IF register.

Provided that IME and IE allow the execution of more than one of the requested interrupts, then the interrupt with the highest priority becomes executed first. The priorities are ordered as the bits in the IE and IF registers, Bit 0 (V-Blank) having the highest priority, and Bit 4 (Joypad) having the lowest priority.

===Nested Interrupts===
The CPU automatically disables all other interrupts by setting IME=0 when it executes an interrupt. Usually IME remains zero until the interrupt procedure returns (and sets IME=1 by the RETI instruction). However, if you want any other interrupts of lower or higher (or same) priority to be allowed to be executed from inside of the interrupt procedure, then you can place an EI instruction into the interrupt procedure.

===Interrupt Service Routine===
According to Z80 datasheets, the following occurs when control is being transferred to an interrupt handler:

1. Two wait states are executed (2 machine cycles pass while nothing occurs, presumably the CPU is executing NOPs during this time).&lt;br&gt;
2. The current PC is pushed onto the stack, this process consumes 2 more machine cycles.&lt;br&gt;
3. The high byte of the PC is set to 0, the low byte is set to the address of the handler ($40,$48,$50,$58,$60). This consumes one last machine cycle.&lt;br&gt;

The entire ISR '''should''' consume a total of 5 machine cycles. This has yet to be tested, but is what the Z80 datasheet implies.</text>
      <sha1>nd7kg0lfyfm511u2rvntzvw9ic8r3w7</sha1>
    </revision>
  </page>
  <page>
    <title>CGB Registers</title>
    <ns>0</ns>
    <id>49</id>
    <revision>
      <id>153</id>
      <timestamp>2009-06-28T10:42:43Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: ===Forward=== This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color ...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4677">===Forward===
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

===Unlocking CGB functions===
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

===Detecting CGB (and GBA) functions===
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

===FF6C - Undocumented (FEh) - Bit 0 (Read/Write) - CGB Mode Only===
===FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only===
===FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)===
===FF76 - Undocumented (00h) - Always 00h (Read Only)===
===FF77 - Undocumented (00h) - Always 00h (Read Only)===
These are undocumented CGB Registers. The numbers in brackets () indicate the initial values. Purpose of these registers is unknown (if any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB Mode.</text>
      <sha1>9d0y80j3c2xfv1ak6c8o47d7m2fjque</sha1>
    </revision>
    <revision>
      <id>173</id>
      <parentid>153</parentid>
      <timestamp>2009-06-28T12:56:55Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4702">{{Pandocs|cgbregisters}}
===Forward===
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

===Unlocking CGB functions===
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

===Detecting CGB (and GBA) functions===
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

===FF6C - Undocumented (FEh) - Bit 0 (Read/Write) - CGB Mode Only===
===FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only===
===FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)===
===FF76 - Undocumented (00h) - Always 00h (Read Only)===
===FF77 - Undocumented (00h) - Always 00h (Read Only)===
These are undocumented CGB Registers. The numbers in brackets () indicate the initial values. Purpose of these registers is unknown (if any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB Mode.</text>
      <sha1>d07m36ckw4hku6wiqp92vco4w8hwajo</sha1>
    </revision>
    <revision>
      <id>543</id>
      <parentid>173</parentid>
      <timestamp>2014-09-09T19:57:33Z</timestamp>
      <contributor>
        <username>LIJI</username>
        <id>43</id>
      </contributor>
      <comment>/* FF77 - Undocumented (00h) - Always 00h (Read Only) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4784">{{Pandocs|cgbregisters}}
===Forward===
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

===Unlocking CGB functions===
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

===Detecting CGB (and GBA) functions===
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

===FF6C - Undocumented (FEh) - Bit 0 (Read/Write) - CGB Mode Only===
===FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only===
===FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)===
===FF76 - Undocumented (00h) - Always 00h (Read Only)===
===FF77 - Undocumented (00h) - (Read Only)===
These are undocumented CGB Registers. The numbers in brackets () indicate the initial values. Purpose of these registers is unknown (if any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB Mode. Register FF77 is 00h when no sound is playing, and alternates between 00h and 0Fh otherwise.</text>
      <sha1>43ass31f96b4nlxb6rsh4fsrsjii5mh</sha1>
    </revision>
    <revision>
      <id>544</id>
      <parentid>543</parentid>
      <timestamp>2014-09-09T22:10:06Z</timestamp>
      <contributor>
        <username>LIJI</username>
        <id>43</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4918">{{Pandocs|cgbregisters}}
===Forward===
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

===Unlocking CGB functions===
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

===Detecting CGB (and GBA) functions===
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

===FF6C - Undocumented (FEh) - Bit 0 (Read/Write) - CGB Mode Only===
===FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only===
===FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)===
===FF76 - Undocumented (00h) - (Read Only)===
===FF77 - Undocumented (00h) - (Read Only)===
These are undocumented CGB Registers. The numbers in brackets () indicate the initial values. Purpose of these registers is unknown (if any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB Mode. Each of the four nibbles in registers FF76-FF77 represent the current PCM amplitude (00h-0Fh) in each of the four sound channels, where the lower nibble of FF76 represents the channel 1 and the higher nibble in FF77 represents channel 4.</text>
      <sha1>mwxu6q9ppycb9ctco49jq18ne3nxup1</sha1>
    </revision>
    <revision>
      <id>583</id>
      <parentid>544</parentid>
      <timestamp>2015-05-04T22:51:49Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <comment>/* FF76 - Undocumented (00h) - (Read Only) */ For better readability</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4950">{{Pandocs|cgbregisters}}
===Forward===
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

===Unlocking CGB functions===
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

===Detecting CGB (and GBA) functions===
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

===FF6C - Undocumented (FEh) - Bit 0 (Read/Write) - CGB Mode Only===
===FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only===
===FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)===
===FF76 - Undocumented (00h) - (Read Only)===
PCM amplitude, channel 1 and 2

===FF77 - Undocumented (00h) - (Read Only)===
These are undocumented CGB Registers. The numbers in brackets () indicate the initial values. Purpose of these registers is unknown (if any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB Mode. Each of the four nibbles in registers FF76-FF77 represent the current PCM amplitude (00h-0Fh) in each of the four sound channels, where the lower nibble of FF76 represents the channel 1 and the higher nibble in FF77 represents channel 4.</text>
      <sha1>2qo5fqiueix9l4gp1cdfemwjx7tjgcs</sha1>
    </revision>
    <revision>
      <id>584</id>
      <parentid>583</parentid>
      <timestamp>2015-05-04T22:52:39Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <comment>/* FF77 - Undocumented (00h) - (Read Only) */ For better readability</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4984">{{Pandocs|cgbregisters}}
===Forward===
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

===Unlocking CGB functions===
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

===Detecting CGB (and GBA) functions===
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

===FF6C - Undocumented (FEh) - Bit 0 (Read/Write) - CGB Mode Only===
===FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only===
===FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)===
===FF76 - Undocumented (00h) - (Read Only)===
PCM amplitude, channel 1 and 2

===FF77 - Undocumented (00h) - (Read Only)===
PCM amplitude, channel 3 and 4.


These are undocumented CGB Registers. The numbers in brackets () indicate the initial values. Purpose of these registers is unknown (if any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB Mode. Each of the four nibbles in registers FF76-FF77 represent the current PCM amplitude (00h-0Fh) in each of the four sound channels, where the lower nibble of FF76 represents the channel 1 and the higher nibble in FF77 represents channel 4.</text>
      <sha1>thw4thbdtoin22tvtnkh7lhqmlq514u</sha1>
    </revision>
    <revision>
      <id>585</id>
      <parentid>584</parentid>
      <timestamp>2015-05-04T22:53:19Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4987">{{Pandocs|cgbregisters}}
===Forward===
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

===Unlocking CGB functions===
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

===Detecting CGB (and GBA) functions===
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

===FF6C - Undocumented (FEh) - Bit 0 (Read/Write) - CGB Mode Only===
===FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)===
===FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only===
===FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)===
===FF76 - Undocumented (00h) - (Read Only)===
PCM amplitude, channels 1 and 2.

===FF77 - Undocumented (00h) - (Read Only)===
PCM amplitude, channels 3 and 4.


These are undocumented CGB Registers. The numbers in brackets () indicate the initial values. Purpose of these registers is unknown (if any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB Mode. Each of the four nibbles in registers FF76-FF77 represent the current PCM amplitude (00h-0Fh) in each of the four sound channels, where the lower nibble of FF76 represents the channel 1 and the higher nibble in FF77 represents channel 4.</text>
      <sha1>5abeni124ga4a8hlbjbe8k522675erz</sha1>
    </revision>
    <revision>
      <id>750</id>
      <parentid>585</parentid>
      <timestamp>2017-05-09T22:09:39Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>Reorganization.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5330">{{Pandocs|cgbregisters}}
==Forward==
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

==Unlocking CGB functions==
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

==Detecting CGB (and GBA) functions==
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

==Documented registers==
===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

==Undocumented registers==
These are undocumented CGB Registers. Purpose of these registers is unknown (if any). It isn't recommended to use them in your software, but you could, for example, use them to check if you are running on an emulator or on DMG hardware.

===FF6C - Bit 0 (Read/Write) - CGB Mode Only===
Only the least significant bit of this register can be written to. It defaults to 0, so this register's initial value is $FE.

In non-CGB mode, it isn't writable, and its value is locked at $FF.

===FF72 - Bits 0-7 (Read/Write)===
===FF73 - Bits 0-7 (Read/Write)===
Both of these registers are fully read/write. Their initial value is $00.

===FF74 - Bits 0-7 (Read/Write) - CGB Mode Only===
In CGB mode, this register is fully readable and writable. Its initial value is $00.

Otherwise, this register is read-only, and locked at value $FF.

===FF75 - Bits 4-6 (Read/Write)===
Only bits 4, 5 and 6 of this register are read/write enabled. Their initial value is 0.

===FF76 - PCM amplitudes 1 &amp; 2 (Read Only)===
This register is read-only. The low nibble is a copy of sound channel #1's PCM amplitude, the high byte a copy of sound channel #2's.

===FF77 - PCM amplitudes 3 &amp; 4 (Read Only)===
Same, but with channels 3 and 4.</text>
      <sha1>oinpxmq159klxr2eg3qkgxcwxlfhf9p</sha1>
    </revision>
    <revision>
      <id>804</id>
      <parentid>750</parentid>
      <timestamp>2018-11-04T20:59:14Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* FF76 - PCM amplitudes 1 &amp; 2 (Read Only) */ Some people threw a tantrum over this, apparently. Can you guys please wait ONE SECOND please?</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5332">{{Pandocs|cgbregisters}}
==Forward==
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

==Unlocking CGB functions==
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

==Detecting CGB (and GBA) functions==
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

==Documented registers==
===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

==Undocumented registers==
These are undocumented CGB Registers. Purpose of these registers is unknown (if any). It isn't recommended to use them in your software, but you could, for example, use them to check if you are running on an emulator or on DMG hardware.

===FF6C - Bit 0 (Read/Write) - CGB Mode Only===
Only the least significant bit of this register can be written to. It defaults to 0, so this register's initial value is $FE.

In non-CGB mode, it isn't writable, and its value is locked at $FF.

===FF72 - Bits 0-7 (Read/Write)===
===FF73 - Bits 0-7 (Read/Write)===
Both of these registers are fully read/write. Their initial value is $00.

===FF74 - Bits 0-7 (Read/Write) - CGB Mode Only===
In CGB mode, this register is fully readable and writable. Its initial value is $00.

Otherwise, this register is read-only, and locked at value $FF.

===FF75 - Bits 4-6 (Read/Write)===
Only bits 4, 5 and 6 of this register are read/write enabled. Their initial value is 0.

===FF76 - PCM amplitudes 1 &amp; 2 (Read Only)===
This register is read-only. The low nibble is a copy of sound channel #1's PCM amplitude, the high nibble a copy of sound channel #2's.

===FF77 - PCM amplitudes 3 &amp; 4 (Read Only)===
Same, but with channels 3 and 4.</text>
      <sha1>nlr12936qjpow0fzonpkv5f1d39yegu</sha1>
    </revision>
    <revision>
      <id>805</id>
      <parentid>804</parentid>
      <timestamp>2018-11-06T23:44:52Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* Undocumented registers */ Add unofficial official names for two undocumented registers</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5348">{{Pandocs|cgbregisters}}
==Forward==
This chapter describes only CGB (Color Gameboy) registers that didn't fit into normal categories - most CGB registers are described in the chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, a changed bit is noted in the chapter about the Serial/Link port.

==Unlocking CGB functions==
When using any CGB registers (including those in the Video/Link chapters), you must first unlock CGB features by changing byte 0143h in the cartridge header. Typically use a value of 80h for games which support both CGB and monochrome gameboys, and C0h for games which work on CGBs only. Otherwise, the CGB will operate in monochrome &quot;Non CGB&quot; compatibility mode.

==Detecting CGB (and GBA) functions==
CGB hardware can be detected by examing the CPU accumulator (A-register) directly after startup. A value of 11h indicates CGB (or GBA) hardware, if so, CGB functions can be used (if unlocked, see above).
When A=11h, you may also examine Bit 0 of the CPUs B-Register to separate between CGB (bit cleared) and GBA (bit set), by that detection it is possible to use 'repaired' color palette data matching for GBA displays.

==Documented registers==
===FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch===

  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)

This register is used to prepare the gameboy to switch between CGB Double Speed Mode and Normal Speed Mode. The actual speed switch is performed by executing a STOP command after Bit 0 has been set. After that Bit 0 will be cleared automatically, and the gameboy will operate at the 'other' speed. The recommended speed switching procedure in pseudo code would be:

  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF

The CGB is operating in Normal Speed Mode when it is turned on. Note that using the Double Speed Mode increases the power consumption, it would be recommended to use Single Speed whenever possible. However, the display will flicker (white) for a moment during speed switches, so this cannot be done permanentely.
In Double Speed Mode the following will operate twice as fast as normal:

  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM

And the following will keep operating as usual:

  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies


===FF56 - RP - CGB Mode Only - Infrared Communications Port===
This register allows to input and output data through the CGBs built-in Infrared Port. When reading data, bit 6 and 7 must be set (and obviously Bit 0 must be cleared - if you don't want to receive your own gameboys IR signal). After sending or receiving data you should reset the register to 00h to reduce battery power consumption again.

  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)

Note that the receiver will adapt itself to the normal level of IR pollution in the air, so if you would send a LED ON signal for a longer period, then the receiver would treat that as normal (=OFF) after a while. For example, a Philips TV Remote Control sends a series of 32 LED ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 880us LED ON signal.
Even though being generally CGB compatible, the GBA does not include an infra-red port.

===FF70 - SVBK - CGB Mode Only - WRAM Bank===
In CGB Mode 32 KBytes internal RAM are available. This memory is divided into 8 banks of 4 KBytes each. Bank 0 is always available in memory at C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.

  Bit 0-2  Select WRAM Bank (Read/Write)

Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h will select Bank 1 either.

==Undocumented registers==
These are undocumented CGB Registers. Purpose of these registers is unknown (if any). It isn't recommended to use them in your software, but you could, for example, use them to check if you are running on an emulator or on DMG hardware.

===FF6C - Bit 0 (Read/Write) - CGB Mode Only===
Only the least significant bit of this register can be written to. It defaults to 0, so this register's initial value is $FE.

In non-CGB mode, it isn't writable, and its value is locked at $FF.

===FF72 - Bits 0-7 (Read/Write)===
===FF73 - Bits 0-7 (Read/Write)===
Both of these registers are fully read/write. Their initial value is $00.

===FF74 - Bits 0-7 (Read/Write) - CGB Mode Only===
In CGB mode, this register is fully readable and writable. Its initial value is $00.

Otherwise, this register is read-only, and locked at value $FF.

===FF75 - Bits 4-6 (Read/Write)===
Only bits 4, 5 and 6 of this register are read/write enabled. Their initial value is 0.

===FF76 - PCM12 - PCM amplitudes 1 &amp; 2 (Read Only)===
This register is read-only. The low nibble is a copy of sound channel #1's PCM amplitude, the high nibble a copy of sound channel #2's.

===FF77 - PCM34 - PCM amplitudes 3 &amp; 4 (Read Only)===
Same, but with channels 3 and 4.</text>
      <sha1>r0hqpqwsmgns8v01hn13khyb3x3msth</sha1>
    </revision>
  </page>
  <page>
    <title>SGB Functions</title>
    <ns>0</ns>
    <id>50</id>
    <revision>
      <id>154</id>
      <timestamp>2009-06-28T10:50:54Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: == SGB Description ==  ===General Description=== Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="38556">== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent).

Avoiding Screen Garbage
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.


== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

===Using Gameboy BGP/OBP Registers===
A direct translation of color 0-3 into color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. Basically, this is completely irrelevant because the palettes are just stored in RAM whithout any relationship to the displayed picture, anyways, these pre-defined colors may be transferred to actually visible palettes slightly faster as when transferring palette data by separate command packets.


== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palette to actual SGB palette.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, set P14 and P15 low (one after each other) to select Buttons and Cursor lines, and read-out joypad state as normally. When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.


== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 16bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Reportedly, non-transparent border data will cover the gameboy window.

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>jbg180svdrvplt7qjt24qcg7st8zl8s</sha1>
    </revision>
    <revision>
      <id>174</id>
      <parentid>154</parentid>
      <timestamp>2009-06-28T12:57:39Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="38581">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent).

Avoiding Screen Garbage
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.


== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

===Using Gameboy BGP/OBP Registers===
A direct translation of color 0-3 into color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. Basically, this is completely irrelevant because the palettes are just stored in RAM whithout any relationship to the displayed picture, anyways, these pre-defined colors may be transferred to actually visible palettes slightly faster as when transferring palette data by separate command packets.


== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palette to actual SGB palette.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, set P14 and P15 low (one after each other) to select Buttons and Cursor lines, and read-out joypad state as normally. When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.


== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 16bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Reportedly, non-transparent border data will cover the gameboy window.

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>3tvdldfzky5wnweiwc90iimw11n6v7f</sha1>
    </revision>
    <revision>
      <id>802</id>
      <parentid>174</parentid>
      <timestamp>2018-10-14T21:59:44Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* SGB Command 13h - CHR_TRN */ Fix tile size</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="38609">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent).

Avoiding Screen Garbage
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.


== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

===Using Gameboy BGP/OBP Registers===
A direct translation of color 0-3 into color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. Basically, this is completely irrelevant because the palettes are just stored in RAM whithout any relationship to the displayed picture, anyways, these pre-defined colors may be transferred to actually visible palettes slightly faster as when transferring palette data by separate command packets.


== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palette to actual SGB palette.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, set P14 and P15 low (one after each other) to select Buttons and Cursor lines, and read-out joypad state as normally. When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.


== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Reportedly, non-transparent border data will cover the gameboy window.

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>9r7ai4v5prva1a59awx54aud3idfum7</sha1>
    </revision>
    <revision>
      <id>803</id>
      <parentid>802</parentid>
      <timestamp>2018-10-18T05:30:48Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Reading Multiple Controllers (Joypads) */ Clarify the requirements for polling</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="38565">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent).

Avoiding Screen Garbage
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.


== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

===Using Gameboy BGP/OBP Registers===
A direct translation of color 0-3 into color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. Basically, this is completely irrelevant because the palettes are just stored in RAM whithout any relationship to the displayed picture, anyways, these pre-defined colors may be transferred to actually visible palettes slightly faster as when transferring palette data by separate command packets.


== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palette to actual SGB palette.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Reportedly, non-transparent border data will cover the gameboy window.

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>h0y6acnf4960rawdz8u8pqbesqij6b7</sha1>
    </revision>
    <revision>
      <id>813</id>
      <parentid>803</parentid>
      <timestamp>2018-11-18T17:51:57Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* SGB Command 14h - PCT_TRN */ You can feel that Pan did veeeery thorough research, huh...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="38594">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent).

Avoiding Screen Garbage
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.


== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

===Using Gameboy BGP/OBP Registers===
A direct translation of color 0-3 into color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. Basically, this is completely irrelevant because the palettes are just stored in RAM whithout any relationship to the displayed picture, anyways, these pre-defined colors may be transferred to actually visible palettes slightly faster as when transferring palette data by separate command packets.


== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palette to actual SGB palette.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>2e3ovc9xmz1to6fdell526ihyy7r4ai</sha1>
    </revision>
    <revision>
      <id>814</id>
      <parentid>813</parentid>
      <timestamp>2018-11-19T12:10:37Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* Transfer Time */ Clarify status of displayed data, restore section name</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="38700">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

===Using Gameboy BGP/OBP Registers===
A direct translation of color 0-3 into color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. Basically, this is completely irrelevant because the palettes are just stored in RAM whithout any relationship to the displayed picture, anyways, these pre-defined colors may be transferred to actually visible palettes slightly faster as when transferring palette data by separate command packets.


== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palette to actual SGB palette.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>one5k6izyj6rtjm1otl0bukx731469s</sha1>
    </revision>
    <revision>
      <id>815</id>
      <parentid>814</parentid>
      <timestamp>2018-11-19T13:29:02Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* SGB Color Palettes Overview */ Misc clarifications</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="39022">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palette to actual SGB palette.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>r9g046dxfczer7myi6phtct2km3wtg7</sha1>
    </revision>
    <revision>
      <id>816</id>
      <parentid>815</parentid>
      <timestamp>2018-11-19T13:30:14Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* SGB Command 0Ah - PAL_SET */ Clarify endianness</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="39071">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>n74fvmlakfuuquylxmu68la8b3br7mw</sha1>
    </revision>
    <revision>
      <id>817</id>
      <parentid>816</parentid>
      <timestamp>2018-11-20T13:16:21Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* SGB Command 18h - OBJ_TRN */ Disassembly of the SGBv2 firmware showed that this command's handler only contains a `RTS`. Need to check on all revisions.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="39144">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv1?, SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>gvb61t5q6d96ellyz1hf3v1t5mr3c4y</sha1>
    </revision>
    <revision>
      <id>818</id>
      <parentid>817</parentid>
      <timestamp>2018-11-20T13:17:40Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* SGB Command 0Dh - TEST_EN */ Add warning that function is stubbed on SGBv2</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="39231">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv1?, SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).</text>
      <sha1>7gs8t66mw9a3prkl5xdoj3l10vs9wrp</sha1>
    </revision>
    <revision>
      <id>819</id>
      <parentid>818</parentid>
      <timestamp>2018-11-20T14:20:50Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>Add section about undocumented commands</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="39878">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet must be set to zero.
A 60ms (4 frames) delay should be invoked between each packet transfer.


== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>g9yyaccpfgyaxgdm0nwyshr8hivi1pl</sha1>
    </revision>
    <revision>
      <id>820</id>
      <parentid>819</parentid>
      <timestamp>2018-12-03T11:31:13Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* Transferring Packets */ The SGB firmware doesn't even read those bytes.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="39870">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI handler, the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game &quot;Space Invaders 94&quot; uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The type of the CPU which is used in the SNES is unknown ???


== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>e3nil55hrpi8g2rx00x2bdqqhx8ilxs</sha1>
    </revision>
    <revision>
      <id>823</id>
      <parentid>820</parentid>
      <timestamp>2018-12-10T17:47:41Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* SGB Command 12h - JUMP */ SNES CPU is a 65C816; SNES NMI is its vblank interrupt</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="40024">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.
&quot;Notes&quot;
1) Mute is only active when both bits D2 and D3 are 1.
2) When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
3) When Mute on/off has been executed, the sound fades out/fades in.
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI (vblank interrupt) handler; the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>e7b7k6l7wyce9udlbj0gm6hkdv1438p</sha1>
    </revision>
    <revision>
      <id>825</id>
      <parentid>823</parentid>
      <timestamp>2019-01-04T14:27:47Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* SGB Command 08h - SOUND */ Fix formatting of notes</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="40020">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.

Notes:
# Mute is only active when both bits D2 and D3 are 1.
# When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
# When Mute on/off has been executed, the sound fades out/fades in.
# Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI (vblank interrupt) handler; the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such:

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

Even though 32x32 map entries are transferred, only upper 32x28 are actually used (256x224 pixels, SNES screen size). The 20x18 entries in the center of the 32x28 area should be set to 0000h as transparent space for the gameboy window to be displayed inside. Non-transparent border data will cover the gameboy window (for example, Mario's Picross does this).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>jpg7ditceeb1l50vpkdb6dh0i1koqjy</sha1>
    </revision>
    <revision>
      <id>903</id>
      <parentid>825</parentid>
      <timestamp>2019-08-26T17:57:40Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* SGB Command 14h - PCT_TRN */ 700-7FF of this isn't even used, as it corresponds to the unused bottom 4 tilemap rows</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="40114">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

The value transferred as color 0 will be applied for all eight palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.

Notes:
# Mute is only active when both bits D2 and D3 are 1.
# When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
# When Mute on/off has been executed, the sound fades out/fades in.
# Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI (vblank interrupt) handler; the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-6FF  BG Map 32x28 Entries of 16bit each (1792 bytes)
  700-7FF  Not used, don't care
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such: &lt;code&gt;VH01 PP00 NNNN NNNN&lt;/code&gt;

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

The 32x28 map entries correspond to 256x224 pixels of the Super NES screen. The 20x18 entries in the center of the 32x28 area should be set to a blank (solid color 0) tile as transparent space for the Game Boy window to be displayed inside. Non-transparent border data will cover the Game Boy window (for example, ''Mario's Picross'' does this, as does ''WildSnake'' to a lesser extent).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>cikle6kojo8ewrz7oqept8f8jlsbdtv</sha1>
    </revision>
    <revision>
      <id>904</id>
      <parentid>903</parentid>
      <timestamp>2019-08-26T18:01:51Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* SGB Command 00h - PAL01 */ SGB and GBC sharing palette data</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="40258">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

This is the same RGB5 format as [[Video Display#LCD Color Palettes (CGB only)|Game Boy Color palette entry]], though without the LCD correction. The value transferred as color 0 will be applied for all four palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.

Notes:
# Mute is only active when both bits D2 and D3 are 1.
# When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
# When Mute on/off has been executed, the sound fades out/fades in.
# Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI (vblank interrupt) handler; the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the gameboy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. (Actually, just setting P15 LOW is enough). When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-6FF  BG Map 32x28 Entries of 16bit each (1792 bytes)
  700-7FF  Not used, don't care
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such: &lt;code&gt;VH01 PP00 NNNN NNNN&lt;/code&gt;

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

The 32x28 map entries correspond to 256x224 pixels of the Super NES screen. The 20x18 entries in the center of the 32x28 area should be set to a blank (solid color 0) tile as transparent space for the Game Boy window to be displayed inside. Non-transparent border data will cover the Game Boy window (for example, ''Mario's Picross'' does this, as does ''WildSnake'' to a lesser extent).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>jc2tegjjgyuc02yfti612jlmxu543og</sha1>
    </revision>
    <revision>
      <id>910</id>
      <parentid>904</parentid>
      <timestamp>2019-09-07T02:27:43Z</timestamp>
      <contributor>
        <username>Endrift</username>
        <id>74</id>
      </contributor>
      <comment>/* SGB Multiplayer Command */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="41213">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

This is the same RGB5 format as [[Video Display#LCD Color Palettes (CGB only)|Game Boy Color palette entry]], though without the LCD correction. The value transferred as color 0 will be applied for all four palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.

Notes:
# Mute is only active when both bits D2 and D3 are 1.
# When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
# When Mute on/off has been executed, the sound fades out/fades in.
# Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI (vblank interrupt) handler; the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the Game Boy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

Changing the number of active players ANDs the currently selected player minus one with the number of players in that mode minus one. For example if you go from four players to two players and player 4 was active player 2 will then be active because 3 AND 1 is 1. However, sending the MLT_REQ command will increment the counter several times so results may not be exactly as expected. The most frequent case is going from one player to two-or-four player which will always start with player 1 active.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

If for whatever reason you want to increment the joypad number without reading the joypad state you only need to set P15 to LOW before setting it back to HIGH. Adjusting P14 does not affect whether or not the joypad number will advance, However, if you set P15 to LOW then HIGH then LOW again without bringing both P14 and P15 HIGH at any point, it cancels the increment until P15 is lowered again. There are games, such as Pokémon Yellow, which rely on this cancelling when detecting the SGB.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-6FF  BG Map 32x28 Entries of 16bit each (1792 bytes)
  700-7FF  Not used, don't care
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such: &lt;code&gt;VH01 PP00 NNNN NNNN&lt;/code&gt;

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

The 32x28 map entries correspond to 256x224 pixels of the Super NES screen. The 20x18 entries in the center of the 32x28 area should be set to a blank (solid color 0) tile as transparent space for the Game Boy window to be displayed inside. Non-transparent border data will cover the Game Boy window (for example, ''Mario's Picross'' does this, as does ''WildSnake'' to a lesser extent).

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>mfzphozvlkhqa08yvrc6yu7fte2ozyc</sha1>
    </revision>
    <revision>
      <id>927</id>
      <parentid>910</parentid>
      <timestamp>2019-10-02T04:03:59Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* SGB Command 14h - PCT_TRN */ All borders repeat tiles</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="41706">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

This is the same RGB5 format as [[Video Display#LCD Color Palettes (CGB only)|Game Boy Color palette entry]], though without the LCD correction. The value transferred as color 0 will be applied for all four palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.

Notes:
# Mute is only active when both bits D2 and D3 are 1.
# When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
# When Mute on/off has been executed, the sound fades out/fades in.
# Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is totally unclear what an attraction mode is ???, but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)


===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI (vblank interrupt) handler; the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the Game Boy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

Changing the number of active players ANDs the currently selected player minus one with the number of players in that mode minus one. For example if you go from four players to two players and player 4 was active player 2 will then be active because 3 AND 1 is 1. However, sending the MLT_REQ command will increment the counter several times so results may not be exactly as expected. The most frequent case is going from one player to two-or-four player which will always start with player 1 active.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

If for whatever reason you want to increment the joypad number without reading the joypad state you only need to set P15 to LOW before setting it back to HIGH. Adjusting P14 does not affect whether or not the joypad number will advance, However, if you set P15 to LOW then HIGH then LOW again without bringing both P14 and P15 HIGH at any point, it cancels the increment until P15 is lowered again. There are games, such as Pokémon Yellow, which rely on this cancelling when detecting the SGB.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-6FF  BG Map 32x28 Entries of 16bit each (1792 bytes)
  700-7FF  Not used, don't care
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such: &lt;code&gt;VH01 PP00 NNNN NNNN&lt;/code&gt;

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

The 32x28 map entries correspond to 256x224 pixels of the Super NES screen. The 20x18 entries in the center of the 32x28 area should be set to a blank (solid color 0) tile as transparent space for the Game Boy window to be displayed inside. Non-transparent border data will cover the Game Boy window (for example, ''Mario's Picross'' does this, as does ''WildSnake'' to a lesser extent).

All borders repeat tiles. Assuming that the blank space for the GB screen is a single tile, as is the letterbox in a widescreen border, a border defining all unique tiles would have to define this many tiles:

* (256*224-160*144)/64+1 = 537 tiles in fullscreen border
* (256*176-160*144)/64+2 = 346 tiles in widescreen border

But the CHR RAM allocated by SGB for border holds only 256 tiles. This means a fullscreen border must repeat at least 281 tiles and a widescreen border at least 90.

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>5ea6bz4f1ln3njs8xtj9gcttacxb7pq</sha1>
    </revision>
    <revision>
      <id>928</id>
      <parentid>927</parentid>
      <timestamp>2019-10-02T04:07:20Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* SGB Command 0Ch - ATRC_EN */ When GB controls are left idle?</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="41804">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

This is the same RGB5 format as [[Video Display#LCD Color Palettes (CGB only)|Game Boy Color palette entry]], though without the LCD correction. The value transferred as color 0 will be applied for all four palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.

Notes:
# Mute is only active when both bits D2 and D3 are 1.
# When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
# When Mute on/off has been executed, the sound fades out/fades in.
# Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is not certain what an attraction mode is (probably the screen-saver that many built-in borders activate when GB controls are left idle for a while), but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)

===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter to a specified address. Optionally, it may be used to set a new address for the SNES NMI (vblank interrupt) handler; the NMI handler remains unchanged if all bytes 4-6 are zero.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

Note: The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the Game Boy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

Changing the number of active players ANDs the currently selected player minus one with the number of players in that mode minus one. For example if you go from four players to two players and player 4 was active player 2 will then be active because 3 AND 1 is 1. However, sending the MLT_REQ command will increment the counter several times so results may not be exactly as expected. The most frequent case is going from one player to two-or-four player which will always start with player 1 active.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

If for whatever reason you want to increment the joypad number without reading the joypad state you only need to set P15 to LOW before setting it back to HIGH. Adjusting P14 does not affect whether or not the joypad number will advance, However, if you set P15 to LOW then HIGH then LOW again without bringing both P14 and P15 HIGH at any point, it cancels the increment until P15 is lowered again. There are games, such as Pokémon Yellow, which rely on this cancelling when detecting the SGB.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-6FF  BG Map 32x28 Entries of 16bit each (1792 bytes)
  700-7FF  Not used, don't care
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such: &lt;code&gt;VH01 PP00 NNNN NNNN&lt;/code&gt;

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

The 32x28 map entries correspond to 256x224 pixels of the Super NES screen. The 20x18 entries in the center of the 32x28 area should be set to a blank (solid color 0) tile as transparent space for the Game Boy window to be displayed inside. Non-transparent border data will cover the Game Boy window (for example, ''Mario's Picross'' does this, as does ''WildSnake'' to a lesser extent).

All borders repeat tiles. Assuming that the blank space for the GB screen is a single tile, as is the letterbox in a widescreen border, a border defining all unique tiles would have to define this many tiles:

* (256*224-160*144)/64+1 = 537 tiles in fullscreen border
* (256*176-160*144)/64+2 = 346 tiles in widescreen border

But the CHR RAM allocated by SGB for border holds only 256 tiles. This means a fullscreen border must repeat at least 281 tiles and a widescreen border at least 90.

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>0nq6jlnvb2tg4uoewxorno9jh4uri5u</sha1>
    </revision>
    <revision>
      <id>930</id>
      <parentid>928</parentid>
      <timestamp>2019-10-02T04:55:47Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* SGB Command 12h - JUMP */ JUMP notes from fullsnes</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="42454">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

This is the same RGB5 format as [[Video Display#LCD Color Palettes (CGB only)|Game Boy Color palette entry]], though without the LCD correction. The value transferred as color 0 will be applied for all four palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.

Notes:
# Mute is only active when both bits D2 and D3 are 1.
# When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
# When Mute on/off has been executed, the sound fades out/fades in.
# Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode. It is not certain what an attraction mode is (probably the screen-saver that many built-in borders activate when GB controls are left idle for a while), but it is enabled by default.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)

===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter and NMI (vblank interrupt) handler to specific addresses.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

Some notes for intrepid Super NES programmers seeking to use a flash cartridge in a Super Game Boy as a storage server:
* JUMP overwrites the NMI handler even if it is $000000.
* The SGB system software does not appear to use NMIs.
* JUMP can return to SGB system software via a 16-bit RTS. To do this, JML to a location in bank $00 containing byte value $60, such as any of the [[#Stubbed commands|stubbed commands]].
* IRQs and COP and BRK instructions are not useful because their handlers still point into SGB ROM. Use SEI WAI.
* If a program called through JUMP does not intend to return to SGB system software, it can overwrite all Super NES RAM except $0000BB through $0000BD, the NMI vector.
* To enter APU boot ROM, write $FE to $2140. Echo will still be on though.

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the Game Boy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

Changing the number of active players ANDs the currently selected player minus one with the number of players in that mode minus one. For example if you go from four players to two players and player 4 was active player 2 will then be active because 3 AND 1 is 1. However, sending the MLT_REQ command will increment the counter several times so results may not be exactly as expected. The most frequent case is going from one player to two-or-four player which will always start with player 1 active.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

If for whatever reason you want to increment the joypad number without reading the joypad state you only need to set P15 to LOW before setting it back to HIGH. Adjusting P14 does not affect whether or not the joypad number will advance, However, if you set P15 to LOW then HIGH then LOW again without bringing both P14 and P15 HIGH at any point, it cancels the increment until P15 is lowered again. There are games, such as Pokémon Yellow, which rely on this cancelling when detecting the SGB.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-6FF  BG Map 32x28 Entries of 16bit each (1792 bytes)
  700-7FF  Not used, don't care
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such: &lt;code&gt;VH01 PP00 NNNN NNNN&lt;/code&gt;

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

The 32x28 map entries correspond to 256x224 pixels of the Super NES screen. The 20x18 entries in the center of the 32x28 area should be set to a blank (solid color 0) tile as transparent space for the Game Boy window to be displayed inside. Non-transparent border data will cover the Game Boy window (for example, ''Mario's Picross'' does this, as does ''WildSnake'' to a lesser extent).

All borders repeat tiles. Assuming that the blank space for the GB screen is a single tile, as is the letterbox in a widescreen border, a border defining all unique tiles would have to define this many tiles:

* (256*224-160*144)/64+1 = 537 tiles in fullscreen border
* (256*176-160*144)/64+2 = 346 tiles in widescreen border

But the CHR RAM allocated by SGB for border holds only 256 tiles. This means a fullscreen border must repeat at least 281 tiles and a widescreen border at least 90.

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>fz59zo6t7dkaxqpe2f0hjam54sp9ph9</sha1>
    </revision>
    <revision>
      <id>931</id>
      <parentid>930</parentid>
      <timestamp>2019-10-02T05:08:59Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* SGB Command 0Ch - ATRC_EN */ Describe screen savers, which I suspect this relates to</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="42586">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

This is the same RGB5 format as [[Video Display#LCD Color Palettes (CGB only)|Game Boy Color palette entry]], though without the LCD correction. The value transferred as color 0 will be applied for all four palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.

Notes:
# Mute is only active when both bits D2 and D3 are 1.
# When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
# When Mute on/off has been executed, the sound fades out/fades in.
# Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode, which is enabled by default.

Built-in borders other than the Game Boy frame and the plain black border have a &quot;screen saver&quot; activated by pressing R, L, L, L, L, R or by leaving the controller alone for roughly 7 minutes (tested with 144p Test Suite).
It is speculated that attraction mode disables these borders.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)

===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter and NMI (vblank interrupt) handler to specific addresses.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

Some notes for intrepid Super NES programmers seeking to use a flash cartridge in a Super Game Boy as a storage server:
* JUMP overwrites the NMI handler even if it is $000000.
* The SGB system software does not appear to use NMIs.
* JUMP can return to SGB system software via a 16-bit RTS. To do this, JML to a location in bank $00 containing byte value $60, such as any of the [[#Stubbed commands|stubbed commands]].
* IRQs and COP and BRK instructions are not useful because their handlers still point into SGB ROM. Use SEI WAI.
* If a program called through JUMP does not intend to return to SGB system software, it can overwrite all Super NES RAM except $0000BB through $0000BD, the NMI vector.
* To enter APU boot ROM, write $FE to $2140. Echo will still be on though.

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the Game Boy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

Changing the number of active players ANDs the currently selected player minus one with the number of players in that mode minus one. For example if you go from four players to two players and player 4 was active player 2 will then be active because 3 AND 1 is 1. However, sending the MLT_REQ command will increment the counter several times so results may not be exactly as expected. The most frequent case is going from one player to two-or-four player which will always start with player 1 active.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

If for whatever reason you want to increment the joypad number without reading the joypad state you only need to set P15 to LOW before setting it back to HIGH. Adjusting P14 does not affect whether or not the joypad number will advance, However, if you set P15 to LOW then HIGH then LOW again without bringing both P14 and P15 HIGH at any point, it cancels the increment until P15 is lowered again. There are games, such as Pokémon Yellow, which rely on this cancelling when detecting the SGB.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-6FF  BG Map 32x28 Entries of 16bit each (1792 bytes)
  700-7FF  Not used, don't care
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such: &lt;code&gt;VH01 PP00 NNNN NNNN&lt;/code&gt;

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

The 32x28 map entries correspond to 256x224 pixels of the Super NES screen. The 20x18 entries in the center of the 32x28 area should be set to a blank (solid color 0) tile as transparent space for the Game Boy window to be displayed inside. Non-transparent border data will cover the Game Boy window (for example, ''Mario's Picross'' does this, as does ''WildSnake'' to a lesser extent).

All borders repeat tiles. Assuming that the blank space for the GB screen is a single tile, as is the letterbox in a widescreen border, a border defining all unique tiles would have to define this many tiles:

* (256*224-160*144)/64+1 = 537 tiles in fullscreen border
* (256*176-160*144)/64+2 = 346 tiles in widescreen border

But the CHR RAM allocated by SGB for border holds only 256 tiles. This means a fullscreen border must repeat at least 281 tiles and a widescreen border at least 90.

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>px6685v5uwa4ble1uxbn7tustni2drj</sha1>
    </revision>
    <revision>
      <id>934</id>
      <parentid>931</parentid>
      <timestamp>2019-11-11T15:02:14Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* SGB Command 0Ch - ATRC_EN */ Clarify what it's speculated to disable</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="42689">{{Pandocs|sgbfunctions}}
== SGB Description ==

===General Description===
Basically, the SGB (Super Gameboy) is an adapter cartridge that allows to play gameboy games on a SNES (Super Nintendo Entertainment System) gaming console. In detail, you plug the gameboy cartridge into the SGB cartridge, then plug the SGB cartridge into the SNES, and then connect the SNES to your TV Set. In result, games can be played and viewed on the TV Set, and are controlled by using the SNES joypad(s).

===More Technical Description===
The SGB cartridge just contains a normal gameboy CPU and normal gameboy video controller. Normally the video signal from this controller would be sent to the LCD screen, however, in this special case the SNES read out the video signal and displays it on the TV set by using a special SNES BIOS ROM which is located in the SGB cartridge. Also, normal gameboy sound output is forwared to the SNES and output to the TV Set, vice versa, joypad input is forwared from the SNES controller(s) to the gameboy joypad inputs.

===Normal Monochrome Games===
Any gameboy games which have been designed for normal monochrome handheld gameboys will work with the SGB hardware as well. The SGB will apply a four color palette to these games by replacing the normal four grayshades. The 160x144 pixel gamescreen is displayed in the middle of the 256x224 pixel SNES screen (the unused area is filled by a screen border bitmap). The user may access built-in menues, allowing to change color palette data, to select between several pre-defined borders, etc.

Games that have been designed to support SGB functions may also access the following additional features:

===Colorized Game Screen===
There's limited ability to colorize the gamescreen by assigning custom color palettes to each 20x18 display characters, however, this works mainly for static display data such like title screens or status bars, the 20x18 color attribute map is non-scrollable, and it is not possible to assign separate colors to moveable foreground sprites (OBJs), so that animated screen regions will be typically restricted to using a single palette of four colors only.

===SNES Foreground Sprites===
Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can be displayed. When replacing (or just overlaying) the normal gameboy OBJs by SNES OBJs it'd be thus possible to display OBJs with other colors than normal background area. This method doesn't appear to be very popular, even though it appears to be quite easy to implement, however, the bottommost character line of the gamescreen will be masked out because this area is used to transfer OAM data to the SNES.

===The SGB Border===
The possibly most popular and most impressive feature is to replace the default SGB screen border by a custom bitmap which is stored in the game cartridge.

===Multiple Joypads===
Up to four joypads can be conected to the SNES, and SGB software may read-out each of these joypads separately, allowing up to four players to play the same game simultaneously. Unlike for multiplayer handheld games, this requires only one game cartridge and only one SGB/SNES, and no link cables are required, the downside is that all players must share the same display screen.

===Sound Functions===
Beside for normal gameboy sound, a number of digital sound effects is pre-defined in the SNES BIOS, these effects may be accessed quite easily. Programmers whom are familiar with SNES sounds may also access the SNES sound chip, or use the SNES MIDI engine directly in order to produce other sound effects or music.

===Taking Control of the SNES CPU===
Finally, it is possible to write program code or data into SNES memory, and to execute such program code by using the SNES CPU.

===SGB System Clock===
Because the SGB is synchronized to the SNES CPU, the gameboy system clock is directly chained to the SNES system clock. In result, the gameboy CPU, video controller, timers, and sound frequencies will be all operated approx 2.4% faster as by normal gameboys.
Basically, this should be no problem, and the game will just run a little bit faster. However sensitive musicians may notice that sound frequencies are a bit too high, programs that support SGB functions may avoid this effect by reducing frequencies of gameboy sounds when having detected SGB hardware.
Also, I think that I've heard that SNES models which use a 50Hz display refresh rate (rather than 60Hz) are resulting in respectively slower SGB/gameboy timings ???


== SGB Unlocking and Detecting SGB Functions ==

===Cartridge Header===
SGB games are required to have a cartridge header with Nintendo and proper checksum just as normal gameboy games. Also, two special entries must be set in order to unlock SGB functions:

  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games

When these entries aren't set, the game will still work just like all 'monochrome' gameboy games, but it cannot access any of the special SGB functions.

===Detecting SGB hardware===
The recommended detection method is to send a MLT_REQ command which enables two (or four) joypads. A normal handheld gameboy will ignore this command, a SGB will now return incrementing joypad IDs each time when deselecting keyboard lines (see MLT_REQ description for details).
Now read-out joypad state/IDs several times, and if the ID-numbers are changing, then it is a SGB (a normal gameboy would typically always return 0Fh as ID). Finally, when not intending to use more than one joypad, send another MLT_REQ command in order to re-disable the multi-controller mode.
Detection works regardless of whether and how many joypads are physically connected to the SNES. However, detection works only when having unlocked SGB functions in the cartridge header, as described above.

===Separating between SGB and SGB2===
It is also possible to separate between SGB and SGB2 models by examining the inital value of the accumulator (A-register) directly after startup.

  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA

Because values 01h and FFh are shared for both handhelds and SGBs, it is still required to use the above MLT_REQ detection procedure. As far as I know the SGB2 doesn't have any extra features which'd require separate SGB2 detection except for curiosity purposes, for example, the game &quot;Tetris DX&quot; chooses to display an alternate SGB border on SGB2s.

Reportedly, some SGB models include link ports (just like handheld gameboy) (my own SGB does not have such an port), possibly this feature is available in SGB2-type models only ???


== SGB Command Packet Transfers ==

Command packets (aka Register Files) are transferred from the gameboy to the SNES by using P14 and P15 output lines of the JOYPAD register (FF00h), these lines are normally used to select the two rows in the gameboy keyboard matrix (which still works).

===Transferring Bits===
A command packet transfer must be initiated by setting both P14 and P15 to LOW, this will reset and start the SNES packet receiving program. Data is then transferred (LSB first), setting P14=LOW will indicate a &quot;0&quot; bit, and setting P15=LOW will indicate a &quot;1&quot; bit. For example:

       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...

Data and reset pulses must be kept LOW for at least 5us. P14 and P15 must be kept both HIGH for at least 15us between any pulses.
Obviously, it'd be no good idea to access the JOYPAD register during the transfer, for example, in case that your VBlank interrupt procedure reads-out joypad states each frame, be sure to disable that interrupt during the transfer (or disable only the joypad procedure by using a software flag).

===Transferring Packets===
Each packet is invoked by a RESET pulse, then 128 bits of data are transferred (16 bytes, LSB of first byte first), and finally, a &quot;0&quot;-bit must be transferred as stop bit. The structure of normal packets is:

   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)

The above 'Length' indicates the total number of packets (1-7, including the first packet) which will be sent, ie. if more than 15 parameter bytes are used, then further packet(s) will follow, as such:

   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)

By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.
Unused bytes at the end of the last packet don't matter.
A 60ms (4 frames) delay should be invoked between each packet transfer.

== SGB VRAM Transfers ==

===Overview===
Beside for the packet transfer method, larger data blocks of 4KBytes can be transferred by using the video signal. These transfers are invoked by first sending one of the commands with the ending _TRN (by using normal packet transfer), the 4K data block is then read-out by the SNES from gameboy display memory during the next frame.

===Transfer Data===
Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,
even though the SNES receives the data in from display scanlines, it will automatically re-produce the same ordering of bits and bytes, as being originally stored at 8000h-8FFFh in gameboy memory.

===Preparing the Display===
The above method works only when recursing the following things: BG Map must display unsigned characters 00h-FFh on the screen; 00h..13h in first line, 14h..27h in next line, etc. The gameboy display must be enabled, the display may not be scrolled, OBJ sprites should not overlap the background tiles, the BGP palette register must be set to E4h.

===Transfer Time===
Note that the transfer data should be prepared in VRAM &lt;before&gt; sending the transfer command packet. The actual transfer starts at the beginning of the next frame after the command has been sent, and the transfer ends at the end of the 5th frame after the command has been sent (not counting the frame in which the command has been sent). The displayed data must not be modified during the transfer, as the SGB reads it in multiple chunks.

===Avoiding Screen Garbage===
The display will contain 'garbage' during the transfer, this dirt-effect can be avoided by freezing the screen (in the state which has been displayed before the transfer) by using the MASK_EN command.
Of course, this works only when actually executing the game on a SGB (and not on normal handheld gameboys), it'd be thus required to detect the presence of SGB hardware before blindly sending VRAM data.

== SGB Command Summary ==

===SGB System Command Table===

  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  &quot;Block&quot; Area Designation Mode
  05   ATTR_LIN  &quot;Line&quot; Area Designation Mode
  06   ATTR_DIV  &quot;Divide&quot; Area Designation Mode
  07   ATTR_CHR  &quot;1CHR&quot; Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode



== SGB Color Palettes Overview ==

===Available SNES Palettes===
The SGB/SNES provides 8 palettes of 16 colors each, each color may be defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are used to colorize the gamescreen, only the first four colors of each of these palettes are used. Palettes 4-7 are used for the SGB Border, all 16 colors of each of these palettes may be used.

===Color format===

Colors are encoded as 16-bit RGB numbers, in the following way:

  FEDC BA98 7654 3210
  0BBB BBGG GGGR RRRR

Here's a formula to convert 24-bit RGB into SNES format: &lt;code&gt;(color &amp; 0xF8) &lt;&lt; 7 | (color &amp; 0xF800) &gt;&gt; 6 | (color &amp; 0xF80000) &gt;&gt; 19&lt;/code&gt;

The palettes are encoded '''little-endian''', thus, the R/G byte comes first in memory.

===Color 0 Restriction===
Color 0 of each of the eight palettes is transparent, causing the backdrop color to be displayed instead. The backdrop color is typically defined by the most recently color being assigned to Color 0 (regardless of the palette number being used for that operation).
Effectively, gamescreen palettes can have only three custom colors each, and SGB border palettes only 15 colors each, additionally, color 0 can be used for for all palettes, which will then all share the same color though.

===Translation of Grayshades into Colors===
Because the SGB/SNES reads out the gameboy video controllers display signal, it translates the different grayshades from the signal into SNES colors as such:

  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3

Note that gameboy colors 0-3 are assigned to user-selectable grayshades by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed relationship between gameboy colors 0-3 and SNES colors 0-3.

====Using Gameboy BGP/OBP Registers====
A direct translation of GB color 0-3 into SNES color 0-3 may be produced by setting BGP/OBP registers to a value of 0E4h each. However, in case that your program uses black background for example, then you may internally assign background as &quot;White&quot; at the gameboy side by BGP/OBP registers (which is then interpreted as SNES color 0, which is shared for all SNES palettes). The advantage is that you may define Color 0 as Black at the SNES side, and may assign custom colors for Colors 1-3 of each SNES palette.

===System Color Palette Memory===
Beside for the actually visible palettes, up to 512 palettes of 4 colors each may be defined in SNES RAM. The palettes are just stored in RAM without any relationship to the displayed picture; however, these pre-defined colors may be transferred to actually visible palettes slightly faster than when transferring palette data by separate command packets.

== SGB Palette Commands ==

===SGB Command 00h - PAL01===
Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, color 1-3 (without separate color 0).

  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)

This is the same RGB5 format as [[Video Display#LCD Color Palettes (CGB only)|Game Boy Color palette entry]], though without the LCD correction. The value transferred as color 0 will be applied for all four palettes.

===SGB Command 01h - PAL23===
Same as above PAL01, but for Palettes 2 and 3 respectively.

===SGB Command 02h - PAL03===
Same as above PAL01, but for Palettes 0 and 3 respectively.

===SGB Command 03h - PAL12===
Same as above PAL01, but for Palettes 1 and 2 respectively.

===SGB Command 0Ah - PAL_SET===
Used to copy pre-defined palette data from SGB system color palettes to actual SNES palettes.

Note: all palette numbers are little-endian.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)

Before using this function, System Palette data should be initialized by PAL_TRN command, and (when used) Attribute File data should be initialized by ATTR_TRN.

===SGB Command 0Bh - PAL_TRN===
Used to initialize SGB system color palettes in SNES RAM.
System color palette memory contains 512 pre-defined palettes, these palettes do not directly affect the display, however, the PAL_SET command may be later used to transfer four of these 'logical' palettes to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ palettes (16 colors).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The palette data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data for System Color Palette 0-511

Each Palette consists of four 16bit-color definitions (8 bytes).
Note: The data is stored at 3000h-3FFFh in SNES memory.


== SGB Color Attribute Commands ==

===SGB Command 04h - ATTR_BLK===
Used to specify color attributes for the inside or outside of one or more rectangular screen regions.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)

When sending three or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets is described below.

===SGB Command 05h - ATTR_LIN===
Used to specify color attributes of one or more horizontal or vertical character lines.

  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.

When sending 15 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. The format of the separate Data Sets (one byte each) is described below.
The length of each line reaches from one end of the screen to the other end. In case that some lines overlap each other, then lines from lastmost data sets will overwrite lines from previous data sets.

===SGB Command 06h - ATTR_DIV===
Used to split the screen into two halfes, and to assign separate color attributes to each half, and to the division line between them.

  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)


===SGB Command 07h - ATTR_CHR===
Used to specify color attributes for separate characters.

  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.

When sending 41 or more data sets, data is continued in further packet(s). Unused bytes at the end of the last packet should be set to zero. Each data set consists of two bits, indicating the palette number for one character.
Depending on the writing style, data sets are written from left to right, or from top to bottom. In either case the function wraps to the next row/column when reaching the end of the screen.

===SGB Command 15h - ATTR_TRN===
Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists of 20x18 color attributes for the gameboy screen. This function does not directly affect display attributes. Instead, one of the defined ATFs may be copied to actual display memory at a later time by using ATTR_SET or PAL_SET functions.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The ATF data is sent by VRAM-Transfer (4 KBytes).

  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used

Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of the 18 character lines of the gameboy window. The two most significant bits of the first byte define the color attribute (0-3) for the first character of the first line, the next two bits the next character, and so on.

===SGB Command 16h - ATTR_SET===
Used to transfer attributes from Attribute File (ATF) to gameboy window.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)

When above Bit 6 is set, the gameboy screen becomes re-enabled after the transfer (in case it has been disabled/frozen by MASK_EN command).
Note: The same functions may be (optionally) also included in PAL_SET commands, as described in the chapter about Color Palette Commands.


== SGB Sound Functions ==

===SGB Command 08h - SOUND===
Used to start/stop internal sound effect, start/stop sound using internal tone data.

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)

See Sound Effect Tables below for a list of available pre-defined effects.

Notes:
# Mute is only active when both bits D2 and D3 are 1.
# When the volume is set for either Sound Effect A or Sound Effect B, mute is turned off.
# When Mute on/off has been executed, the sound fades out/fades in.
# Mute on/off operates on the (BGM) which is reproduced by Sound Effect A, Sound Effect B, and the Super NES APU. A &quot;mute off&quot; flag does not exist by itself. When mute flag is set, volume and pitch of Sound Effect A (port 1) and Sound Effect B (port 2) must be set.

===SGB Command 09h - SOU_TRN===
Used to transfer sound code or data to SNES Audio Processing Unit memory (APU-RAM).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)

The sound code/data is sent by VRAM-Transfer (4 KBytes).

  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used

Possible destinations in APU-RAM are:

  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)

This function may be used to take control of the SNES sound chip, and/or to access the SNES MIDI engine. In either case it requires deeper knowledge of SNES sound programming.

===SGB Sound Effect A/B Tables===
Below lists the digital sound effects that are pre-defined in the SGB/SNES BIOS, and which can be used with the SGB &quot;SOUND&quot; Command.
Effect A and B may be simultaneously reproduced.
The P-column indicates the recommended Pitch value, the V-column indicates the numbers of Voices used. Sound Effect A uses voices 6,7. Sound Effect B uses voices 0,1,4,5. Effects that use less voices will use only the upper voices (eg. 4,5 for Effect B with only two voices).

===Sound Effect A Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2

Sound effect A is used for formanto sounds (percussion sounds).

===Sound Effect B Flag Table===

  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2

Sound effect B is mainly used for looping sounds (sustained sounds).


== SGB System Control Commands ==

===SGB Command 17h - MASK_EN===
Used to mask the gameboy window, among others this can be used to freeze the gameboy screen before transferring data through VRAM (the SNES then keeps displaying the gameboy screen, even though VRAM doesn't contain meaningful display information during the transfer).

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)

Freezing works only if the SNES has stored a picture, ie. if necessary wait one or two frames before freezing (rather than freezing directly after having displayed the picture).
The Cancel Mask function may be also invoked (optionally) by completion of PAL_SET and ATTR_SET commands.

===SGB Command 0Ch - ATRC_EN===
Used to enable/disable Attraction mode, which is enabled by default.

Built-in borders other than the Game Boy frame and the plain black border have a &quot;screen saver&quot; activated by pressing R, L, L, L, L, R or by leaving the controller alone for roughly 7 minutes (tested with 144p Test Suite).
It is speculated that the animation may have interfered with rarely-used SGB features, such as OBJ_TRN or JUMP, and that Attraction Disable disables this animation.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)

===SGB Command 0Dh - TEST_EN===
Used to enable/disable test mode for &quot;SGB-CPU variable clock speed function&quot;. This function is disabled by default.

This command does nothing on some SGB revisions. (SGBv2 confirmed, unknown on others)

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)

Maybe intended to determine whether SNES operates at 50Hz or 60Hz display refresh rate ??? Possibly result can be read-out from joypad register ???

===SGB Command 0Eh - ICON_EN===
Used to enable/disable ICON function. Possibly meant to enable/disable SGB/SNES popup menues which might otherwise activated during gameboy game play. By default all functions are enabled (0).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)

Above Bit 2 will suppress all further packets/commands when set, this might be useful when starting a monochrome game from inside of the SGB-menu of a multi-gamepak which contains a collection of different games.

===SGB Command 0Fh - DATA_SND===
Used to write one or more bytes directly into SNES Work RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.

Unused bytes at the end of the packet should be set to zero, this function is restricted to a single packet, so that not more than 11 bytes can be defined at once.
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh.

===SGB Command 10h - DATA_TRN===
Used to transfer binary code or data directly into SNES RAM.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)

The data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Data

Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly writing to the free 2KBytes at 0:1800h would be a not so good idea ???

===SGB Command 12h - JUMP===
Used to set the SNES program counter and NMI (vblank interrupt) handler to specific addresses.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero

The game ''Space Invaders'' uses this function when selecting &quot;Arcade mode&quot; to execute SNES program code which has been previously transferred from the SGB to the SNES. The SNES CPU is a Ricoh 5A22, which combines a 65C816 core licensed from WDC with a custom memory controller. For more information, see [https://problemkaputt.de/fullsnes.htm &quot;fullsnes&quot; by nocash].

Some notes for intrepid Super NES programmers seeking to use a flash cartridge in a Super Game Boy as a storage server:
* JUMP overwrites the NMI handler even if it is $000000.
* The SGB system software does not appear to use NMIs.
* JUMP can return to SGB system software via a 16-bit RTS. To do this, JML to a location in bank $00 containing byte value $60, such as any of the [[#Stubbed commands|stubbed commands]].
* IRQs and COP and BRK instructions are not useful because their handlers still point into SGB ROM. Use SEI WAI.
* If a program called through JUMP does not intend to return to SGB system software, it can overwrite all Super NES RAM except $0000BB through $0000BD, the NMI vector.
* To enter APU boot ROM, write $FE to $2140. Echo will still be on though.

== SGB Multiplayer Command ==

===SGB Command 11h - MLT_REQ===
Used to request multiplayer mode (ie. input from more than one joypad).
Because this function provides feedback from the SGB/SNES to the Game Boy program, it is also used to detect SGB hardware.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)

In one player mode, the second joypad (if any) is used for the SGB system program. In two player mode, both joypads are used for the game. Because SNES have only two joypad sockets, four player mode requires an external &quot;Multiplayer 5&quot; adapter.

Changing the number of active players ANDs the currently selected player minus one with the number of players in that mode minus one. For example if you go from four players to two players and player 4 was active player 2 will then be active because 3 AND 1 is 1. However, sending the MLT_REQ command will increment the counter several times so results may not be exactly as expected. The most frequent case is going from one player to two-or-four player which will always start with player 1 active.

===Reading Multiple Controllers (Joypads)===
When having enabled multiple controllers by MLT_REQ, data for each joypad can be read out through JOYPAD register (FF00) as follows: First set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you can now read the lower 4bits of FF00 which indicate the joypad ID for the following joypad input:

  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4

Next, read joypad state as normally. When completed, set P14 and P15 back HIGH, this automatically increments the joypad number (or restarts counting once reached the lastmost joypad). Repeat the procedure until you have read-out states for all two (or four) joypads.

If for whatever reason you want to increment the joypad number without reading the joypad state you only need to set P15 to LOW before setting it back to HIGH. Adjusting P14 does not affect whether or not the joypad number will advance, However, if you set P15 to LOW then HIGH then LOW again without bringing both P14 and P15 HIGH at any point, it cancels the increment until P15 is lowered again. There are games, such as Pokémon Yellow, which rely on this cancelling when detecting the SGB.

== SGB Border and OBJ Commands ==

===SGB Command 13h - CHR_TRN===
Used to transfer tile data (characters) to SNES Tile memory in VRAM. This normally used to define BG tiles for the SGB Border (see PCT_TRN), but might be also used to define moveable SNES foreground sprites (see OBJ_TRN).

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)

The tile data is sent by VRAM-Transfer (4 KBytes).

  000-FFF  Bitmap data for 128 Tiles

Each tile occupies 32 bytes (8x8 pixels, 16 colors each).
When intending to transfer more than 128 tiles, call this function twice (once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ Bit seems to have no effect and writes to the same VRAM addresses for both BG and OBJ ???

TODO: explain tile format

===SGB Command 14h - PCT_TRN===
Used to transfer tile map data and palette data to SNES BG Map memory in VRAM to be used for the SGB border. The actual tiles must be separately transferred by using the CHR_TRN function.

  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)

The map data is sent by VRAM-Transfer (4 KBytes).

  000-6FF  BG Map 32x28 Entries of 16bit each (1792 bytes)
  700-7FF  Not used, don't care
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care

Each BG Map Entry consists of a 16bit value as such: &lt;code&gt;VH01 PP00 NNNN NNNN&lt;/code&gt;

  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)

The 32x28 map entries correspond to 256x224 pixels of the Super NES screen. The 20x18 entries in the center of the 32x28 area should be set to a blank (solid color 0) tile as transparent space for the Game Boy window to be displayed inside. Non-transparent border data will cover the Game Boy window (for example, ''Mario's Picross'' does this, as does ''WildSnake'' to a lesser extent).

All borders repeat tiles. Assuming that the blank space for the GB screen is a single tile, as is the letterbox in a widescreen border, a border defining all unique tiles would have to define this many tiles:

* (256*224-160*144)/64+1 = 537 tiles in fullscreen border
* (256*176-160*144)/64+2 = 346 tiles in widescreen border

But the CHR RAM allocated by SGB for border holds only 256 tiles. This means a fullscreen border must repeat at least 281 tiles and a widescreen border at least 90.

===SGB Command 18h - OBJ_TRN===
Used to transfer OBJ attributes to SNES OAM memory. Unlike all other functions with the ending _TRN, this function does not use the usual one-shot 4KBytes VRAM transfer method.
Instead, when enabled (below execute bit set), data is permanently (each frame) read out from the lower character line of the gameboy screen. To suppress garbage on the display, the lower line is masked, and only the upper 20x17 characters of the gameboy window are used - the masking method is unknwon - frozen, black, or recommended to be covered by the SGB border, or else ??? Also, when the function is enabled, &quot;system attract mode is not performed&quot; - whatever that means ???

This command does nothing on some SGB revisions. (SGBv2, SGB2?)

  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)

The recommended method is to &quot;display&quot; gameboy BG tiles F9h..FFh from left to right as first 7 characters of the bottom-most character line of the gameboy screen. As for normal 4KByte VRAM transfers, this area should not be scrolled, should not be overlapped by gameboy OBJs, and the gameboy BGP palette register should be set up properly. By following that method, SNES OAM data can be defined in the 70h bytes of the gameboy BG tile memory at following addresses:

  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)

The format of SNES OAM Entries is:

  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)

The format of SNES OAM MSB Entries is:

  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).


==Undocumented SGB commands==

The following information has been extracted from disassembling a SGBv2 firmware; it should be verified on other SGB revisions.

The SGB firmware explicitly ignores all commands with ID &gt;= $1E. This leaves undocumented commands $19 to $1D inclusive.

===Stubbed commands===

Commands $1A to $1F (inclusive)'s handlers are stubs (only contain a `RTS`). This is interesting, since the command-processing function explicitly ignores commands $1E and $1F.

===SGB command 19h===

The game Donkey Kong '94 appears to send this command, and it appears to set a flag in the SGB's memory. It's not known yet what it does, though.</text>
      <sha1>8hl104tyalqis72ixoqufuqxs3l82q6</sha1>
    </revision>
  </page>
  <page>
    <title>CPU Registers and Flags</title>
    <ns>0</ns>
    <id>52</id>
    <revision>
      <id>156</id>
      <timestamp>2009-06-28T10:55:25Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: ===Registers===    16bit Hi   Lo   Name/Function   AF    A    -    Accumulator &amp; Flags   BC    B    C    BC   DE    D    E    DE   HL    H    L    HL   SP    -    -    Stack Pointer   PC  ...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1875">===Registers===

  16bit Hi   Lo   Name/Function
  AF    A    -    Accumulator &amp; Flags
  BC    B    C    BC
  DE    D    E    DE
  HL    H    L    HL
  SP    -    -    Stack Pointer
  PC    -    -    Program Counter/Pointer

As shown above, most registers can be accessed either as one 16bit register, or as two separate 8bit registers.

===The Flag Register (lower 8bit of AF register)===

  Bit  Name  Set Clr  Expl.
  7    zf    Z   NZ   Zero Flag
  6    n     -   -    Add/Sub-Flag (BCD)
  5    h     -   -    Half Carry Flag (BCD)
  4    cy    C   NC   Carry Flag
  3-0  -     -   -    Not used (always zero)

Conatins the result from the recent instruction which has affected flags.

===The Zero Flag (Z)===
This bit becomes set (1) if the result of an operation has been zero (0). Used for conditional jumps.

===The Carry Flag (C, or Cy)===
Becomes set when the result of an addition became bigger than FFh (8bit) or FFFFh (16bit). Or when the result of a subtraction or Comparison became less than zero (much as for Z80 and 80x86 CPUs, but unlike as for 65XX and ARM CPUs). Also the flag becomes set when a rotate/shift operation has shifted-out a &quot;1&quot;-bit.
Used for conditional jumps, and for instructions such like ADC, SBC, RL, RLA, etc.

===The BCD Flags (N, H)===
These flags are (rarely) used for the DAA instruction only, N Indicates whether the previous instruction has been an addition or subtraction, and H indicates carry for lower 4bits of the result, also for DAA, the C flag must indicate carry for upper 8bits.
After adding/subtracting two BCD numbers, DAA is intended to convert the result into BCD format; BCD numbers are ranged from 00h to 99h rather than 00h to FFh.
Because C and H flags must contain carry-outs for each digit, DAA cannot be used for 16bit operations (which have 4 digits), or for INC/DEC operations (which do not affect C-flag).</text>
      <sha1>22k1xsn2odqzu2e928i2b3z6118lz4a</sha1>
    </revision>
    <revision>
      <id>175</id>
      <parentid>156</parentid>
      <timestamp>2009-06-28T12:58:18Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1909">{{Pandocs|cpuregistersandflags}}

===Registers===

  16bit Hi   Lo   Name/Function
  AF    A    -    Accumulator &amp; Flags
  BC    B    C    BC
  DE    D    E    DE
  HL    H    L    HL
  SP    -    -    Stack Pointer
  PC    -    -    Program Counter/Pointer

As shown above, most registers can be accessed either as one 16bit register, or as two separate 8bit registers.

===The Flag Register (lower 8bit of AF register)===

  Bit  Name  Set Clr  Expl.
  7    zf    Z   NZ   Zero Flag
  6    n     -   -    Add/Sub-Flag (BCD)
  5    h     -   -    Half Carry Flag (BCD)
  4    cy    C   NC   Carry Flag
  3-0  -     -   -    Not used (always zero)

Conatins the result from the recent instruction which has affected flags.

===The Zero Flag (Z)===
This bit becomes set (1) if the result of an operation has been zero (0). Used for conditional jumps.

===The Carry Flag (C, or Cy)===
Becomes set when the result of an addition became bigger than FFh (8bit) or FFFFh (16bit). Or when the result of a subtraction or Comparison became less than zero (much as for Z80 and 80x86 CPUs, but unlike as for 65XX and ARM CPUs). Also the flag becomes set when a rotate/shift operation has shifted-out a &quot;1&quot;-bit.
Used for conditional jumps, and for instructions such like ADC, SBC, RL, RLA, etc.

===The BCD Flags (N, H)===
These flags are (rarely) used for the DAA instruction only, N Indicates whether the previous instruction has been an addition or subtraction, and H indicates carry for lower 4bits of the result, also for DAA, the C flag must indicate carry for upper 8bits.
After adding/subtracting two BCD numbers, DAA is intended to convert the result into BCD format; BCD numbers are ranged from 00h to 99h rather than 00h to FFh.
Because C and H flags must contain carry-outs for each digit, DAA cannot be used for 16bit operations (which have 4 digits), or for INC/DEC operations (which do not affect C-flag).</text>
      <sha1>22c4hwqn55v9bw2q9fok178eymrw25b</sha1>
    </revision>
  </page>
  <page>
    <title>CPU Instruction Set</title>
    <ns>0</ns>
    <id>53</id>
    <revision>
      <id>157</id>
      <timestamp>2009-06-28T10:56:34Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: Tables below specify the mnemonic, opcode bytes, clock cycles, affected flags (ordered as znhc), and explanatation. The timings assume a CPU clock frequency of 4.194304 MHz (or 8.4 MHz for...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6237">Tables below specify the mnemonic, opcode bytes, clock cycles, affected flags (ordered as znhc), and explanatation.
The timings assume a CPU clock frequency of 4.194304 MHz (or 8.4
MHz for CGB in double speed mode), as all gameboy timings are divideable
by 4, many people specify timings and clock frequency divided by 4.

===GMB 8bit-Load commands===

  ld   r,r         xx         4 ---- r=r
  ld   r,n         xx nn      8 ---- r=n
  ld   r,(HL)      xx         8 ---- r=(HL)
  ld   (HL),r      7x         8 ---- (HL)=r
  ld   (HL),n      36 nn     12 ----
  ld   A,(BC)      0A         8 ----
  ld   A,(DE)      1A         8 ----
  ld   A,(nn)      FA        16 ----
  ld   (BC),A      02         8 ----
  ld   (DE),A      12         8 ----
  ld   (nn),A      EA        16 ----
  ld   A,(FF00+n)  F0 nn     12 ---- read from io-port n (memory FF00+n)
  ld   (FF00+n),A  E0 nn     12 ---- write to io-port n (memory FF00+n)
  ld   A,(FF00+C)  F2         8 ---- read from io-port C (memory FF00+C)
  ld   (FF00+C),A  E2         8 ---- write to io-port C (memory FF00+C)
  ldi  (HL),A      22         8 ---- (HL)=A, HL=HL+1
  ldi  A,(HL)      2A         8 ---- A=(HL), HL=HL+1
  ldd  (HL),A      32         8 ---- (HL)=A, HL=HL-1
  ldd  A,(HL)      3A         8 ---- A=(HL), HL=HL-1


===GMB 16bit-Load commands===

  ld   rr,nn       x1 nn nn  12 ---- rr=nn (rr may be BC,DE,HL or SP)
  ld   SP,HL       F9         8 ---- SP=HL
  push rr          x5        16 ---- SP=SP-2  (SP)=rr   (rr may be BC,DE,HL,AF)
  pop  rr          x1        12 (AF) rr=(SP)  SP=SP+2   (rr may be BC,DE,HL,AF)


===GMB 8bit-Arithmetic/logical Commands===

  add  A,r         8x         4 z0hc A=A+r
  add  A,n         C6 nn      8 z0hc A=A+n
  add  A,(HL)      86         8 z0hc A=A+(HL)
  adc  A,r         8x         4 z0hc A=A+r+cy
  adc  A,n         CE nn      8 z0hc A=A+n+cy
  adc  A,(HL)      8E         8 z0hc A=A+(HL)+cy
  sub  r           9x         4 z1hc A=A-r
  sub  n           D6 nn      8 z1hc A=A-n
  sub  (HL)        96         8 z1hc A=A-(HL)
  sbc  A,r         9x         4 z1hc A=A-r-cy
  sbc  A,n         DE nn      8 z1hc A=A-n-cy
  sbc  A,(HL)      9E         8 z1hc A=A-(HL)-cy
  and  r           Ax         4 z010 A=A &amp; r
  and  n           E6 nn      8 z010 A=A &amp; n
  and  (HL)        A6         8 z010 A=A &amp; (HL)
  xor  r           Ax         4 z000
  xor  n           EE nn      8 z000
  xor  (HL)        AE         8 z000
  or   r           Bx         4 z000 A=A | r
  or   n           F6 nn      8 z000 A=A | n
  or   (HL)        B6         8 z000 A=A | (HL)
  cp   r           Bx         4 z1hc compare A-r
  cp   n           FE nn      8 z1hc compare A-n
  cp   (HL)        BE         8 z1hc compare A-(HL)
  inc  r           xx         4 z0h- r=r+1
  inc  (HL)        34        12 z0h- (HL)=(HL)+1
  dec  r           xx         4 z1h- r=r-1
  dec  (HL)        35        12 z1h- (HL)=(HL)-1
  daa              27         4 z-0x decimal adjust akku
  cpl              2F         4 -11- A = A xor FF


===GMB 16bit-Arithmetic/logical Commands===

  add  HL,rr     x9           8 -0hc HL = HL+rr     ;rr may be BC,DE,HL,SP
  inc  rr        x3           8 ---- rr = rr+1      ;rr may be BC,DE,HL,SP
  dec  rr        xB           8 ---- rr = rr-1      ;rr may be BC,DE,HL,SP
  add  SP,dd     E8          16 00hc SP = SP +/- dd ;dd is 8bit signed number
  ld   HL,SP+dd  F8          12 00hc HL = SP +/- dd ;dd is 8bit signed number


===GMB Rotate- und Shift-Commands===

  rlca           07           4 000c rotate akku left
  rla            17           4 000c rotate akku left through carry
  rrca           0F           4 000c rotate akku right
  rra            1F           4 000c rotate akku right through carry
  rlc  r         CB 0x        8 z00c rotate left
  rlc  (HL)      CB 06       16 z00c rotate left
  rl   r         CB 1x        8 z00c rotate left through carry
  rl   (HL)      CB 16       16 z00c rotate left through carry
  rrc  r         CB 0x        8 z00c rotate right
  rrc  (HL)      CB 0E       16 z00c rotate right
  rr   r         CB 1x        8 z00c rotate right through carry
  rr   (HL)      CB 1E       16 z00c rotate right through carry
  sla  r         CB 2x        8 z00c shift left arithmetic (b0=0)
  sla  (HL)      CB 26       16 z00c shift left arithmetic (b0=0)
  swap r         CB 3x        8 z000 exchange low/hi-nibble
  swap (HL)      CB 36       16 z000 exchange low/hi-nibble
  sra  r         CB 2x        8 z00c shift right arithmetic (b7=b7)
  sra  (HL)      CB 2E       16 z00c shift right arithmetic (b7=b7)
  srl  r         CB 3x        8 z00c shift right logical (b7=0)
  srl  (HL)      CB 3E       16 z00c shift right logical (b7=0)


===GMB Singlebit Operation Commands===

  bit  n,r       CB xx        8 z01- test bit n
  bit  n,(HL)    CB xx       12 z01- test bit n
  set  n,r       CB xx        8 ---- set bit n
  set  n,(HL)    CB xx       16 ---- set bit n
  res  n,r       CB xx        8 ---- reset bit n
  res  n,(HL)    CB xx       16 ---- reset bit n


===GMB CPU-Control commands===

  ccf            3F           4 -00c cy=cy xor 1
  scf            37           4 -001 cy=1
  nop            00           4 ---- no operation
  halt           76         N*4 ---- halt until interrupt occurs (low power)
  stop           10 00        ? ---- low power standby mode (VERY low power)
  di             F3           4 ---- disable interrupts, IME=0
  ei             FB           4 ---- enable interrupts, IME=1


===GMB Jump commands===

  jp   nn        C3 nn nn    16 ---- jump to nn, PC=nn
  jp   HL        E9           4 ---- jump to HL, PC=HL
  jp   f,nn      xx nn nn 16;12 ---- conditional jump if nz,z,nc,c
  jr   PC+dd     18 dd       12 ---- relative jump to nn (PC=PC+/-7bit)
  jr   f,PC+dd   xx dd     12;8 ---- conditional relative jump if nz,z,nc,c
  call nn        CD nn nn    24 ---- call to nn, SP=SP-2, (SP)=PC, PC=nn
  call f,nn      xx nn nn 24;12 ---- conditional call if nz,z,nc,c
  ret            C9          16 ---- return, PC=(SP), SP=SP+2
  ret  f         xx        20;8 ---- conditional return if nz,z,nc,c
  reti           D9          16 ---- return and enable interrupts (IME=1)
  rst  n         xx          16 ---- call to 00,08,10,18,20,28,30,38</text>
      <sha1>oucenwlckjyr8mhb23xxe5gxu130cj9</sha1>
    </revision>
    <revision>
      <id>176</id>
      <parentid>157</parentid>
      <timestamp>2009-06-28T12:58:54Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6267">{{Pandocs|cpuinstructionset}}
Tables below specify the mnemonic, opcode bytes, clock cycles, affected flags (ordered as znhc), and explanatation.
The timings assume a CPU clock frequency of 4.194304 MHz (or 8.4
MHz for CGB in double speed mode), as all gameboy timings are divideable
by 4, many people specify timings and clock frequency divided by 4.

===GMB 8bit-Load commands===

  ld   r,r         xx         4 ---- r=r
  ld   r,n         xx nn      8 ---- r=n
  ld   r,(HL)      xx         8 ---- r=(HL)
  ld   (HL),r      7x         8 ---- (HL)=r
  ld   (HL),n      36 nn     12 ----
  ld   A,(BC)      0A         8 ----
  ld   A,(DE)      1A         8 ----
  ld   A,(nn)      FA        16 ----
  ld   (BC),A      02         8 ----
  ld   (DE),A      12         8 ----
  ld   (nn),A      EA        16 ----
  ld   A,(FF00+n)  F0 nn     12 ---- read from io-port n (memory FF00+n)
  ld   (FF00+n),A  E0 nn     12 ---- write to io-port n (memory FF00+n)
  ld   A,(FF00+C)  F2         8 ---- read from io-port C (memory FF00+C)
  ld   (FF00+C),A  E2         8 ---- write to io-port C (memory FF00+C)
  ldi  (HL),A      22         8 ---- (HL)=A, HL=HL+1
  ldi  A,(HL)      2A         8 ---- A=(HL), HL=HL+1
  ldd  (HL),A      32         8 ---- (HL)=A, HL=HL-1
  ldd  A,(HL)      3A         8 ---- A=(HL), HL=HL-1


===GMB 16bit-Load commands===

  ld   rr,nn       x1 nn nn  12 ---- rr=nn (rr may be BC,DE,HL or SP)
  ld   SP,HL       F9         8 ---- SP=HL
  push rr          x5        16 ---- SP=SP-2  (SP)=rr   (rr may be BC,DE,HL,AF)
  pop  rr          x1        12 (AF) rr=(SP)  SP=SP+2   (rr may be BC,DE,HL,AF)


===GMB 8bit-Arithmetic/logical Commands===

  add  A,r         8x         4 z0hc A=A+r
  add  A,n         C6 nn      8 z0hc A=A+n
  add  A,(HL)      86         8 z0hc A=A+(HL)
  adc  A,r         8x         4 z0hc A=A+r+cy
  adc  A,n         CE nn      8 z0hc A=A+n+cy
  adc  A,(HL)      8E         8 z0hc A=A+(HL)+cy
  sub  r           9x         4 z1hc A=A-r
  sub  n           D6 nn      8 z1hc A=A-n
  sub  (HL)        96         8 z1hc A=A-(HL)
  sbc  A,r         9x         4 z1hc A=A-r-cy
  sbc  A,n         DE nn      8 z1hc A=A-n-cy
  sbc  A,(HL)      9E         8 z1hc A=A-(HL)-cy
  and  r           Ax         4 z010 A=A &amp; r
  and  n           E6 nn      8 z010 A=A &amp; n
  and  (HL)        A6         8 z010 A=A &amp; (HL)
  xor  r           Ax         4 z000
  xor  n           EE nn      8 z000
  xor  (HL)        AE         8 z000
  or   r           Bx         4 z000 A=A | r
  or   n           F6 nn      8 z000 A=A | n
  or   (HL)        B6         8 z000 A=A | (HL)
  cp   r           Bx         4 z1hc compare A-r
  cp   n           FE nn      8 z1hc compare A-n
  cp   (HL)        BE         8 z1hc compare A-(HL)
  inc  r           xx         4 z0h- r=r+1
  inc  (HL)        34        12 z0h- (HL)=(HL)+1
  dec  r           xx         4 z1h- r=r-1
  dec  (HL)        35        12 z1h- (HL)=(HL)-1
  daa              27         4 z-0x decimal adjust akku
  cpl              2F         4 -11- A = A xor FF


===GMB 16bit-Arithmetic/logical Commands===

  add  HL,rr     x9           8 -0hc HL = HL+rr     ;rr may be BC,DE,HL,SP
  inc  rr        x3           8 ---- rr = rr+1      ;rr may be BC,DE,HL,SP
  dec  rr        xB           8 ---- rr = rr-1      ;rr may be BC,DE,HL,SP
  add  SP,dd     E8          16 00hc SP = SP +/- dd ;dd is 8bit signed number
  ld   HL,SP+dd  F8          12 00hc HL = SP +/- dd ;dd is 8bit signed number


===GMB Rotate- und Shift-Commands===

  rlca           07           4 000c rotate akku left
  rla            17           4 000c rotate akku left through carry
  rrca           0F           4 000c rotate akku right
  rra            1F           4 000c rotate akku right through carry
  rlc  r         CB 0x        8 z00c rotate left
  rlc  (HL)      CB 06       16 z00c rotate left
  rl   r         CB 1x        8 z00c rotate left through carry
  rl   (HL)      CB 16       16 z00c rotate left through carry
  rrc  r         CB 0x        8 z00c rotate right
  rrc  (HL)      CB 0E       16 z00c rotate right
  rr   r         CB 1x        8 z00c rotate right through carry
  rr   (HL)      CB 1E       16 z00c rotate right through carry
  sla  r         CB 2x        8 z00c shift left arithmetic (b0=0)
  sla  (HL)      CB 26       16 z00c shift left arithmetic (b0=0)
  swap r         CB 3x        8 z000 exchange low/hi-nibble
  swap (HL)      CB 36       16 z000 exchange low/hi-nibble
  sra  r         CB 2x        8 z00c shift right arithmetic (b7=b7)
  sra  (HL)      CB 2E       16 z00c shift right arithmetic (b7=b7)
  srl  r         CB 3x        8 z00c shift right logical (b7=0)
  srl  (HL)      CB 3E       16 z00c shift right logical (b7=0)


===GMB Singlebit Operation Commands===

  bit  n,r       CB xx        8 z01- test bit n
  bit  n,(HL)    CB xx       12 z01- test bit n
  set  n,r       CB xx        8 ---- set bit n
  set  n,(HL)    CB xx       16 ---- set bit n
  res  n,r       CB xx        8 ---- reset bit n
  res  n,(HL)    CB xx       16 ---- reset bit n


===GMB CPU-Control commands===

  ccf            3F           4 -00c cy=cy xor 1
  scf            37           4 -001 cy=1
  nop            00           4 ---- no operation
  halt           76         N*4 ---- halt until interrupt occurs (low power)
  stop           10 00        ? ---- low power standby mode (VERY low power)
  di             F3           4 ---- disable interrupts, IME=0
  ei             FB           4 ---- enable interrupts, IME=1


===GMB Jump commands===

  jp   nn        C3 nn nn    16 ---- jump to nn, PC=nn
  jp   HL        E9           4 ---- jump to HL, PC=HL
  jp   f,nn      xx nn nn 16;12 ---- conditional jump if nz,z,nc,c
  jr   PC+dd     18 dd       12 ---- relative jump to nn (PC=PC+/-7bit)
  jr   f,PC+dd   xx dd     12;8 ---- conditional relative jump if nz,z,nc,c
  call nn        CD nn nn    24 ---- call to nn, SP=SP-2, (SP)=PC, PC=nn
  call f,nn      xx nn nn 24;12 ---- conditional call if nz,z,nc,c
  ret            C9          16 ---- return, PC=(SP), SP=SP+2
  ret  f         xx        20;8 ---- conditional return if nz,z,nc,c
  reti           D9          16 ---- return and enable interrupts (IME=1)
  rst  n         xx          16 ---- call to 00,08,10,18,20,28,30,38</text>
      <sha1>60iu2scfoaabzvlbnv8euepniuk93q0</sha1>
    </revision>
  </page>
  <page>
    <title>CPU Comparison with Z80</title>
    <ns>0</ns>
    <id>54</id>
    <revision>
      <id>158</id>
      <timestamp>2009-06-28T10:58:19Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: ===Comparison with 8080=== Basically, the gameboy CPU works more like an older 8080 CPU rather than like a more powerful Z80 CPU. It is, however, supporting CB-prefixed instructions. Also...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2146">===Comparison with 8080===
Basically, the gameboy CPU works more like an older 8080 CPU rather than like a more powerful Z80 CPU. It is, however, supporting CB-prefixed instructions. Also, all known gameboy assemblers using the more obvious Z80-style syntax, rather than the chaotic 8080-style syntax.

===Comparison with Z80===
Any DD-, ED-, and FD-prefixed instructions are missing, that means no IX-, IY-registers, no block commands, and some other missing commands.
All exchange instructions have been removed (including total absence of second register set), 16bit memory accesses are mostly missing, and 16bit arithmetic functions are heavily cut-down.
The gameboy has no IN/OUT instructions, instead I/O ports are accessed directly by normal LD instructions, or by special LD (FF00+n) opcodes.
The sign and parity/overflow flags have been removed.
The gameboy operates approximately as fast as a 4MHz Z80 (8MHz in CGB double speed mode), execution time of all instructions has been rounded up to a multiple of 4 cycles though.

===Moved, Removed, and Added Opcodes===

  Opcode  Z80             GMB
  ---------------------------------------
  08      EX   AF,AF      LD   (nn),SP
  10      DJNZ PC+dd      STOP
  22      LD   (nn),HL    LDI  (HL),A
  2A      LD   HL,(nn)    LDI  A,(HL)
  32      LD   (nn),A     LDD  (HL),A
  3A      LD   A,(nn)     LDD  A,(HL)
  D3      OUT  (n),A      -
  D9      EXX             RETI
  DB      IN   A,(n)      -
  DD      &lt;IX&gt;            -
  E0      RET  PO         LD   (FF00+n),A
  E2      JP   PO,nn      LD   (FF00+C),A
  E3      EX   (SP),HL    -
  E4      CALL P0,nn      -
  E8      RET  PE         ADD  SP,dd
  EA      JP   PE,nn      LD   (nn),A
  EB      EX   DE,HL      -
  EC      CALL PE,nn      -
  ED      &lt;pref&gt;          -
  F0      RET  P          LD   A,(FF00+n)
  F2      JP   P,nn       LD   A,(FF00+C)
  F4      CALL P,nn       -
  F8      RET  M          LD   HL,SP+dd
  FA      JP   M,nn       LD   A,(nn)
  FC      CALL M,nn       -
  FD      &lt;IY&gt;            -
  CB3X    SLL  r/(HL)     SWAP r/(HL)


== Note: ==
The unused (-) opcodes will lock-up the gameboy CPU when used.</text>
      <sha1>sue4guyth6ecmlomdskmdbj4652qrui</sha1>
    </revision>
    <revision>
      <id>177</id>
      <parentid>158</parentid>
      <timestamp>2009-06-28T12:59:42Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2180">{{Pandocs|cpuComparisonwithz80}}
===Comparison with 8080===
Basically, the gameboy CPU works more like an older 8080 CPU rather than like a more powerful Z80 CPU. It is, however, supporting CB-prefixed instructions. Also, all known gameboy assemblers using the more obvious Z80-style syntax, rather than the chaotic 8080-style syntax.

===Comparison with Z80===
Any DD-, ED-, and FD-prefixed instructions are missing, that means no IX-, IY-registers, no block commands, and some other missing commands.
All exchange instructions have been removed (including total absence of second register set), 16bit memory accesses are mostly missing, and 16bit arithmetic functions are heavily cut-down.
The gameboy has no IN/OUT instructions, instead I/O ports are accessed directly by normal LD instructions, or by special LD (FF00+n) opcodes.
The sign and parity/overflow flags have been removed.
The gameboy operates approximately as fast as a 4MHz Z80 (8MHz in CGB double speed mode), execution time of all instructions has been rounded up to a multiple of 4 cycles though.

===Moved, Removed, and Added Opcodes===

  Opcode  Z80             GMB
  ---------------------------------------
  08      EX   AF,AF      LD   (nn),SP
  10      DJNZ PC+dd      STOP
  22      LD   (nn),HL    LDI  (HL),A
  2A      LD   HL,(nn)    LDI  A,(HL)
  32      LD   (nn),A     LDD  (HL),A
  3A      LD   A,(nn)     LDD  A,(HL)
  D3      OUT  (n),A      -
  D9      EXX             RETI
  DB      IN   A,(n)      -
  DD      &lt;IX&gt;            -
  E0      RET  PO         LD   (FF00+n),A
  E2      JP   PO,nn      LD   (FF00+C),A
  E3      EX   (SP),HL    -
  E4      CALL P0,nn      -
  E8      RET  PE         ADD  SP,dd
  EA      JP   PE,nn      LD   (nn),A
  EB      EX   DE,HL      -
  EC      CALL PE,nn      -
  ED      &lt;pref&gt;          -
  F0      RET  P          LD   A,(FF00+n)
  F2      JP   P,nn       LD   A,(FF00+C)
  F4      CALL P,nn       -
  F8      RET  M          LD   HL,SP+dd
  FA      JP   M,nn       LD   A,(nn)
  FC      CALL M,nn       -
  FD      &lt;IY&gt;            -
  CB3X    SLL  r/(HL)     SWAP r/(HL)


== Note: ==
The unused (-) opcodes will lock-up the gameboy CPU when used.</text>
      <sha1>h3bvwhkob59tzhsxvzj4yzfgboyqu8z</sha1>
    </revision>
    <revision>
      <id>790</id>
      <parentid>177</parentid>
      <timestamp>2018-05-05T22:10:21Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>1/1: IN/OUT, EX *,HL, and JP PE/PO/P/M are differences compared all the way back to 8080. Also fix some grammar, usage, and mechanics that</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2542">{{Pandocs|cpuComparisonwithz80}}
===Comparison with 8080===
The Game Boy CPU has a bit more in common with an older Intel 8080 CPU than the more powerful Zilog Z80 CPU. It is missing a handful of 8080 instructions but does support almost all CB-prefixed instructions. Also, all known Game Boy assemblers use the more obvious Z80-style syntax, rather than the chaotic 8080-style syntax.

Unlike the 8080 and Z80, the Game Boy has no dedicated I/O bus and no IN/OUT opcodes. Instead, I/O ports are accessed directly by normal LD instructions, or by new LD (FF00+n) opcodes.

The sign and parity/overflow flags have been removed, as have the 12 RET, CALL, and JP instructions conditioned on them. So have EX (SP),HL (XTHL) and EX DE,HL (XCHG).

===Comparison with Z80===
All DD- and FD-prefixed instructions are missing. That means no IX- or IY-registers.

In addition to the removed 8080 instructions, the other exchange instructions have been removed (including total absence of second register set).

All ED-prefixed instructions are missing. That means 16bit memory accesses are mostly missing, 16bit arithmetic functions are heavily cut-down, no block commands, and some other missing commands. IN/OUT (C) are replaced with new LD ($FF00+C) opcodes.

The Game Boy operates approximately as fast as a 4 MHz Z80 (8 MHz in CGB double speed mode), with execution time of all instructions having been rounded up to a multiple of 4 cycles.

===Moved, Removed, and Added Opcodes===

  Opcode  Z80             GMB
  ---------------------------------------
  08      EX   AF,AF      LD   (nn),SP
  10      DJNZ PC+dd      STOP
  22      LD   (nn),HL    LDI  (HL),A
  2A      LD   HL,(nn)    LDI  A,(HL)
  32      LD   (nn),A     LDD  (HL),A
  3A      LD   A,(nn)     LDD  A,(HL)
  D3      OUT  (n),A      -
  D9      EXX             RETI
  DB      IN   A,(n)      -
  DD      &lt;IX&gt;            -
  E0      RET  PO         LD   (FF00+n),A
  E2      JP   PO,nn      LD   (FF00+C),A
  E3      EX   (SP),HL    -
  E4      CALL P0,nn      -
  E8      RET  PE         ADD  SP,dd
  EA      JP   PE,nn      LD   (nn),A
  EB      EX   DE,HL      -
  EC      CALL PE,nn      -
  ED      &lt;pref&gt;          -
  F0      RET  P          LD   A,(FF00+n)
  F2      JP   P,nn       LD   A,(FF00+C)
  F4      CALL P,nn       -
  F8      RET  M          LD   HL,SP+dd
  FA      JP   M,nn       LD   A,(nn)
  FC      CALL M,nn       -
  FD      &lt;IY&gt;            -
  CB3X    SLL  r/(HL)     SWAP r/(HL)

Note: The unused (-) opcodes will lock up the Game Boy CPU when used.</text>
      <sha1>iklav1tex8ghlxgqzp4noxmdlxggwyy</sha1>
    </revision>
    <revision>
      <id>791</id>
      <parentid>790</parentid>
      <timestamp>2018-05-05T22:15:35Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <minor/>
      <comment>Remaining changes, not included before to reduce diff desync</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2598">{{Pandocs|cpuComparisonwithz80}}
===Comparison with 8080===
The Game Boy CPU has a bit more in common with an older Intel 8080 CPU than the more powerful Zilog Z80 CPU. It is missing a handful of 8080 instructions but does support JR and almost all CB-prefixed instructions. Also, all known Game Boy assemblers use the more obvious Z80-style syntax, rather than the chaotic 8080-style syntax.

Unlike the 8080 and Z80, the Game Boy has no dedicated I/O bus and no IN/OUT opcodes. Instead, I/O ports are accessed directly by normal LD instructions, or by new LD (FF00+n) opcodes.

The sign and parity/overflow flags have been removed, as have the 12 RET, CALL, and JP instructions conditioned on them. So have EX (SP),HL (XTHL) and EX DE,HL (XCHG).

===Comparison with Z80===
In addition to the removed 8080 instructions, the other exchange instructions have been removed (including total absence of second register set).

All DD- and FD-prefixed instructions are missing. That means no IX- or IY-registers.

All ED-prefixed instructions are missing. That means 16bit memory accesses are mostly missing, 16bit arithmetic functions are heavily cut-down, and some other missing commands. IN/OUT (C) are replaced with new LD ($FF00+C) opcodes. Block commands are gone, but autoincrementing HL accesses are added.

The Game Boy operates approximately as fast as a 4 MHz Z80 (8 MHz in CGB double speed mode), with execution time of all instructions having been rounded up to a multiple of 4 cycles.

===Moved, Removed, and Added Opcodes===

  Opcode  Z80             GMB
  ---------------------------------------
  08      EX   AF,AF      LD   (nn),SP
  10      DJNZ PC+dd      STOP
  22      LD   (nn),HL    LDI  (HL),A
  2A      LD   HL,(nn)    LDI  A,(HL)
  32      LD   (nn),A     LDD  (HL),A
  3A      LD   A,(nn)     LDD  A,(HL)
  D3      OUT  (n),A      -
  D9      EXX             RETI
  DB      IN   A,(n)      -
  DD      &lt;IX&gt;            -
  E0      RET  PO         LD   (FF00+n),A
  E2      JP   PO,nn      LD   (FF00+C),A
  E3      EX   (SP),HL    -
  E4      CALL P0,nn      -
  E8      RET  PE         ADD  SP,dd
  EA      JP   PE,nn      LD   (nn),A
  EB      EX   DE,HL      -
  EC      CALL PE,nn      -
  ED      &lt;pref&gt;          -
  F0      RET  P          LD   A,(FF00+n)
  F2      JP   P,nn       LD   A,(FF00+C)
  F4      CALL P,nn       -
  F8      RET  M          LD   HL,SP+dd
  FA      JP   M,nn       LD   A,(nn)
  FC      CALL M,nn       -
  FD      &lt;IY&gt;            -
  CB3X    SLL  r/(HL)     SWAP r/(HL)

Note: The unused (-) opcodes will lock up the Game Boy CPU when used.</text>
      <sha1>p6tbf2ty77tsjfh03vuj0w3hyi42p0e</sha1>
    </revision>
  </page>
  <page>
    <title>The Cartridge Header</title>
    <ns>0</ns>
    <id>55</id>
    <revision>
      <id>159</id>
      <timestamp>2009-06-28T10:59:45Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: An internal information area is located at 0100-014F in each cartridge. It contains the following values:  ===0100-0103 - Entry Point=== After displaying the Nintendo Logo, the built-in bo...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5559">An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 13h  MBC3+RAM+BATTERY
  01h  MBC1                     15h  MBC4
  02h  MBC1+RAM                 16h  MBC4+RAM
  03h  MBC1+RAM+BATTERY         17h  MBC4+RAM+BATTERY
  05h  MBC2                     19h  MBC5
  06h  MBC2+BATTERY             1Ah  MBC5+RAM
  08h  ROM+RAM                  1Bh  MBC5+RAM+BATTERY
  09h  ROM+RAM+BATTERY          1Ch  MBC5+RUMBLE
  0Bh  MMM01                    1Dh  MBC5+RUMBLE+RAM
  0Ch  MMM01+RAM                1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Dh  MMM01+RAM+BATTERY        FCh  POCKET CAMERA
  0Fh  MBC3+TIMER+BATTERY       FDh  BANDAI TAMA5
  10h  MBC3+TIMER+RAM+BATTERY   FEh  HuC3
  11h  MBC3                     FFh  HuC1+RAM+BATTERY
  12h  MBC3+RAM


===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>80o0qits3oie4z1bc9sefssrl06crx0</sha1>
    </revision>
    <revision>
      <id>178</id>
      <parentid>159</parentid>
      <timestamp>2009-06-28T13:00:29Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5590">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 13h  MBC3+RAM+BATTERY
  01h  MBC1                     15h  MBC4
  02h  MBC1+RAM                 16h  MBC4+RAM
  03h  MBC1+RAM+BATTERY         17h  MBC4+RAM+BATTERY
  05h  MBC2                     19h  MBC5
  06h  MBC2+BATTERY             1Ah  MBC5+RAM
  08h  ROM+RAM                  1Bh  MBC5+RAM+BATTERY
  09h  ROM+RAM+BATTERY          1Ch  MBC5+RUMBLE
  0Bh  MMM01                    1Dh  MBC5+RUMBLE+RAM
  0Ch  MMM01+RAM                1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Dh  MMM01+RAM+BATTERY        FCh  POCKET CAMERA
  0Fh  MBC3+TIMER+BATTERY       FDh  BANDAI TAMA5
  10h  MBC3+TIMER+RAM+BATTERY   FEh  HuC3
  11h  MBC3                     FFh  HuC1+RAM+BATTERY
  12h  MBC3+RAM


===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>sq6l8pfacwznjoym82omwz4kxl0pkb7</sha1>
    </revision>
    <revision>
      <id>598</id>
      <parentid>178</parentid>
      <timestamp>2015-06-12T07:10:33Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <comment>/* 0149 - RAM Size */ GB Wars 3 saves entires maps in RAM</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5636">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 13h  MBC3+RAM+BATTERY
  01h  MBC1                     15h  MBC4
  02h  MBC1+RAM                 16h  MBC4+RAM
  03h  MBC1+RAM+BATTERY         17h  MBC4+RAM+BATTERY
  05h  MBC2                     19h  MBC5
  06h  MBC2+BATTERY             1Ah  MBC5+RAM
  08h  ROM+RAM                  1Bh  MBC5+RAM+BATTERY
  09h  ROM+RAM+BATTERY          1Ch  MBC5+RUMBLE
  0Bh  MMM01                    1Dh  MBC5+RUMBLE+RAM
  0Ch  MMM01+RAM                1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Dh  MMM01+RAM+BATTERY        FCh  POCKET CAMERA
  0Fh  MBC3+TIMER+BATTERY       FDh  BANDAI TAMA5
  10h  MBC3+TIMER+RAM+BATTERY   FEh  HuC3
  11h  MBC3                     FFh  HuC1+RAM+BATTERY
  12h  MBC3+RAM


===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>swzd3gqe4lj5jsc55vxqj8tz8dq8phh</sha1>
    </revision>
    <revision>
      <id>599</id>
      <parentid>598</parentid>
      <timestamp>2015-06-12T07:43:30Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <comment>/* 0149 - RAM Size */ I think nothing is missing now ?</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5680">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 13h  MBC3+RAM+BATTERY
  01h  MBC1                     15h  MBC4
  02h  MBC1+RAM                 16h  MBC4+RAM
  03h  MBC1+RAM+BATTERY         17h  MBC4+RAM+BATTERY
  05h  MBC2                     19h  MBC5
  06h  MBC2+BATTERY             1Ah  MBC5+RAM
  08h  ROM+RAM                  1Bh  MBC5+RAM+BATTERY
  09h  ROM+RAM+BATTERY          1Ch  MBC5+RUMBLE
  0Bh  MMM01                    1Dh  MBC5+RUMBLE+RAM
  0Ch  MMM01+RAM                1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Dh  MMM01+RAM+BATTERY        FCh  POCKET CAMERA
  0Fh  MBC3+TIMER+BATTERY       FDh  BANDAI TAMA5
  10h  MBC3+TIMER+RAM+BATTERY   FEh  HuC3
  11h  MBC3                     FFh  HuC1+RAM+BATTERY
  12h  MBC3+RAM


===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>6b8iq54rhtt7vqh2nwrcbc4dzsqbe48</sha1>
    </revision>
    <revision>
      <id>623</id>
      <parentid>599</parentid>
      <timestamp>2016-04-23T20:03:29Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <comment>/* 0147 - Cartridge Type */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5745">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 15h  MBC4
  01h  MBC1                     16h  MBC4+RAM
  02h  MBC1+RAM                 17h  MBC4+RAM+BATTERY
  03h  MBC1+RAM+BATTERY         19h  MBC5
  05h  MBC2                     1Ah  MBC5+RAM
  06h  MBC2+BATTERY             1Bh  MBC5+RAM+BATTERY
  08h  ROM+RAM                  1Ch  MBC5+RUMBLE
  09h  ROM+RAM+BATTERY          1Dh  MBC5+RUMBLE+RAM
  0Bh  MMM01                    1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Ch  MMM01+RAM                20h  MBC6
  0Dh  MMM01+RAM+BATTERY        22h  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  0Fh  MBC3+TIMER+BATTERY
  10h  MBC3+TIMER+RAM+BATTERY   FCh  POCKET CAMERA
  11h  MBC3                     FDh  BANDAI TAMA5
  12h  MBC3+RAM                 FEh  HuC3
  13h  MBC3+RAM+BATTERY         FFh  HuC1+RAM+BATTERY

===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>p8i1hosmthn7cbu4shn8cyrc0kwzgoj</sha1>
    </revision>
    <revision>
      <id>705</id>
      <parentid>623</parentid>
      <timestamp>2016-09-12T22:44:53Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5745">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 15h  MBC4
  01h  MBC1                     16h  MBC4+RAM
  02h  MBC1+RAM                 17h  MBC4+RAM+BATTERY
  03h  MBC1+RAM+BATTERY         19h  MBC5
  05h  MBC2                     1Ah  MBC5+RAM
  06h  MBC2+BATTERY             1Bh  MBC5+RAM+BATTERY
  08h  ROM+RAM                  1Ch  MBC5+RUMBLE
  09h  ROM+RAM+BATTERY          1Dh  MBC5+RUMBLE+RAM
  0Bh  MMM01                    1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Ch  MMM01+RAM                20h  MBC6
  0Dh  MMM01+RAM+BATTERY        22h  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  0Fh  MBC3+TIMER+BATTERY
  10h  MBC3+TIMER+RAM+BATTERY   FCh  POCKET CAMERA
  11h  MBC3                     FDh  BANDAI TAMA5
  12h  MBC3+RAM                 FEh  HuC3
  13h  MBC3+RAM+BATTERY         FFh  HuC1+RAM+BATTERY

===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in Japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>9r04javimgrv9k2kgam01lpdl2zcy92</sha1>
    </revision>
    <revision>
      <id>706</id>
      <parentid>705</parentid>
      <timestamp>2016-10-13T20:22:11Z</timestamp>
      <contributor>
        <username>Emma</username>
        <id>66</id>
      </contributor>
      <comment>8 MiB ROM Size, for completeness. Densha de Go! 2 is the only such cartridge, it seems.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5774">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 15h  MBC4
  01h  MBC1                     16h  MBC4+RAM
  02h  MBC1+RAM                 17h  MBC4+RAM+BATTERY
  03h  MBC1+RAM+BATTERY         19h  MBC5
  05h  MBC2                     1Ah  MBC5+RAM
  06h  MBC2+BATTERY             1Bh  MBC5+RAM+BATTERY
  08h  ROM+RAM                  1Ch  MBC5+RUMBLE
  09h  ROM+RAM+BATTERY          1Dh  MBC5+RUMBLE+RAM
  0Bh  MMM01                    1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Ch  MMM01+RAM                20h  MBC6
  0Dh  MMM01+RAM+BATTERY        22h  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  0Fh  MBC3+TIMER+BATTERY
  10h  MBC3+TIMER+RAM+BATTERY   FCh  POCKET CAMERA
  11h  MBC3                     FDh  BANDAI TAMA5
  12h  MBC3+RAM                 FEh  HuC3
  13h  MBC3+RAM+BATTERY         FFh  HuC1+RAM+BATTERY

===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  08h -   8MByte (512 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in Japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>kmwh2dfj8c9ffc4h80v17r5ryq4vfa4</sha1>
    </revision>
    <revision>
      <id>744</id>
      <parentid>706</parentid>
      <timestamp>2017-05-09T16:28:00Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* 0144-0145 - New Licensee Code */ Add sample codes</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7273">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

Sample licensee codes :
{| class=&quot;wikitable&quot;
|-
| '''00''' 
| none
| '''01''' 
| nintendo
| '''08''' 
| capcom
|-
| '''13''' 
| electronic arts
| '''18''' 
| hudsonsoft
| '''19''' 
| b-ai
|-
| '''20''' 
| kss
| '''22''' 
| pow
| '''24''' 
| pcm complete
|-
| '''25''' 
| san-x
| '''28''' 
| kemco japan
| '''29''' 
| seta
|-
| '''30''' 
| viacom
| '''31''' 
| nintendo
| '''32''' 
| bandia
|-
| '''33''' 
| ocean/acclaim
| '''34''' 
| konami
| '''35''' 
| hector
|-
| '''37''' 
| taito
| '''38''' 
| hudson
| '''39''' 
| banpresto
|-
| '''41''' 
| ubi soft
| '''42''' 
| atlus
| '''44''' 
| malibu
|-
| '''46''' 
| angel
| '''47''' 
| pullet-proof
| '''49''' 
| irem
|-
| '''50''' 
| absolute
| '''51''' 
| acclaim
| '''52''' 
| activision
|-
| '''53''' 
| american sammy
| '''54''' 
| konami
| '''55''' 
| hi tech entertainment
|-
| '''56''' 
| ljn
| '''57''' 
| matchbox
| '''58''' 
| mattel
|-
| '''59''' 
| milton bradley
| '''60''' 
| titus
| '''61''' 
| virgin
|-
| '''64''' 
| lucasarts
| '''67''' 
| ocean
| '''69''' 
| electronic arts
|-
| '''70''' 
| infogrames
| '''71''' 
| interplay
| '''72''' 
| broderbund
|-
| '''73''' 
| sculptured
| '''75''' 
| sci
| '''78''' 
| t*hq
|-
| '''79''' 
| accolade
| '''80''' 
| misawa
| '''83''' 
| lozc
|-
| '''86''' 
| tokuma shoten i*
| '''87''' 
| tsukuda ori*
| '''91''' 
| chun soft
|-
| '''92''' 
| video system
| '''93''' 
| ocean/acclaim
| '''95''' 
| varie
|-
| '''96''' 
| yonezawa/s'pal
| '''97''' 
| kaneko
| '''99''' 
| pack in soft
|}

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 15h  MBC4
  01h  MBC1                     16h  MBC4+RAM
  02h  MBC1+RAM                 17h  MBC4+RAM+BATTERY
  03h  MBC1+RAM+BATTERY         19h  MBC5
  05h  MBC2                     1Ah  MBC5+RAM
  06h  MBC2+BATTERY             1Bh  MBC5+RAM+BATTERY
  08h  ROM+RAM                  1Ch  MBC5+RUMBLE
  09h  ROM+RAM+BATTERY          1Dh  MBC5+RUMBLE+RAM
  0Bh  MMM01                    1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Ch  MMM01+RAM                20h  MBC6
  0Dh  MMM01+RAM+BATTERY        22h  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  0Fh  MBC3+TIMER+BATTERY
  10h  MBC3+TIMER+RAM+BATTERY   FCh  POCKET CAMERA
  11h  MBC3                     FDh  BANDAI TAMA5
  12h  MBC3+RAM                 FEh  HuC3
  13h  MBC3+RAM+BATTERY         FFh  HuC1+RAM+BATTERY

===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  08h -   8MByte (512 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in Japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>lz62hozcfzxr6x3kqcf4ikzzs4vzw1u</sha1>
    </revision>
    <revision>
      <id>745</id>
      <parentid>744</parentid>
      <timestamp>2017-05-09T16:30:14Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* 014B - Old Licensee Code */ Add link to SephirothBCH's document with licensee codes</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7354">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

Sample licensee codes :
{| class=&quot;wikitable&quot;
|-
| '''00''' 
| none
| '''01''' 
| nintendo
| '''08''' 
| capcom
|-
| '''13''' 
| electronic arts
| '''18''' 
| hudsonsoft
| '''19''' 
| b-ai
|-
| '''20''' 
| kss
| '''22''' 
| pow
| '''24''' 
| pcm complete
|-
| '''25''' 
| san-x
| '''28''' 
| kemco japan
| '''29''' 
| seta
|-
| '''30''' 
| viacom
| '''31''' 
| nintendo
| '''32''' 
| bandia
|-
| '''33''' 
| ocean/acclaim
| '''34''' 
| konami
| '''35''' 
| hector
|-
| '''37''' 
| taito
| '''38''' 
| hudson
| '''39''' 
| banpresto
|-
| '''41''' 
| ubi soft
| '''42''' 
| atlus
| '''44''' 
| malibu
|-
| '''46''' 
| angel
| '''47''' 
| pullet-proof
| '''49''' 
| irem
|-
| '''50''' 
| absolute
| '''51''' 
| acclaim
| '''52''' 
| activision
|-
| '''53''' 
| american sammy
| '''54''' 
| konami
| '''55''' 
| hi tech entertainment
|-
| '''56''' 
| ljn
| '''57''' 
| matchbox
| '''58''' 
| mattel
|-
| '''59''' 
| milton bradley
| '''60''' 
| titus
| '''61''' 
| virgin
|-
| '''64''' 
| lucasarts
| '''67''' 
| ocean
| '''69''' 
| electronic arts
|-
| '''70''' 
| infogrames
| '''71''' 
| interplay
| '''72''' 
| broderbund
|-
| '''73''' 
| sculptured
| '''75''' 
| sci
| '''78''' 
| t*hq
|-
| '''79''' 
| accolade
| '''80''' 
| misawa
| '''83''' 
| lozc
|-
| '''86''' 
| tokuma shoten i*
| '''87''' 
| tsukuda ori*
| '''91''' 
| chun soft
|-
| '''92''' 
| video system
| '''93''' 
| ocean/acclaim
| '''95''' 
| varie
|-
| '''96''' 
| yonezawa/s'pal
| '''97''' 
| kaneko
| '''99''' 
| pack in soft
|}

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 15h  MBC4
  01h  MBC1                     16h  MBC4+RAM
  02h  MBC1+RAM                 17h  MBC4+RAM+BATTERY
  03h  MBC1+RAM+BATTERY         19h  MBC5
  05h  MBC2                     1Ah  MBC5+RAM
  06h  MBC2+BATTERY             1Bh  MBC5+RAM+BATTERY
  08h  ROM+RAM                  1Ch  MBC5+RUMBLE
  09h  ROM+RAM+BATTERY          1Dh  MBC5+RUMBLE+RAM
  0Bh  MMM01                    1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Ch  MMM01+RAM                20h  MBC6
  0Dh  MMM01+RAM+BATTERY        22h  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  0Fh  MBC3+TIMER+BATTERY
  10h  MBC3+TIMER+RAM+BATTERY   FCh  POCKET CAMERA
  11h  MBC3                     FDh  BANDAI TAMA5
  12h  MBC3+RAM                 FEh  HuC3
  13h  MBC3+RAM+BATTERY         FFh  HuC1+RAM+BATTERY

===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  08h -   8MByte (512 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in Japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)
A list of licensee codes can be found [[Gameboy_ROM_Header_Info#Licensee|here]].

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>cy2xbz9y2lj4tfw7w6tyw7rld01qzyr</sha1>
    </revision>
    <revision>
      <id>755</id>
      <parentid>745</parentid>
      <timestamp>2017-05-18T21:35:22Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <comment>/* 0147 - Cartridge Type */ Removing the MBC4. No answer on the talk page, and I'm pretty darn sure there is no such controller</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7267">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

Sample licensee codes :
{| class=&quot;wikitable&quot;
|-
| '''00''' 
| none
| '''01''' 
| nintendo
| '''08''' 
| capcom
|-
| '''13''' 
| electronic arts
| '''18''' 
| hudsonsoft
| '''19''' 
| b-ai
|-
| '''20''' 
| kss
| '''22''' 
| pow
| '''24''' 
| pcm complete
|-
| '''25''' 
| san-x
| '''28''' 
| kemco japan
| '''29''' 
| seta
|-
| '''30''' 
| viacom
| '''31''' 
| nintendo
| '''32''' 
| bandia
|-
| '''33''' 
| ocean/acclaim
| '''34''' 
| konami
| '''35''' 
| hector
|-
| '''37''' 
| taito
| '''38''' 
| hudson
| '''39''' 
| banpresto
|-
| '''41''' 
| ubi soft
| '''42''' 
| atlus
| '''44''' 
| malibu
|-
| '''46''' 
| angel
| '''47''' 
| pullet-proof
| '''49''' 
| irem
|-
| '''50''' 
| absolute
| '''51''' 
| acclaim
| '''52''' 
| activision
|-
| '''53''' 
| american sammy
| '''54''' 
| konami
| '''55''' 
| hi tech entertainment
|-
| '''56''' 
| ljn
| '''57''' 
| matchbox
| '''58''' 
| mattel
|-
| '''59''' 
| milton bradley
| '''60''' 
| titus
| '''61''' 
| virgin
|-
| '''64''' 
| lucasarts
| '''67''' 
| ocean
| '''69''' 
| electronic arts
|-
| '''70''' 
| infogrames
| '''71''' 
| interplay
| '''72''' 
| broderbund
|-
| '''73''' 
| sculptured
| '''75''' 
| sci
| '''78''' 
| t*hq
|-
| '''79''' 
| accolade
| '''80''' 
| misawa
| '''83''' 
| lozc
|-
| '''86''' 
| tokuma shoten i*
| '''87''' 
| tsukuda ori*
| '''91''' 
| chun soft
|-
| '''92''' 
| video system
| '''93''' 
| ocean/acclaim
| '''95''' 
| varie
|-
| '''96''' 
| yonezawa/s'pal
| '''97''' 
| kaneko
| '''99''' 
| pack in soft
|}

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 19h  MBC5
  01h  MBC1                     1Ah  MBC5+RAM
  02h  MBC1+RAM                 1Bh  MBC5+RAM+BATTERY
  03h  MBC1+RAM+BATTERY         1Ch  MBC5+RUMBLE
  05h  MBC2                     1Dh  MBC5+RUMBLE+RAM
  06h  MBC2+BATTERY             1Eh  MBC5+RUMBLE+RAM+BATTERY
  08h  ROM+RAM                  20h  MBC6
  09h  ROM+RAM+BATTERY          22h  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  0Bh  MMM01
  0Ch  MMM01+RAM
  0Dh  MMM01+RAM+BATTERY
  0Fh  MBC3+TIMER+BATTERY
  10h  MBC3+TIMER+RAM+BATTERY   FCh  POCKET CAMERA
  11h  MBC3                     FDh  BANDAI TAMA5
  12h  MBC3+RAM                 FEh  HuC3
  13h  MBC3+RAM+BATTERY         FFh  HuC1+RAM+BATTERY

===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  08h -   8MByte (512 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in Japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)
A list of licensee codes can be found [[Gameboy_ROM_Header_Info#Licensee|here]].

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>99yoqpfvv59dlhnn0ty32d124gden6z</sha1>
    </revision>
    <revision>
      <id>757</id>
      <parentid>755</parentid>
      <timestamp>2017-05-18T21:55:14Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <comment>/* 0144-0145 - New Licensee Code */ A4 is specific to the Yu-Gi-Oh! branch of Konami, added caps, fixed a few typos</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7320">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

Sample licensee codes :
{| class=&quot;wikitable&quot;
|-
| '''00''' 
| none
| '''01''' 
| Nintendo R&amp;D1
| '''08''' 
| Capcom
|-
| '''13''' 
| Electronic Arts
| '''18''' 
| Hudson Soft
| '''19''' 
| b-ai
|-
| '''20''' 
| kss
| '''22''' 
| pow
| '''24''' 
| PCM Complete
|-
| '''25''' 
| san-x
| '''28''' 
| Kemco Japan
| '''29''' 
| seta
|-
| '''30''' 
| Viacom
| '''31''' 
| Nintendo
| '''32''' 
| Bandai
|-
| '''33''' 
| Ocean/Acclaim
| '''34''' 
| Konami
| '''35''' 
| Hector
|-
| '''37''' 
| Taito
| '''38''' 
| Hudson
| '''39''' 
| Banpresto
|-
| '''41''' 
| Ubi Soft
| '''42''' 
| Atlus
| '''44''' 
| Malibu
|-
| '''46''' 
| angel
| '''47''' 
| Bullet-Proof
| '''49''' 
| irem
|-
| '''50''' 
| Absolute
| '''51''' 
| Acclaim
| '''52''' 
| Activision
|-
| '''53''' 
| American sammy
| '''54''' 
| Konami
| '''55''' 
| Hi tech entertainment
|-
| '''56''' 
| LJN
| '''57''' 
| Matchbox
| '''58''' 
| Mattel
|-
| '''59''' 
| Milton Bradley
| '''60''' 
| Titus
| '''61''' 
| Virgin
|-
| '''64''' 
| LucasArts
| '''67''' 
| Ocean
| '''69''' 
| Electronic Arts
|-
| '''70''' 
| Infogrames
| '''71''' 
| Interplay
| '''72''' 
| Broderbund
|-
| '''73''' 
| sculptured
| '''75''' 
| sci
| '''78''' 
| t*hq
|-
| '''79''' 
| Accolade
| '''80''' 
| misawa
| '''83''' 
| lozc
|-
| '''86''' 
| tokuma shoten i*
| '''87''' 
| tsukuda ori*
| '''91''' 
| Chunsoft
|-
| '''92''' 
| Video system
| '''93''' 
| Ocean/Acclaim
| '''95''' 
| Varie
|-
| '''96''' 
| Yonezawa/s'pal
| '''97''' 
| Kaneko
| '''99''' 
| Pack in soft
|-
| '''A4''' 
| Konami (Yu-Gi-Oh!)
| 
| 
| 
| 
|}

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 19h  MBC5
  01h  MBC1                     1Ah  MBC5+RAM
  02h  MBC1+RAM                 1Bh  MBC5+RAM+BATTERY
  03h  MBC1+RAM+BATTERY         1Ch  MBC5+RUMBLE
  05h  MBC2                     1Dh  MBC5+RUMBLE+RAM
  06h  MBC2+BATTERY             1Eh  MBC5+RUMBLE+RAM+BATTERY
  08h  ROM+RAM                  20h  MBC6
  09h  ROM+RAM+BATTERY          22h  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  0Bh  MMM01
  0Ch  MMM01+RAM
  0Dh  MMM01+RAM+BATTERY
  0Fh  MBC3+TIMER+BATTERY
  10h  MBC3+TIMER+RAM+BATTERY   FCh  POCKET CAMERA
  11h  MBC3                     FDh  BANDAI TAMA5
  12h  MBC3+RAM                 FEh  HuC3
  13h  MBC3+RAM+BATTERY         FFh  HuC1+RAM+BATTERY

===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  08h -   8MByte (512 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in Japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)
A list of licensee codes can be found [[Gameboy_ROM_Header_Info#Licensee|here]].

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>l62ey5esxbuee8g0ktzlvfauium3liw</sha1>
    </revision>
    <revision>
      <id>758</id>
      <parentid>757</parentid>
      <timestamp>2017-05-18T21:56:20Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <comment>/* 0144-0145 - New Licensee Code */ Forgot that one</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7319">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The gameboys boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

Sample licensee codes :
{| class=&quot;wikitable&quot;
|-
| '''00''' 
| none
| '''01''' 
| Nintendo R&amp;D1
| '''08''' 
| Capcom
|-
| '''13''' 
| Electronic Arts
| '''18''' 
| Hudson Soft
| '''19''' 
| b-ai
|-
| '''20''' 
| kss
| '''22''' 
| pow
| '''24''' 
| PCM Complete
|-
| '''25''' 
| san-x
| '''28''' 
| Kemco Japan
| '''29''' 
| seta
|-
| '''30''' 
| Viacom
| '''31''' 
| Nintendo
| '''32''' 
| Bandai
|-
| '''33''' 
| Ocean/Acclaim
| '''34''' 
| Konami
| '''35''' 
| Hector
|-
| '''37''' 
| Taito
| '''38''' 
| Hudson
| '''39''' 
| Banpresto
|-
| '''41''' 
| Ubi Soft
| '''42''' 
| Atlus
| '''44''' 
| Malibu
|-
| '''46''' 
| angel
| '''47''' 
| Bullet-Proof
| '''49''' 
| irem
|-
| '''50''' 
| Absolute
| '''51''' 
| Acclaim
| '''52''' 
| Activision
|-
| '''53''' 
| American sammy
| '''54''' 
| Konami
| '''55''' 
| Hi tech entertainment
|-
| '''56''' 
| LJN
| '''57''' 
| Matchbox
| '''58''' 
| Mattel
|-
| '''59''' 
| Milton Bradley
| '''60''' 
| Titus
| '''61''' 
| Virgin
|-
| '''64''' 
| LucasArts
| '''67''' 
| Ocean
| '''69''' 
| Electronic Arts
|-
| '''70''' 
| Infogrames
| '''71''' 
| Interplay
| '''72''' 
| Broderbund
|-
| '''73''' 
| sculptured
| '''75''' 
| sci
| '''78''' 
| THQ
|-
| '''79''' 
| Accolade
| '''80''' 
| misawa
| '''83''' 
| lozc
|-
| '''86''' 
| tokuma shoten i*
| '''87''' 
| tsukuda ori*
| '''91''' 
| Chunsoft
|-
| '''92''' 
| Video system
| '''93''' 
| Ocean/Acclaim
| '''95''' 
| Varie
|-
| '''96''' 
| Yonezawa/s'pal
| '''97''' 
| Kaneko
| '''99''' 
| Pack in soft
|-
| '''A4''' 
| Konami (Yu-Gi-Oh!)
| 
| 
| 
| 
|}

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 19h  MBC5
  01h  MBC1                     1Ah  MBC5+RAM
  02h  MBC1+RAM                 1Bh  MBC5+RAM+BATTERY
  03h  MBC1+RAM+BATTERY         1Ch  MBC5+RUMBLE
  05h  MBC2                     1Dh  MBC5+RUMBLE+RAM
  06h  MBC2+BATTERY             1Eh  MBC5+RUMBLE+RAM+BATTERY
  08h  ROM+RAM                  20h  MBC6
  09h  ROM+RAM+BATTERY          22h  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  0Bh  MMM01
  0Ch  MMM01+RAM
  0Dh  MMM01+RAM+BATTERY
  0Fh  MBC3+TIMER+BATTERY
  10h  MBC3+TIMER+RAM+BATTERY   FCh  POCKET CAMERA
  11h  MBC3                     FDh  BANDAI TAMA5
  12h  MBC3+RAM                 FEh  HuC3
  13h  MBC3+RAM+BATTERY         FFh  HuC1+RAM+BATTERY

===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  08h -   8MByte (512 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in Japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)
A list of licensee codes can be found [[Gameboy_ROM_Header_Info#Licensee|here]].

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>jg66kidhhsuq4fvv0wkh7b6ivk6qsoi</sha1>
    </revision>
    <revision>
      <id>786</id>
      <parentid>758</parentid>
      <timestamp>2018-01-30T18:02:42Z</timestamp>
      <contributor>
        <username>Mantidactyle</username>
        <id>41</id>
      </contributor>
      <minor/>
      <comment>/* 0104-0133 - Nintendo Logo */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7321">{{Pandocs|thecartridgeheader}}
An internal information area is located at 0100-014F in
each cartridge. It contains the following values:

===0100-0103 - Entry Point===
After displaying the Nintendo Logo, the built-in boot procedure jumps to this address (100h), which should then jump to the actual main program in the cartridge. Usually this 4 byte area contains a NOP instruction, followed by a JP 0150h instruction. But not always.

===0104-0133 - Nintendo Logo===
These bytes define the bitmap of the Nintendo logo that is displayed when the gameboy gets turned on. The hexdump of this bitmap is:

  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E

The Game Boy's boot procedure verifies the content of this bitmap (after it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect. A CGB verifies only the first 18h bytes of the bitmap, but others (for example a pocket gameboy) verify all 30h bytes.

===0134-0143 - Title===
Title of the game in UPPER CASE ASCII. If it is less than 16 characters then the remaining bytes are filled with 00's. When inventing the CGB, Nintendo has reduced the length of this area to 15 characters, and some months later they had the fantastic idea to reduce it to 11 characters only. The new meaning of the ex-title bytes is described below.

===013F-0142 - Manufacturer Code===
In older cartridges this area has been part of the Title (see above), in newer cartridges this area contains an 4 character uppercase manufacturer code. Purpose and Deeper Meaning unknown.

===0143 - CGB Flag===
In older cartridges this byte has been part of the Title (see above). In CGB cartridges the upper bit is used to enable CGB functions. This is required, otherwise the CGB switches itself into Non-CGB-Mode. Typical values are:

  80h - Game supports CGB functions, but works on old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).

Values with Bit 7 set, and either Bit 2 or 3 set, will switch the gameboy into a special non-CGB-mode with uninitialized palettes. Purpose unknown, eventually this has been supposed to be used to colorize monochrome games that include fixed palette data at a special location in ROM.

===0144-0145 - New Licensee Code===
Specifies a two character ASCII licensee code, indicating the company or publisher of the game. These two bytes are used in newer games only (games that have been released after the SGB has been invented). Older games are using the header entry at 014B instead.

Sample licensee codes :
{| class=&quot;wikitable&quot;
|-
| '''00''' 
| none
| '''01''' 
| Nintendo R&amp;D1
| '''08''' 
| Capcom
|-
| '''13''' 
| Electronic Arts
| '''18''' 
| Hudson Soft
| '''19''' 
| b-ai
|-
| '''20''' 
| kss
| '''22''' 
| pow
| '''24''' 
| PCM Complete
|-
| '''25''' 
| san-x
| '''28''' 
| Kemco Japan
| '''29''' 
| seta
|-
| '''30''' 
| Viacom
| '''31''' 
| Nintendo
| '''32''' 
| Bandai
|-
| '''33''' 
| Ocean/Acclaim
| '''34''' 
| Konami
| '''35''' 
| Hector
|-
| '''37''' 
| Taito
| '''38''' 
| Hudson
| '''39''' 
| Banpresto
|-
| '''41''' 
| Ubi Soft
| '''42''' 
| Atlus
| '''44''' 
| Malibu
|-
| '''46''' 
| angel
| '''47''' 
| Bullet-Proof
| '''49''' 
| irem
|-
| '''50''' 
| Absolute
| '''51''' 
| Acclaim
| '''52''' 
| Activision
|-
| '''53''' 
| American sammy
| '''54''' 
| Konami
| '''55''' 
| Hi tech entertainment
|-
| '''56''' 
| LJN
| '''57''' 
| Matchbox
| '''58''' 
| Mattel
|-
| '''59''' 
| Milton Bradley
| '''60''' 
| Titus
| '''61''' 
| Virgin
|-
| '''64''' 
| LucasArts
| '''67''' 
| Ocean
| '''69''' 
| Electronic Arts
|-
| '''70''' 
| Infogrames
| '''71''' 
| Interplay
| '''72''' 
| Broderbund
|-
| '''73''' 
| sculptured
| '''75''' 
| sci
| '''78''' 
| THQ
|-
| '''79''' 
| Accolade
| '''80''' 
| misawa
| '''83''' 
| lozc
|-
| '''86''' 
| tokuma shoten i*
| '''87''' 
| tsukuda ori*
| '''91''' 
| Chunsoft
|-
| '''92''' 
| Video system
| '''93''' 
| Ocean/Acclaim
| '''95''' 
| Varie
|-
| '''96''' 
| Yonezawa/s'pal
| '''97''' 
| Kaneko
| '''99''' 
| Pack in soft
|-
| '''A4''' 
| Konami (Yu-Gi-Oh!)
| 
| 
| 
| 
|}

===0146 - SGB Flag===
Specifies whether the game supports SGB functions, common values are:

  00h = No SGB functions (Normal Gameboy or CGB only game)
  03h = Game supports SGB functions

The SGB disables its SGB functions if this byte is set to another value than 03h.

===0147 - Cartridge Type===
Specifies which Memory Bank Controller (if any) is used in the cartridge, and if further external hardware exists in the cartridge.

  00h  ROM ONLY                 19h  MBC5
  01h  MBC1                     1Ah  MBC5+RAM
  02h  MBC1+RAM                 1Bh  MBC5+RAM+BATTERY
  03h  MBC1+RAM+BATTERY         1Ch  MBC5+RUMBLE
  05h  MBC2                     1Dh  MBC5+RUMBLE+RAM
  06h  MBC2+BATTERY             1Eh  MBC5+RUMBLE+RAM+BATTERY
  08h  ROM+RAM                  20h  MBC6
  09h  ROM+RAM+BATTERY          22h  MBC7+SENSOR+RUMBLE+RAM+BATTERY
  0Bh  MMM01
  0Ch  MMM01+RAM
  0Dh  MMM01+RAM+BATTERY
  0Fh  MBC3+TIMER+BATTERY
  10h  MBC3+TIMER+RAM+BATTERY   FCh  POCKET CAMERA
  11h  MBC3                     FDh  BANDAI TAMA5
  12h  MBC3+RAM                 FEh  HuC3
  13h  MBC3+RAM+BATTERY         FFh  HuC1+RAM+BATTERY

===0148 - ROM Size===
Specifies the ROM Size of the cartridge. Typically calculated as &quot;32KB shl N&quot;.

  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  08h -   8MByte (512 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)


===0149 - RAM Size===
Specifies the size of the external RAM in the cartridge (if any).

  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
  04h - 128 KBytes (16 banks of 8KBytes each)
  05h - 64 KBytes (8 banks of 8KBytes each)

When using a MBC2 chip 00h must be specified in this entry, even though the MBC2 includes a built-in RAM of 512 x 4 bits.

===014A - Destination Code===
Specifies if this version of the game is supposed to be sold in Japan, or anywhere else. Only two values are defined.

  00h - Japanese
  01h - Non-Japanese


===014B - Old Licensee Code===
Specifies the games company/publisher code in range 00-FFh. A value of 33h signalizes that the New License Code in header bytes 0144-0145 is used instead.
(Super GameBoy functions won't work if &lt;&gt; $33.)
A list of licensee codes can be found [[Gameboy_ROM_Header_Info#Licensee|here]].

===014C - Mask ROM Version number===
Specifies the version number of the game. That is usually 00h.

===014D - Header Checksum===
Contains an 8 bit checksum across the cartridge header bytes 0134-014C. The checksum is calculated as follows:

  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT

The lower 8 bits of the result must be the same than the value in this entry. The GAME WON'T WORK if this checksum is incorrect.

===014E-014F - Global Checksum===
Contains a 16 bit checksum (upper byte first) across the whole cartridge ROM. Produced by adding all bytes of the cartridge (except for the two checksum bytes). The Gameboy doesn't verify this checksum.</text>
      <sha1>g1kx5q11n97ckgvy3juvrumz9gs39ah</sha1>
    </revision>
  </page>
  <page>
    <title>Memory Bank Controllers</title>
    <ns>0</ns>
    <id>56</id>
    <revision>
      <id>160</id>
      <timestamp>2009-06-28T11:06:19Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank s...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9493">As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself), several different MBC types are available:

__TOC__

In each cartridge, the required (or preferred) MBC type should be specified in byte at 0147h of the ROM. (As described in the chapter about The Cartridge Header.)

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to read the latched (frozen) time from the RTC registers, while the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.


== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.


== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>pixs7em87u4agubu35b237fdteqg7lp</sha1>
    </revision>
    <revision>
      <id>179</id>
      <parentid>160</parentid>
      <timestamp>2009-06-28T13:01:01Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9527">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself), several different MBC types are available:

__TOC__

In each cartridge, the required (or preferred) MBC type should be specified in byte at 0147h of the ROM. (As described in the chapter about The Cartridge Header.)

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to read the latched (frozen) time from the RTC registers, while the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.


== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.


== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>0b8cywu9nvmowi09d0ljxanvdw7evba</sha1>
    </revision>
    <revision>
      <id>257</id>
      <parentid>179</parentid>
      <timestamp>2010-06-23T00:06:53Z</timestamp>
      <contributor>
        <username>Trap15</username>
        <id>20</id>
      </contributor>
      <comment>Added MBC5</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10583">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself), several different MBC types are available:

__TOC__

In each cartridge, the required (or preferred) MBC type should be specified in byte at 0147h of the ROM. (As described in the chapter about The Cartridge Header.)

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to read the latched (frozen) time from the RTC registers, while the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 64kbit, 256kbit and 1mbit.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===3000-3FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.


== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>re8xjwi2r23r61dve2otn1yfzedmpca</sha1>
    </revision>
    <revision>
      <id>258</id>
      <parentid>257</parentid>
      <timestamp>2010-06-23T00:09:37Z</timestamp>
      <contributor>
        <username>Trap15</username>
        <id>20</id>
      </contributor>
      <comment>/* 4000-5FFF - RAM Bank Number (Write Only) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10556">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself), several different MBC types are available:

__TOC__

In each cartridge, the required (or preferred) MBC type should be specified in byte at 0147h of the ROM. (As described in the chapter about The Cartridge Header.)

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to read the latched (frozen) time from the RTC registers, while the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 64kbit, 256kbit and 1mbit.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===3000-3FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.


== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>k36y6copji15tbhpamjosslrm4n335q</sha1>
    </revision>
    <revision>
      <id>362</id>
      <parentid>258</parentid>
      <timestamp>2010-12-01T18:52:20Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>/* MBC5 (max 8MByte ROM and/or 128KByte RAM) */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10556">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself), several different MBC types are available:

__TOC__

In each cartridge, the required (or preferred) MBC type should be specified in byte at 0147h of the ROM. (As described in the chapter about The Cartridge Header.)

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to read the latched (frozen) time from the RTC registers, while the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 64kbit, 256kbit and 1mbit.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.


== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>py18oeb9oikt5pplyf32gt927nsh0k8</sha1>
    </revision>
    <revision>
      <id>572</id>
      <parentid>362</parentid>
      <timestamp>2014-12-29T06:19:26Z</timestamp>
      <contributor>
        <username>Elizafox</username>
        <id>49</id>
      </contributor>
      <comment>/* MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) */ Clarify</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10599">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself), several different MBC types are available:

__TOC__

In each cartridge, the required (or preferred) MBC type should be specified in byte at 0147h of the ROM. (As described in the chapter about The Cartridge Header.)

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 64kbit, 256kbit and 1mbit.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.


== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>6ue1loltobvrmc09429qxa1e9bs6ne0</sha1>
    </revision>
    <revision>
      <id>699</id>
      <parentid>572</parentid>
      <timestamp>2016-08-25T05:02:20Z</timestamp>
      <contributor>
        <username>Fylwind</username>
        <id>64</id>
      </contributor>
      <comment>Link to [[The Cartridge Header#0148_-_ROM_Size]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10625">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 64kbit, 256kbit and 1mbit.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.


== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>4r2udjlnb58a5n96cr4insp4nmmy83j</sha1>
    </revision>
    <revision>
      <id>700</id>
      <parentid>699</parentid>
      <timestamp>2016-08-25T08:54:21Z</timestamp>
      <contributor>
        <username>Fylwind</username>
        <id>64</id>
      </contributor>
      <comment>/* A000-BFFF - RAM Bank 00-0F, if any (Read/Write) */ use bytes instead of bits</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10622">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.


== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>2ccl97y8mi92rb14yauidz5o83me40k</sha1>
    </revision>
    <revision>
      <id>798</id>
      <parentid>700</parentid>
      <timestamp>2018-08-25T21:29:33Z</timestamp>
      <contributor>
        <username>Ellam</username>
        <id>81</id>
      </contributor>
      <comment>Update MBC3 max RAM to reflect Pokemon Crystal (J)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10622">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.


== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>jz2v4f0ghzv592l5bllrputhno62o66</sha1>
    </revision>
    <revision>
      <id>826</id>
      <parentid>798</parentid>
      <timestamp>2019-01-13T20:38:08Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* HuC1 (MBC with Infrared Controller) */ MBC1M and MMM01 exist</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11248">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>oguz7wmi3phemjsjxrf515ksuq591gh</sha1>
    </revision>
    <revision>
      <id>849</id>
      <parentid>826</parentid>
      <timestamp>2019-02-10T22:07:08Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* Multicart MBCs */ Preliminary EMS info</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12458">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

=== EMS ===
PinoBatch learned the game selection protocol for EMS flash carts from beware, who in turn learned it from nitro2k01. Take this with a grain of salt, as it hasn't been verified on the authentic EMS hardware.

A [[The Cartridge Header|header]] matching any of the following is detected as EMS mapper:

* Header name is &quot;EMSMENU&quot;, NUL-padded
* Header name is &quot;GB16M&quot;, NUL-padded
* Cartridge type ($0147) = $1B and region ($014A) = $E1

Registers:

;$2000 write: Normal behavior, plus save written value in $2000 latch
;$1000 write: $A5 enables configure mode, $98 disables, and other values have no known effect
;$7000 write while configure mode is on: Copy $2000 latch to OR mask

After the OR mask has been set, all reads from ROM will OR A21-A14 (the bank number) with the OR mask. This chooses which game is visible to the CPU. If the OR mask is not aligned to the game size, the results may be nonsensical. 

The mapper does not support an outer bank for battery SRAM.

To start a game, do the following in code run from RAM: Write $A5 to $1000, write game starting bank number to $2000, write any value to $7000, write $98 to $1000, write $01 to $2000 (so that 32K games work), jump to $0100.

== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>2s8iz53blkxnrh1tsveu9o92u4pcmij</sha1>
    </revision>
    <revision>
      <id>894</id>
      <parentid>849</parentid>
      <timestamp>2019-07-20T19:34:37Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* Multicart MBCs */ add Wisdom Tree</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13265">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

=== EMS ===
PinoBatch learned the game selection protocol for EMS flash carts from beware, who in turn learned it from nitro2k01. Take this with a grain of salt, as it hasn't been verified on the authentic EMS hardware.

A [[The Cartridge Header|header]] matching any of the following is detected as EMS mapper:

* Header name is &quot;EMSMENU&quot;, NUL-padded
* Header name is &quot;GB16M&quot;, NUL-padded
* Cartridge type ($0147) = $1B and region ($014A) = $E1

Registers:

;$2000 write: Normal behavior, plus save written value in $2000 latch
;$1000 write: $A5 enables configure mode, $98 disables, and other values have no known effect
;$7000 write while configure mode is on: Copy $2000 latch to OR mask

After the OR mask has been set, all reads from ROM will OR A21-A14 (the bank number) with the OR mask. This chooses which game is visible to the CPU. If the OR mask is not aligned to the game size, the results may be nonsensical. 

The mapper does not support an outer bank for battery SRAM.

To start a game, do the following in code run from RAM: Write $A5 to $1000, write game starting bank number to $2000, write any value to $7000, write $98 to $1000, write $01 to $2000 (so that 32K games work), jump to $0100.

== Wisdom Tree ==
This is just a 32K ROM switch. Unusually, it uses the address lines, not the data lines, to select a bank.

An emulator can detect a ROM designed for Wisdom Tree mapper in one of two ways:

* $0147 = $00, $0148 = $00, size &gt; 32k, ROM contains &quot;WISDOM TREE&quot; or &quot;WISDOM\x00TREE&quot; (the space can be $20 or $00)
* $0147 = $c0, $014a = $d1

Registers:

;$0000-$7FFF write: Select 32K bank at $0000-$7FFF based on A7-A0

Things that should be tested:

* Does it respond to writes throughout $0000-$7FFF? It's simpler to do so, but at least one source speculates that only $0000-$3FFF actually work.
* Does it always boot in the first bank, or does it boot in a random bank? If the latter, a multicart using this mapper would need to patch the $0100 entry point in all banks to jump to the menu.

== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>6a5jzc9q7ogbj5a440c2c04jneokbz5</sha1>
    </revision>
    <revision>
      <id>895</id>
      <parentid>894</parentid>
      <timestamp>2019-07-20T19:35:33Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <minor/>
      <comment>/* Wisdom Tree */ fix the section's nesting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13322">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

=== EMS ===
PinoBatch learned the game selection protocol for EMS flash carts from beware, who in turn learned it from nitro2k01. Take this with a grain of salt, as it hasn't been verified on the authentic EMS hardware.

A [[The Cartridge Header|header]] matching any of the following is detected as EMS mapper:

* Header name is &quot;EMSMENU&quot;, NUL-padded
* Header name is &quot;GB16M&quot;, NUL-padded
* Cartridge type ($0147) = $1B and region ($014A) = $E1

Registers:

;$2000 write: Normal behavior, plus save written value in $2000 latch
;$1000 write: $A5 enables configure mode, $98 disables, and other values have no known effect
;$7000 write while configure mode is on: Copy $2000 latch to OR mask

After the OR mask has been set, all reads from ROM will OR A21-A14 (the bank number) with the OR mask. This chooses which game is visible to the CPU. If the OR mask is not aligned to the game size, the results may be nonsensical. 

The mapper does not support an outer bank for battery SRAM.

To start a game, do the following in code run from RAM: Write $A5 to $1000, write game starting bank number to $2000, write any value to $7000, write $98 to $1000, write $01 to $2000 (so that 32K games work), jump to $0100.

=== Wisdom Tree ===
This is just a 32K ROM switch implemented with a latch on A7-A0 that goes to A22-A15. Unusually, it uses the address lines, not the data lines, to select a bank.

An emulator can detect a ROM designed for Wisdom Tree mapper in one of two ways:

* $0147 = $00, $0148 = $00, size &gt; 32k, ROM contains &quot;WISDOM TREE&quot; or &quot;WISDOM\x00TREE&quot; (the space can be $20 or $00)
* $0147 = $c0, $014a = $d1

Registers:

;$0000-$7FFF write: Select 32K bank at $0000-$7FFF based on A7-A0

Things that should be tested:

* Does it respond to writes throughout $0000-$7FFF? It's simpler to do so, but at least one source speculates that only $0000-$3FFF actually work.
* Does it always boot in the first bank, or does it boot in a random bank? If the latter, a multicart using this mapper would need to patch the $0100 entry point in all banks to jump to the menu.

== MBC Timing Issues ==

Using MBCs with CGB Double Speed Mode
The MBC5 has been designed to support CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nethertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, my own good old selfmade MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>knf4r4ym2rxj7xqhha8rdr3of10fn26</sha1>
    </revision>
    <revision>
      <id>896</id>
      <parentid>895</parentid>
      <timestamp>2019-07-20T19:39:17Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* MBC Timing Issues */ It's about timing guarantees</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13326">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

=== EMS ===
PinoBatch learned the game selection protocol for EMS flash carts from beware, who in turn learned it from nitro2k01. Take this with a grain of salt, as it hasn't been verified on the authentic EMS hardware.

A [[The Cartridge Header|header]] matching any of the following is detected as EMS mapper:

* Header name is &quot;EMSMENU&quot;, NUL-padded
* Header name is &quot;GB16M&quot;, NUL-padded
* Cartridge type ($0147) = $1B and region ($014A) = $E1

Registers:

;$2000 write: Normal behavior, plus save written value in $2000 latch
;$1000 write: $A5 enables configure mode, $98 disables, and other values have no known effect
;$7000 write while configure mode is on: Copy $2000 latch to OR mask

After the OR mask has been set, all reads from ROM will OR A21-A14 (the bank number) with the OR mask. This chooses which game is visible to the CPU. If the OR mask is not aligned to the game size, the results may be nonsensical. 

The mapper does not support an outer bank for battery SRAM.

To start a game, do the following in code run from RAM: Write $A5 to $1000, write game starting bank number to $2000, write any value to $7000, write $98 to $1000, write $01 to $2000 (so that 32K games work), jump to $0100.

=== Wisdom Tree ===
This is just a 32K ROM switch implemented with a latch on A7-A0 that goes to A22-A15. Unusually, it uses the address lines, not the data lines, to select a bank.

An emulator can detect a ROM designed for Wisdom Tree mapper in one of two ways:

* $0147 = $00, $0148 = $00, size &gt; 32k, ROM contains &quot;WISDOM TREE&quot; or &quot;WISDOM\x00TREE&quot; (the space can be $20 or $00)
* $0147 = $c0, $014a = $d1

Registers:

;$0000-$7FFF write: Select 32K bank at $0000-$7FFF based on A7-A0

Things that should be tested:

* Does it respond to writes throughout $0000-$7FFF? It's simpler to do so, but at least one source speculates that only $0000-$3FFF actually work.
* Does it always boot in the first bank, or does it boot in a random bank? If the latter, a multicart using this mapper would need to patch the $0100 entry point in all banks to jump to the menu.

== MBC Timing Issues ==

Among Nintendo MBCs, only the MBC5 is guaranteed by Nintendo to support the tighter timing of CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nevertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, a self-made MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>5ycep3tmc6z7sv2ipi0hstzyucy02hn</sha1>
    </revision>
    <revision>
      <id>897</id>
      <parentid>896</parentid>
      <timestamp>2019-07-20T20:35:18Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>Added BGB magic values</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14212">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

=== EMS ===
PinoBatch learned the game selection protocol for EMS flash carts from beware, who in turn learned it from nitro2k01. Take this with a grain of salt, as it hasn't been verified on the authentic EMS hardware.

A [[The Cartridge Header|header]] matching any of the following is detected as EMS mapper:

* Header name is &quot;EMSMENU&quot;, NUL-padded
* Header name is &quot;GB16M&quot;, NUL-padded
* Cartridge type ($0147) = $1B and region ($014A) = $E1

Registers:

;$2000 write: Normal behavior, plus save written value in $2000 latch
;$1000 write: $A5 enables configure mode, $98 disables, and other values have no known effect
;$7000 write while configure mode is on: Copy $2000 latch to OR mask

After the OR mask has been set, all reads from ROM will OR A21-A14 (the bank number) with the OR mask. This chooses which game is visible to the CPU. If the OR mask is not aligned to the game size, the results may be nonsensical. 

The mapper does not support an outer bank for battery SRAM.

To start a game, do the following in code run from RAM: Write $A5 to $1000, write game starting bank number to $2000, write any value to $7000, write $98 to $1000, write $01 to $2000 (so that 32K games work), jump to $0100.

=== Wisdom Tree ===
This is just a 32K ROM switch implemented with a latch on A7-A0 that goes to A22-A15. Unusually, it uses the address lines, not the data lines, to select a bank.

An emulator can detect a ROM designed for Wisdom Tree mapper in one of two ways:

* $0147 = $00, $0148 = $00, size &gt; 32k, ROM contains &quot;WISDOM TREE&quot; or &quot;WISDOM\x00TREE&quot; (the space can be $20 or $00)

Registers:

;$0000-$7FFF write: Select 32K bank at $0000-$7FFF based on A7-A0

Things that should be tested:

* Does it respond to writes throughout $0000-$7FFF? It's simpler to do so, but at least one source speculates that only $0000-$3FFF actually work.
* Does it always boot in the first bank, or does it boot in a random bank? If the latter, a multicart using this mapper would need to patch the $0100 entry point in all banks to jump to the menu.

=== Magic values for detection of multicarts in emulators ===
Sometimes it may be useful to allow a ROM to be detected as a multicart in emulator, for example for development of a menu for physical multicart hardware. These are values suggested by beware, and supported in BGB, for signaling that your ROM is supposed to interface a multicart mapper. Emulator authors who are interested in supporting multicart mappers are encouraged to support detection of these values in addition to the values described in each section, which are heuristics based on ROMs in the wild, which may not always be suitable for newly produced software. The values are deliberately chosen to be high entropy (&quot;random&quot;) such that the risk of an accidental false positive is unlikely.

* $0147 = $c0, $014a = $d1 -&gt; Detect as Wisdom Tree
* $0147 = $1b, $014a = $e1 -&gt; Detect as EMS multicart
* $0147 = $be -&gt; Detect as Bung multicart

== MBC Timing Issues ==

Among Nintendo MBCs, only the MBC5 is guaranteed by Nintendo to support the tighter timing of CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nevertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, a self-made MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>39lgzsbkhzxzlc1su9gp5k9c28au7jj</sha1>
    </revision>
    <revision>
      <id>898</id>
      <parentid>897</parentid>
      <timestamp>2019-07-20T21:45:15Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>Rewrote Wisdom Tree</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15142">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

=== EMS ===
PinoBatch learned the game selection protocol for EMS flash carts from beware, who in turn learned it from nitro2k01. Take this with a grain of salt, as it hasn't been verified on the authentic EMS hardware.

A [[The Cartridge Header|header]] matching any of the following is detected as EMS mapper:

* Header name is &quot;EMSMENU&quot;, NUL-padded
* Header name is &quot;GB16M&quot;, NUL-padded
* Cartridge type ($0147) = $1B and region ($014A) = $E1

Registers:

;$2000 write: Normal behavior, plus save written value in $2000 latch
;$1000 write: $A5 enables configure mode, $98 disables, and other values have no known effect
;$7000 write while configure mode is on: Copy $2000 latch to OR mask

After the OR mask has been set, all reads from ROM will OR A21-A14 (the bank number) with the OR mask. This chooses which game is visible to the CPU. If the OR mask is not aligned to the game size, the results may be nonsensical. 

The mapper does not support an outer bank for battery SRAM.

To start a game, do the following in code run from RAM: Write $A5 to $1000, write game starting bank number to $2000, write any value to $7000, write $98 to $1000, write $01 to $2000 (so that 32K games work), jump to $0100.

=== Wisdom Tree ===
The Wisdom Tree mapper is a simple, cost-optimized one chip design consisting of a 74LS377 octal latch, aside from the ROM chip. Because the mapper consists of a single standard 74 series logic chip, it has two unusual properties:
# Unlike a usual MBC, it switches the whole 32 kiB ROM area instead of just the $4000-$7FFF area. If you want to use the interrupt vectors with this cart, you should duplicate them across all banks. Additionally, since the initial state of the '377 can't be guaranteed, the ROM header and some code for switching to a known bank should also be included in every bank. This also means that the Wisdom Tree mapper could be used as a multicart mapper for 32 kiB ROMs, assuming there was enough ROM space in each bank for some small initialization code, and none of the ROMs wrote to the $0000-$7FFF area.
# Because the '377 latches data on the ''positive'' edge, and the value on the Gameboy data bus is no longer valid when the positive edge of the write pulse arrives, the designer of this mapper chose to use the A7-A0 address lines for selecting a bank instead of the data lines. Thus, the value you write is ignored, and the lower 8 bits of the address is used. For example, to select bank $XX, you would write any value to address $YYXX, where $YY is in the range $00-$7F.

An emulator can detect a ROM designed for Wisdom Tree mapper in one of two ways:

* ROM contains &quot;WISDOM TREE&quot; or &quot;WISDOM\x00TREE&quot; (the space can be $20 or $00), $0147 = $00, $0148 = $00, size &gt; 32k. This method works for the games released by Wisdom Tree, Inc.
* $0147 = $C0, $014A = $D1. These are the values recommended by beware for 3rd party developers to indicate that the ROM is targeting Wisdom Tree mapper hardware. (See below.)

=== Magic values for detection of multicarts in emulators ===
Sometimes it may be useful to allow a ROM to be detected as a multicart in emulator, for example for development of a menu for physical multicart hardware. These are values suggested by beware, and supported in BGB, for signaling that your ROM is supposed to interface a multicart mapper. Emulator authors who are interested in supporting multicart mappers are encouraged to support detection of these values in addition to the values described in each section, which are heuristics based on ROMs in the wild, which may not always be suitable for newly produced software. The values are deliberately chosen to be high entropy (&quot;random&quot;) such that the risk of an accidental false positive is unlikely.

* $0147 = $c0, $014a = $d1 -&gt; Detect as Wisdom Tree
* $0147 = $1b, $014a = $e1 -&gt; Detect as EMS multicart
* $0147 = $be -&gt; Detect as Bung multicart

== MBC Timing Issues ==

Among Nintendo MBCs, only the MBC5 is guaranteed by Nintendo to support the tighter timing of CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nevertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, a self-made MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>qfxfu3yipsrsgla0813pb8bb292dcv6</sha1>
    </revision>
    <revision>
      <id>899</id>
      <parentid>898</parentid>
      <timestamp>2019-07-20T22:01:48Z</timestamp>
      <contributor>
        <username>PinoBatch</username>
        <id>77</id>
      </contributor>
      <comment>/* Wisdom Tree */ The required reset stub is 5 bytes: not a big inconvenience</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15377">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

=== EMS ===
PinoBatch learned the game selection protocol for EMS flash carts from beware, who in turn learned it from nitro2k01. Take this with a grain of salt, as it hasn't been verified on the authentic EMS hardware.

A [[The Cartridge Header|header]] matching any of the following is detected as EMS mapper:

* Header name is &quot;EMSMENU&quot;, NUL-padded
* Header name is &quot;GB16M&quot;, NUL-padded
* Cartridge type ($0147) = $1B and region ($014A) = $E1

Registers:

;$2000 write: Normal behavior, plus save written value in $2000 latch
;$1000 write: $A5 enables configure mode, $98 disables, and other values have no known effect
;$7000 write while configure mode is on: Copy $2000 latch to OR mask

After the OR mask has been set, all reads from ROM will OR A21-A14 (the bank number) with the OR mask. This chooses which game is visible to the CPU. If the OR mask is not aligned to the game size, the results may be nonsensical. 

The mapper does not support an outer bank for battery SRAM.

To start a game, do the following in code run from RAM: Write $A5 to $1000, write game starting bank number to $2000, write any value to $7000, write $98 to $1000, write $01 to $2000 (so that 32K games work), jump to $0100.

=== Wisdom Tree ===
The Wisdom Tree mapper is a simple, cost-optimized one chip design consisting of a 74LS377 octal latch, aside from the ROM chip. Because the mapper consists of a single standard 74 series logic chip, it has two unusual properties:


First, unlike a usual MBC, it switches the whole 32 kiB ROM area instead of just the $4000-$7FFF area. If you want to use the interrupt vectors with this cart, you should duplicate them across all banks. Additionally, since the initial state of the '377 can't be guaranteed, the ROM header and some code for switching to a known bank should also be included in every bank. This also means that the Wisdom Tree mapper could be used as a multicart mapper for 32 kiB ROMs, assuming there was enough ROM space in each bank for some small initialization code, and none of the ROMs wrote to the $0000-$7FFF area. For example, if the last 5 bytes of all banks are unused, games can be patched as follows:
&lt;pre&gt;
; At $0100 in all banks but the first
  nop
  jp $7FFB

; At $7FFB in all banks
  ld hl, $0100
  ld [hl], a
  jp hl
&lt;/pre&gt;

Second, because the '377 latches data on the ''positive'' edge, and the value on the Game Boy data bus is no longer valid when the positive edge of the write pulse arrives, the designer of this mapper chose to use the A7-A0 address lines for selecting a bank instead of the data lines. Thus, the value you write is ignored, and the lower 8 bits of the address is used. For example, to select bank $XX, you would write any value to address $YYXX, where $YY is in the range $00-$7F.

An emulator can detect a ROM designed for Wisdom Tree mapper in one of two ways:

* ROM contains &quot;WISDOM TREE&quot; or &quot;WISDOM\x00TREE&quot; (the space can be $20 or $00), $0147 = $00, $0148 = $00, size &gt; 32k. This method works for the games released by Wisdom Tree, Inc.
* $0147 = $C0, $014A = $D1. These are the values recommended by beware for 3rd party developers to indicate that the ROM is targeting Wisdom Tree mapper hardware. (See below.)

=== Magic values for detection of multicarts in emulators ===
Sometimes it may be useful to allow a ROM to be detected as a multicart in emulator, for example for development of a menu for physical multicart hardware. These are values suggested by beware, and supported in BGB, for signaling that your ROM is supposed to interface a multicart mapper. Emulator authors who are interested in supporting multicart mappers are encouraged to support detection of these values in addition to the values described in each section, which are heuristics based on ROMs in the wild, which may not always be suitable for newly produced software. The values are deliberately chosen to be high entropy (&quot;random&quot;) such that the risk of an accidental false positive is unlikely.

* $0147 = $c0, $014a = $d1 -&gt; Detect as Wisdom Tree
* $0147 = $1b, $014a = $e1 -&gt; Detect as EMS multicart
* $0147 = $be -&gt; Detect as Bung multicart

== MBC Timing Issues ==

Among Nintendo MBCs, only the MBC5 is guaranteed by Nintendo to support the tighter timing of CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nevertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, a self-made MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>iq7ty75p2ye0trnnolwkz6da4x9oxgz</sha1>
    </revision>
    <revision>
      <id>900</id>
      <parentid>899</parentid>
      <timestamp>2019-07-20T22:05:50Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>/* Wisdom Tree */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15377">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

=== EMS ===
PinoBatch learned the game selection protocol for EMS flash carts from beware, who in turn learned it from nitro2k01. Take this with a grain of salt, as it hasn't been verified on the authentic EMS hardware.

A [[The Cartridge Header|header]] matching any of the following is detected as EMS mapper:

* Header name is &quot;EMSMENU&quot;, NUL-padded
* Header name is &quot;GB16M&quot;, NUL-padded
* Cartridge type ($0147) = $1B and region ($014A) = $E1

Registers:

;$2000 write: Normal behavior, plus save written value in $2000 latch
;$1000 write: $A5 enables configure mode, $98 disables, and other values have no known effect
;$7000 write while configure mode is on: Copy $2000 latch to OR mask

After the OR mask has been set, all reads from ROM will OR A21-A14 (the bank number) with the OR mask. This chooses which game is visible to the CPU. If the OR mask is not aligned to the game size, the results may be nonsensical. 

The mapper does not support an outer bank for battery SRAM.

To start a game, do the following in code run from RAM: Write $A5 to $1000, write game starting bank number to $2000, write any value to $7000, write $98 to $1000, write $01 to $2000 (so that 32K games work), jump to $0100.

=== Wisdom Tree ===
The Wisdom Tree mapper is a simple, cost-optimized one chip design consisting of a 74LS377 octal latch, aside from the ROM chip. Because the mapper consists of a single standard 74 series logic chip, it has two unusual properties:


First, unlike a usual MBC, it switches the whole 32 kiB ROM area instead of just the $4000-$7FFF area. If you want to use the interrupt vectors with this cart, you should duplicate them across all banks. Additionally, since the initial state of the '377 can't be guaranteed, the ROM header and some code for switching to a known bank should also be included in every bank. This also means that the Wisdom Tree mapper could be used as a multicart mapper for 32 kiB ROMs, assuming there was enough ROM space in each bank for some small initialization code, and none of the ROMs wrote to the $0000-$7FFF area. For example, if the last 5 bytes of all banks are unused, games can be patched as follows:
&lt;pre&gt;
; At $0100 in all banks but the first
  nop
  jp $7FFB

; At $7FFB in all banks
  ld hl, $0100
  ld [hl], l
  jp hl
&lt;/pre&gt;

Second, because the '377 latches data on the ''positive'' edge, and the value on the Game Boy data bus is no longer valid when the positive edge of the write pulse arrives, the designer of this mapper chose to use the A7-A0 address lines for selecting a bank instead of the data lines. Thus, the value you write is ignored, and the lower 8 bits of the address is used. For example, to select bank $XX, you would write any value to address $YYXX, where $YY is in the range $00-$7F.

An emulator can detect a ROM designed for Wisdom Tree mapper in one of two ways:

* ROM contains &quot;WISDOM TREE&quot; or &quot;WISDOM\x00TREE&quot; (the space can be $20 or $00), $0147 = $00, $0148 = $00, size &gt; 32k. This method works for the games released by Wisdom Tree, Inc.
* $0147 = $C0, $014A = $D1. These are the values recommended by beware for 3rd party developers to indicate that the ROM is targeting Wisdom Tree mapper hardware. (See below.)

=== Magic values for detection of multicarts in emulators ===
Sometimes it may be useful to allow a ROM to be detected as a multicart in emulator, for example for development of a menu for physical multicart hardware. These are values suggested by beware, and supported in BGB, for signaling that your ROM is supposed to interface a multicart mapper. Emulator authors who are interested in supporting multicart mappers are encouraged to support detection of these values in addition to the values described in each section, which are heuristics based on ROMs in the wild, which may not always be suitable for newly produced software. The values are deliberately chosen to be high entropy (&quot;random&quot;) such that the risk of an accidental false positive is unlikely.

* $0147 = $c0, $014a = $d1 -&gt; Detect as Wisdom Tree
* $0147 = $1b, $014a = $e1 -&gt; Detect as EMS multicart
* $0147 = $be -&gt; Detect as Bung multicart

== MBC Timing Issues ==

Among Nintendo MBCs, only the MBC5 is guaranteed by Nintendo to support the tighter timing of CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nevertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, a self-made MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>mswqqep4vw7e4j5vb6d1gifwapzi4p7</sha1>
    </revision>
    <revision>
      <id>901</id>
      <parentid>900</parentid>
      <timestamp>2019-07-20T22:08:06Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>Reverted edits by [[Special:Contributions/Nitro2k01|Nitro2k01]] ([[User talk:Nitro2k01|talk]]) to last revision by [[User:PinoBatch|PinoBatch]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15377">{{Pandocs|memorybankcontrollers}}
As the gameboys 16 bit address bus offers only limited space for ROM and RAM addressing, many games are using Memory Bank Controllers (MBCs) to expand the available address space by bank switching. These MBC chips are located in the game cartridge (ie. not in the gameboy itself).

In each cartridge, the required (or preferred) MBC type should be specified in the byte at 0147h of the ROM, as described in [[The_Cartridge_Header#0148_-_ROM_Size|the cartridge header]].  Several different MBC types are available:

__TOC__

== None (32KByte ROM only) ==

Small games of not more than 32KBytes ROM do not require a MBC chip for ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. Optionally up to 8KByte of RAM could be connected at A000-BFFF, even though that could require a tiny MBC-like circuit, but no real MBC chip.


== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.


== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.


== MBC3 (max 2MByte ROM and/or 64KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 64KB RAM (8 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-07h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.

== MBC5 (max 8MByte ROM and/or 128KByte RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 8KiB, 32KiB and 128KiB.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

== HuC1 (MBC with Infrared Controller) ==

This controller (made by Hudson Soft) appears to be very similar to an MBC1 with the main difference being that it supports infrared LED input / output. (Similiar to the infrared port that has been later invented in CGBs.)

The Japanese cart &quot;Fighting Phoenix&quot; (internal cart name: SUPER B DAMAN) is known to contain this chip.

== Multicart MBCs ==

'''MBC1M''' uses the MBC1 IC, but the board does not connect the MBC1's A18 address output to the ROM. This allows including multiple 2 Mbit (16 bank) games, with SRAM bank select ($4000) to select which of up to four games is switched in. In theory, a MBC1M board could be made for 1 Mbit or 512 kbit games by additionally not connecting A17 and A16 outputs, but this appears not to have been done in licensed games.

'''MMM01''' is a more complex that allows for games of different sizes [https://wiki.tauwasser.eu/view/MMM01 Docs on Tauwasser.eu]

'''Bung''' and '''EMS''' MBCs are reported to exist.

=== EMS ===
PinoBatch learned the game selection protocol for EMS flash carts from beware, who in turn learned it from nitro2k01. Take this with a grain of salt, as it hasn't been verified on the authentic EMS hardware.

A [[The Cartridge Header|header]] matching any of the following is detected as EMS mapper:

* Header name is &quot;EMSMENU&quot;, NUL-padded
* Header name is &quot;GB16M&quot;, NUL-padded
* Cartridge type ($0147) = $1B and region ($014A) = $E1

Registers:

;$2000 write: Normal behavior, plus save written value in $2000 latch
;$1000 write: $A5 enables configure mode, $98 disables, and other values have no known effect
;$7000 write while configure mode is on: Copy $2000 latch to OR mask

After the OR mask has been set, all reads from ROM will OR A21-A14 (the bank number) with the OR mask. This chooses which game is visible to the CPU. If the OR mask is not aligned to the game size, the results may be nonsensical. 

The mapper does not support an outer bank for battery SRAM.

To start a game, do the following in code run from RAM: Write $A5 to $1000, write game starting bank number to $2000, write any value to $7000, write $98 to $1000, write $01 to $2000 (so that 32K games work), jump to $0100.

=== Wisdom Tree ===
The Wisdom Tree mapper is a simple, cost-optimized one chip design consisting of a 74LS377 octal latch, aside from the ROM chip. Because the mapper consists of a single standard 74 series logic chip, it has two unusual properties:


First, unlike a usual MBC, it switches the whole 32 kiB ROM area instead of just the $4000-$7FFF area. If you want to use the interrupt vectors with this cart, you should duplicate them across all banks. Additionally, since the initial state of the '377 can't be guaranteed, the ROM header and some code for switching to a known bank should also be included in every bank. This also means that the Wisdom Tree mapper could be used as a multicart mapper for 32 kiB ROMs, assuming there was enough ROM space in each bank for some small initialization code, and none of the ROMs wrote to the $0000-$7FFF area. For example, if the last 5 bytes of all banks are unused, games can be patched as follows:
&lt;pre&gt;
; At $0100 in all banks but the first
  nop
  jp $7FFB

; At $7FFB in all banks
  ld hl, $0100
  ld [hl], a
  jp hl
&lt;/pre&gt;

Second, because the '377 latches data on the ''positive'' edge, and the value on the Game Boy data bus is no longer valid when the positive edge of the write pulse arrives, the designer of this mapper chose to use the A7-A0 address lines for selecting a bank instead of the data lines. Thus, the value you write is ignored, and the lower 8 bits of the address is used. For example, to select bank $XX, you would write any value to address $YYXX, where $YY is in the range $00-$7F.

An emulator can detect a ROM designed for Wisdom Tree mapper in one of two ways:

* ROM contains &quot;WISDOM TREE&quot; or &quot;WISDOM\x00TREE&quot; (the space can be $20 or $00), $0147 = $00, $0148 = $00, size &gt; 32k. This method works for the games released by Wisdom Tree, Inc.
* $0147 = $C0, $014A = $D1. These are the values recommended by beware for 3rd party developers to indicate that the ROM is targeting Wisdom Tree mapper hardware. (See below.)

=== Magic values for detection of multicarts in emulators ===
Sometimes it may be useful to allow a ROM to be detected as a multicart in emulator, for example for development of a menu for physical multicart hardware. These are values suggested by beware, and supported in BGB, for signaling that your ROM is supposed to interface a multicart mapper. Emulator authors who are interested in supporting multicart mappers are encouraged to support detection of these values in addition to the values described in each section, which are heuristics based on ROMs in the wild, which may not always be suitable for newly produced software. The values are deliberately chosen to be high entropy (&quot;random&quot;) such that the risk of an accidental false positive is unlikely.

* $0147 = $c0, $014a = $d1 -&gt; Detect as Wisdom Tree
* $0147 = $1b, $014a = $e1 -&gt; Detect as EMS multicart
* $0147 = $be -&gt; Detect as Bung multicart

== MBC Timing Issues ==

Among Nintendo MBCs, only the MBC5 is guaranteed by Nintendo to support the tighter timing of CGB Double Speed Mode.
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast enough in that mode. If so, it might be nevertheless possible to use Double Speed during periods which use only code and data which is located in internal RAM.
However, despite of the above, a self-made MBC1-EPROM card appears to work stable and fine even in Double Speed Mode though.</text>
      <sha1>iq7ty75p2ye0trnnolwkz6da4x9oxgz</sha1>
    </revision>
  </page>
  <page>
    <title>Gamegenie/Shark Cheats</title>
    <ns>0</ns>
    <id>57</id>
    <revision>
      <id>161</id>
      <timestamp>2009-06-28T11:07:00Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: Game Shark and Gamegenie are external cartridge adapters that can be plugged between the gameboy and the actual game cartridge. Hexadecimal codes can be then entered for specific games, ty...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1671">Game Shark and Gamegenie are external cartridge adapters that can be plugged between the gameboy and the actual game cartridge. Hexadecimal codes can be then entered for specific games, typically providing things like Infinite Sex, 255 Cigarettes, or Starting directly in Wonderland Level PRO, etc.

===Gamegenie (ROM patches)===
Gamegenie codes consist of nine-digit hex numbers, formatted as ABC-DEF-GHI, the meaning of the separate digits is:

  AB    New data
  FCDE  Memory address, XORed by 0F000h
  GI    Old data, XORed by 0BAh and rotated left by two
  H     Don't know, maybe checksum and/or else

The address should be located in ROM area 0000h-7FFFh, the adapter permanently compares address/old data with address/data being read by the game, and replaces that data by new data if necessary. That method (more or less) prohibits unwanted patching of wrong memory banks. Eventually it is also possible to patch external RAM ?
Newer devices reportedly allow to specify only the first six digits (optionally). As far as I rememeber, around three or four codes can be used simultaneously.

===Game Shark (RAM patches)===
Game Shark codes consist of eight-digit hex numbers, formatted as ABCDEFGH, the meaning of the separate digits is:

  AB    External RAM bank number
  CD    New Data
  GHEF  Memory Address (internal or external RAM, A000-DFFF)

As far as I understand, patching is implement by hooking the original VBlank interrupt handler, and re-writing RAM values each frame. The downside is that this method steals some CPU time, also, it cannot be used to patch program code in ROM.
As far as I rememeber, somewhat 10-25 codes can be used simultaneously.</text>
      <sha1>5jgtadlt76qe1epc39aqt1h9gqzqvfq</sha1>
    </revision>
    <revision>
      <id>180</id>
      <parentid>161</parentid>
      <timestamp>2009-06-28T13:01:35Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1704">{{Pandocs|gamegeniesharkcheats}}
Game Shark and Gamegenie are external cartridge adapters that can be plugged between the gameboy and the actual game cartridge. Hexadecimal codes can be then entered for specific games, typically providing things like Infinite Sex, 255 Cigarettes, or Starting directly in Wonderland Level PRO, etc.

===Gamegenie (ROM patches)===
Gamegenie codes consist of nine-digit hex numbers, formatted as ABC-DEF-GHI, the meaning of the separate digits is:

  AB    New data
  FCDE  Memory address, XORed by 0F000h
  GI    Old data, XORed by 0BAh and rotated left by two
  H     Don't know, maybe checksum and/or else

The address should be located in ROM area 0000h-7FFFh, the adapter permanently compares address/old data with address/data being read by the game, and replaces that data by new data if necessary. That method (more or less) prohibits unwanted patching of wrong memory banks. Eventually it is also possible to patch external RAM ?
Newer devices reportedly allow to specify only the first six digits (optionally). As far as I rememeber, around three or four codes can be used simultaneously.

===Game Shark (RAM patches)===
Game Shark codes consist of eight-digit hex numbers, formatted as ABCDEFGH, the meaning of the separate digits is:

  AB    External RAM bank number
  CD    New Data
  GHEF  Memory Address (internal or external RAM, A000-DFFF)

As far as I understand, patching is implement by hooking the original VBlank interrupt handler, and re-writing RAM values each frame. The downside is that this method steals some CPU time, also, it cannot be used to patch program code in ROM.
As far as I rememeber, somewhat 10-25 codes can be used simultaneously.</text>
      <sha1>jrtdbxjvebcy6j75u1qhnr72efcsziv</sha1>
    </revision>
  </page>
  <page>
    <title>Power Up Sequence</title>
    <ns>0</ns>
    <id>58</id>
    <revision>
      <id>162</id>
      <timestamp>2009-06-28T11:07:28Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: When the GameBoy is powered up, a 256 byte program starting at memory location 0 is executed. This program is located in a ROM inside the GameBoy. The first thing the program does is read ...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2461">When the GameBoy is powered up, a 256 byte program starting at memory location 0 is executed. This program is located in a ROM inside the GameBoy. The first thing the program does is read the cartridge locations from $104 to $133 and place this graphic of a Nintendo logo on the screen at the top. This image is then scrolled until it is in the middle of the screen. Two musical notes are then played on the internal speaker. Again, the cartridge locations $104 to $133 are read but this time they are compared with a table in the internal rom. If any byte fails to compare, then the GameBoy stops comparing bytes and simply halts all operations. If all locations compare the same, then the GameBoy starts adding all of the bytes in the cartridge from $134 to $14d. A value of 25 decimal is added to this total. If the least significant byte of the result is a not a zero, then the GameBoy will stop doing anything. If it is a zero, then the internal ROM is disabled and cartridge program execution begins at location $100 with the following register values:

   AF=$01B0
   BC=$0013
   DE=$00D8
   HL=$014D
   Stack Pointer=$FFFE
   [$FF05] = $00   ; TIMA
   [$FF06] = $00   ; TMA
   [$FF07] = $00   ; TAC
   [$FF10] = $80   ; NR10
   [$FF11] = $BF   ; NR11
   [$FF12] = $F3   ; NR12
   [$FF14] = $BF   ; NR14
   [$FF16] = $3F   ; NR21
   [$FF17] = $00   ; NR22
   [$FF19] = $BF   ; NR24
   [$FF1A] = $7F   ; NR30
   [$FF1B] = $FF   ; NR31
   [$FF1C] = $9F   ; NR32
   [$FF1E] = $BF   ; NR33
   [$FF20] = $FF   ; NR41
   [$FF21] = $00   ; NR42
   [$FF22] = $00   ; NR43
   [$FF23] = $BF   ; NR30
   [$FF24] = $77   ; NR50
   [$FF25] = $F3   ; NR51
   [$FF26] = $F1-GB, $F0-SGB ; NR52
   [$FF40] = $91   ; LCDC
   [$FF42] = $00   ; SCY
   [$FF43] = $00   ; SCX
   [$FF45] = $00   ; LYC
   [$FF47] = $FC   ; BGP
   [$FF48] = $FF   ; OBP0
   [$FF49] = $FF   ; OBP1
   [$FF4A] = $00   ; WY
   [$FF4B] = $00   ; WX
   [$FFFF] = $00   ; IE


It is not a good idea to assume the above values will always exist. A later version GameBoy could contain different values than these at reset. Always set these registers on reset rather than assume they are as above.

Please note that GameBoy internal RAM on power up contains random data. All of the GameBoy emulators tend to set all RAM to value $00 on entry.

Cart RAM the first time it is accessed on a real GameBoy contains random data. It will only contain known data if the GameBoy code initializes it to some value.</text>
      <sha1>bcv9dfri6d9v0oyd789yi9qkrtimbaa</sha1>
    </revision>
    <revision>
      <id>181</id>
      <parentid>162</parentid>
      <timestamp>2009-06-28T13:02:58Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2489">{{Pandocs|powerupsequence}}
When the GameBoy is powered up, a 256 byte program starting at memory location 0 is executed. This program is located in a ROM inside the GameBoy. The first thing the program does is read the cartridge locations from $104 to $133 and place this graphic of a Nintendo logo on the screen at the top. This image is then scrolled until it is in the middle of the screen. Two musical notes are then played on the internal speaker. Again, the cartridge locations $104 to $133 are read but this time they are compared with a table in the internal rom. If any byte fails to compare, then the GameBoy stops comparing bytes and simply halts all operations. If all locations compare the same, then the GameBoy starts adding all of the bytes in the cartridge from $134 to $14d. A value of 25 decimal is added to this total. If the least significant byte of the result is a not a zero, then the GameBoy will stop doing anything. If it is a zero, then the internal ROM is disabled and cartridge program execution begins at location $100 with the following register values:

   AF=$01B0
   BC=$0013
   DE=$00D8
   HL=$014D
   Stack Pointer=$FFFE
   [$FF05] = $00   ; TIMA
   [$FF06] = $00   ; TMA
   [$FF07] = $00   ; TAC
   [$FF10] = $80   ; NR10
   [$FF11] = $BF   ; NR11
   [$FF12] = $F3   ; NR12
   [$FF14] = $BF   ; NR14
   [$FF16] = $3F   ; NR21
   [$FF17] = $00   ; NR22
   [$FF19] = $BF   ; NR24
   [$FF1A] = $7F   ; NR30
   [$FF1B] = $FF   ; NR31
   [$FF1C] = $9F   ; NR32
   [$FF1E] = $BF   ; NR33
   [$FF20] = $FF   ; NR41
   [$FF21] = $00   ; NR42
   [$FF22] = $00   ; NR43
   [$FF23] = $BF   ; NR30
   [$FF24] = $77   ; NR50
   [$FF25] = $F3   ; NR51
   [$FF26] = $F1-GB, $F0-SGB ; NR52
   [$FF40] = $91   ; LCDC
   [$FF42] = $00   ; SCY
   [$FF43] = $00   ; SCX
   [$FF45] = $00   ; LYC
   [$FF47] = $FC   ; BGP
   [$FF48] = $FF   ; OBP0
   [$FF49] = $FF   ; OBP1
   [$FF4A] = $00   ; WY
   [$FF4B] = $00   ; WX
   [$FFFF] = $00   ; IE


It is not a good idea to assume the above values will always exist. A later version GameBoy could contain different values than these at reset. Always set these registers on reset rather than assume they are as above.

Please note that GameBoy internal RAM on power up contains random data. All of the GameBoy emulators tend to set all RAM to value $00 on entry.

Cart RAM the first time it is accessed on a real GameBoy contains random data. It will only contain known data if the GameBoy code initializes it to some value.</text>
      <sha1>hn1zl8xj3jbykwl16jc4fqu4nj75kjq</sha1>
    </revision>
    <revision>
      <id>792</id>
      <parentid>181</parentid>
      <timestamp>2018-05-25T17:39:28Z</timestamp>
      <contributor>
        <username>T4g1</username>
        <id>79</id>
      </contributor>
      <minor/>
      <comment>Labl error corrected</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2489">{{Pandocs|powerupsequence}}
When the GameBoy is powered up, a 256 byte program starting at memory location 0 is executed. This program is located in a ROM inside the GameBoy. The first thing the program does is read the cartridge locations from $104 to $133 and place this graphic of a Nintendo logo on the screen at the top. This image is then scrolled until it is in the middle of the screen. Two musical notes are then played on the internal speaker. Again, the cartridge locations $104 to $133 are read but this time they are compared with a table in the internal rom. If any byte fails to compare, then the GameBoy stops comparing bytes and simply halts all operations. If all locations compare the same, then the GameBoy starts adding all of the bytes in the cartridge from $134 to $14d. A value of 25 decimal is added to this total. If the least significant byte of the result is a not a zero, then the GameBoy will stop doing anything. If it is a zero, then the internal ROM is disabled and cartridge program execution begins at location $100 with the following register values:

   AF=$01B0
   BC=$0013
   DE=$00D8
   HL=$014D
   Stack Pointer=$FFFE
   [$FF05] = $00   ; TIMA
   [$FF06] = $00   ; TMA
   [$FF07] = $00   ; TAC
   [$FF10] = $80   ; NR10
   [$FF11] = $BF   ; NR11
   [$FF12] = $F3   ; NR12
   [$FF14] = $BF   ; NR14
   [$FF16] = $3F   ; NR21
   [$FF17] = $00   ; NR22
   [$FF19] = $BF   ; NR24
   [$FF1A] = $7F   ; NR30
   [$FF1B] = $FF   ; NR31
   [$FF1C] = $9F   ; NR32
   [$FF1E] = $BF   ; NR33
   [$FF20] = $FF   ; NR41
   [$FF21] = $00   ; NR42
   [$FF22] = $00   ; NR43
   [$FF23] = $BF   ; NR44
   [$FF24] = $77   ; NR50
   [$FF25] = $F3   ; NR51
   [$FF26] = $F1-GB, $F0-SGB ; NR52
   [$FF40] = $91   ; LCDC
   [$FF42] = $00   ; SCY
   [$FF43] = $00   ; SCX
   [$FF45] = $00   ; LYC
   [$FF47] = $FC   ; BGP
   [$FF48] = $FF   ; OBP0
   [$FF49] = $FF   ; OBP1
   [$FF4A] = $00   ; WY
   [$FF4B] = $00   ; WX
   [$FFFF] = $00   ; IE


It is not a good idea to assume the above values will always exist. A later version GameBoy could contain different values than these at reset. Always set these registers on reset rather than assume they are as above.

Please note that GameBoy internal RAM on power up contains random data. All of the GameBoy emulators tend to set all RAM to value $00 on entry.

Cart RAM the first time it is accessed on a real GameBoy contains random data. It will only contain known data if the GameBoy code initializes it to some value.</text>
      <sha1>16vvwsiw3xzvi1utcfapxp0nzfz485h</sha1>
    </revision>
  </page>
  <page>
    <title>Reducing Power Consumption</title>
    <ns>0</ns>
    <id>59</id>
    <revision>
      <id>163</id>
      <timestamp>2009-06-28T11:08:52Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: The following can be used to recude the power consumption of the gameboy, and to extend the life of the batteries.  == PWR Using the HALT Instruction ==  It is recommended that the HALT in...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3413">The following can be used to recude the power consumption of the gameboy, and to extend the life of the batteries.

== PWR Using the HALT Instruction ==

It is recommended that the HALT instruction be used whenever possible to reduce power consumption &amp; extend the life of the batteries. This command stops the system clock reducing the power consumption of both the CPU and ROM.

The CPU will remain suspended until an interrupt occurs at which point the interrupt is serviced and then the instruction immediately following the HALT is executed.

Depending on how much CPU time is required by a game, the HALT instruction can extend battery life anywhere from 5 to 50% or possibly more.

When waiting for a vblank event, this would be a BAD example:

  @@wait:
   ld   a,(0FF44h)      ;LY
   cp   a,144
   jr   nz,@@wait


A better example would be a procedure as shown below. In this case the vblank interrupt must be enabled, and your vblank interrupt procedure must set vblank_flag to a non-zero value.

   ld   hl,vblank_flag  ;hl=pointer to vblank_flag
   xor  a               ;a=0
  @@wait:               ;wait...
   halt                 ;suspend CPU - wait for ANY interrupt
   cp   a,(hl)          ;vblank flag still zero?
   jr   z,@@wait        ;wait more if zero
   ld   (hl),a          ;set vblank_flag back to zero

The vblank_flag is used to determine whether the HALT period has been terminated by a vblank interrupt, or by another interrupt. In case that your program has all other interrupts disabled, then it would be proof to replace the above procedure by a single HALT instruction.


== PWR Using the STOP Instruction ==

The STOP instruction is intended to switch the gameboy into VERY low power standby mode. For example, a program may use this feature when it hasn't sensed keyboard input for a longer period (assuming that somebody forgot to turn off the gameboy).

Before invoking STOP, it might be required to disable Sound and Video manually (as well as IR-link port in CGB). Much like HALT, the STOP state is terminated by interrupt events - in this case this would be commonly a joypad interrupt. The joypad register might be required to be prepared for STOP either.


== PWR Disabeling the Sound Controller ==

If your programs doesn't use sound at all (or during some periods) then write 00h to register FF26 to save 16% or more on GB power consumption.
Sound can be turned back on by writing 80h to the same register, all sound registers must be then re-initialized.
When the gameboy becomes turned on, sound is enabled by default, and must be turned off manually when not used.


== PWR Not using CGB Double Speed Mode ==

Because CGB Double Speed mode consumes more power, it'd be recommended to use normal speed when possible.
There's limited ability to switch between both speeds, for example, a game might use normal speed in the title screen, and double speed in the game, or vice versa.
However, during speed switch the display collapses for a short moment, so that it'd be no good idea to alter speeds within active game or title screen periods.


== PWR Using the Skills ==

Most of the above power saving methods will produce best results when using efficient and tight assembler code which requires as less CPU power as possible. Thus, experienced old-school programmers will (hopefully) produce lower power consumption, as than HLL-programming teenagers, for example.</text>
      <sha1>fc37wuv0zy6gvtjrbnzyn9xtxkpan4g</sha1>
    </revision>
    <revision>
      <id>182</id>
      <parentid>163</parentid>
      <timestamp>2009-06-28T13:03:25Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3450">{{Pandocs|reducingpowerconsumption}}
The following can be used to recude the power consumption of the gameboy, and to extend the life of the batteries.

== PWR Using the HALT Instruction ==

It is recommended that the HALT instruction be used whenever possible to reduce power consumption &amp; extend the life of the batteries. This command stops the system clock reducing the power consumption of both the CPU and ROM.

The CPU will remain suspended until an interrupt occurs at which point the interrupt is serviced and then the instruction immediately following the HALT is executed.

Depending on how much CPU time is required by a game, the HALT instruction can extend battery life anywhere from 5 to 50% or possibly more.

When waiting for a vblank event, this would be a BAD example:

  @@wait:
   ld   a,(0FF44h)      ;LY
   cp   a,144
   jr   nz,@@wait


A better example would be a procedure as shown below. In this case the vblank interrupt must be enabled, and your vblank interrupt procedure must set vblank_flag to a non-zero value.

   ld   hl,vblank_flag  ;hl=pointer to vblank_flag
   xor  a               ;a=0
  @@wait:               ;wait...
   halt                 ;suspend CPU - wait for ANY interrupt
   cp   a,(hl)          ;vblank flag still zero?
   jr   z,@@wait        ;wait more if zero
   ld   (hl),a          ;set vblank_flag back to zero

The vblank_flag is used to determine whether the HALT period has been terminated by a vblank interrupt, or by another interrupt. In case that your program has all other interrupts disabled, then it would be proof to replace the above procedure by a single HALT instruction.


== PWR Using the STOP Instruction ==

The STOP instruction is intended to switch the gameboy into VERY low power standby mode. For example, a program may use this feature when it hasn't sensed keyboard input for a longer period (assuming that somebody forgot to turn off the gameboy).

Before invoking STOP, it might be required to disable Sound and Video manually (as well as IR-link port in CGB). Much like HALT, the STOP state is terminated by interrupt events - in this case this would be commonly a joypad interrupt. The joypad register might be required to be prepared for STOP either.


== PWR Disabeling the Sound Controller ==

If your programs doesn't use sound at all (or during some periods) then write 00h to register FF26 to save 16% or more on GB power consumption.
Sound can be turned back on by writing 80h to the same register, all sound registers must be then re-initialized.
When the gameboy becomes turned on, sound is enabled by default, and must be turned off manually when not used.


== PWR Not using CGB Double Speed Mode ==

Because CGB Double Speed mode consumes more power, it'd be recommended to use normal speed when possible.
There's limited ability to switch between both speeds, for example, a game might use normal speed in the title screen, and double speed in the game, or vice versa.
However, during speed switch the display collapses for a short moment, so that it'd be no good idea to alter speeds within active game or title screen periods.


== PWR Using the Skills ==

Most of the above power saving methods will produce best results when using efficient and tight assembler code which requires as less CPU power as possible. Thus, experienced old-school programmers will (hopefully) produce lower power consumption, as than HLL-programming teenagers, for example.</text>
      <sha1>myamnx6l348dg74liso5bz3ileskurq</sha1>
    </revision>
    <revision>
      <id>422</id>
      <parentid>182</parentid>
      <timestamp>2011-03-16T16:59:23Z</timestamp>
      <contributor>
        <username>Tpw rules</username>
        <id>28</id>
      </contributor>
      <comment>Fixing spelling, doing some rephrasing</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3326">{{Pandocs|reducingpowerconsumption}}
The following programming techniques can be used to reduce the power consumption of the GameBoy hardware and extend the life of the batteries.

== Using the HALT Instruction ==

The HALT instruction should be used whenever possible to reduce power consumption &amp; extend the life of the batteries. This command stops the system clock, reducing the power consumption of both the CPU and ROM.

The CPU will remain stopped until an interrupt occurs at which point the interrupt is serviced and then the instruction immediately following the HALT is executed.

Depending on how much CPU time is required by a game, the HALT instruction can extend battery life anywhere from 5 to 50% or possibly more.

When waiting for a vblank event, this would be a BAD example:

  @@wait:
   ld   a,(0FF44h)      ;LY
   cp   a,144
   jr   nz,@@wait


A better example would be a procedure as shown below. In this case the vblank interrupt must be enabled, and your vblank interrupt procedure must set vblank_flag to a non-zero value.

   ld   hl,vblank_flag  ;hl=pointer to vblank_flag
   xor  a               ;a=0
  @@wait:               ;wait...
   halt                 ;suspend CPU - wait for ANY interrupt
   cp   a,(hl)          ;vblank flag still zero?
   jr   z,@@wait        ;wait more if zero
   ld   (hl),a          ;set vblank_flag back to zero

The vblank_flag is used to determine whether the HALT period has been terminated by a vblank interrupt, or by another interrupt. In case your program has all other interrupts disabled, then it would be okay to replace the above procedure by a single HALT instruction.


== Using the STOP Instruction ==

The STOP instruction is intended to switch the gameboy into VERY low power standby mode. For example, a program may use this feature when it hasn't sensed keyboard input for a longer period (for example, when somebody forgot to turn off the gameboy).

Before invoking STOP, it might be required to disable Sound and Video manually (as well as IR-link port in CGB). Much like HALT, the STOP state is terminated by interrupt events. STOP is commonly terminated with a joypad interrupt.


== Disabling the Sound Controller ==

If your program doesn't use sound at all (or during some periods) then write 00h to register FF26 to save 16% or more on GB power consumption.
Sound can be turned back on by writing 80h to the same register, all sound registers must be then re-initialized.
When the gameboy is turned on, sound is enabled by default, and must be turned off manually when not used.


== Not using CGB Double Speed Mode ==

Because CGB Double Speed mode consumes more power, it's recommended to use normal speed when possible.
There's limited ability to switch between both speeds, for example, a game might use normal speed in the title screen, and double speed in the game, or vice versa.
However, during speed switch, the display collapses for a short moment, so it's not a good idea to alter speeds within active game or title screen periods.


== Using the Skills ==

Most of the above power saving methods will produce best results when using efficient and tight assembler code which requires as little CPU power as possible. Using a high level language will require more CPU power and these techniques will not have as big as an effect.</text>
      <sha1>jaqq9zrok6cfc2pn90oic7ic7qjhloe</sha1>
    </revision>
    <revision>
      <id>609</id>
      <parentid>422</parentid>
      <timestamp>2015-12-15T20:22:48Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* Using the HALT Instruction */ Added a way of waiting a single frame, which I use in my game. Tested it, it works fine. Also added a note to remember that the interrupt routines MUST enable interrupts during / after execution.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3730">{{Pandocs|reducingpowerconsumption}}
The following programming techniques can be used to reduce the power consumption of the GameBoy hardware and extend the life of the batteries.

== Using the HALT Instruction ==

The HALT instruction should be used whenever possible to reduce power consumption &amp; extend the life of the batteries. This command stops the system clock, reducing the power consumption of both the CPU and ROM.

The CPU will remain stopped until an interrupt occurs at which point the interrupt is serviced and then the instruction immediately following the HALT is executed.

Depending on how much CPU time is required by a game, the HALT instruction can extend battery life anywhere from 5 to 50% or possibly more.

When waiting for a vblank event, this would be a BAD example:

  @@wait:
   ld   a,(0FF44h)      ;LY
   cp   a,144
   jr   nz,@@wait


A better example would be a procedure as shown below. In this case the vblank interrupt must be enabled, and your vblank interrupt procedure must set vblank_flag to a non-zero value.

   ld   hl,vblank_flag  ;hl=pointer to vblank_flag
   xor  a               ;a=0
  @@wait:               ;wait...
   halt                 ;suspend CPU - wait for ANY interrupt
   cp   a,(hl)          ;vblank flag still zero?
   jr   z,@@wait        ;wait more if zero
   ld   (hl),a          ;set vblank_flag back to zero

The vblank_flag is used to determine whether the HALT period has been terminated by a vblank interrupt, or by another interrupt. In case your program has all other interrupts disabled, then it would be okay to replace the above procedure by a single HALT instruction.


Another possibility is, if your game uses no other interrupt than VBlank (or uses no interrupt), to only enable VBlank interrupts and simply use a halt instruction, which will only resume main code execution when a VBlank occurs.



Remember when using HALT to wait between VBlanks, your interrupt routines MUST enable interrupts (ie with ei during the execution, or better, using the RETI instruction)

== Using the STOP Instruction ==

The STOP instruction is intended to switch the gameboy into VERY low power standby mode. For example, a program may use this feature when it hasn't sensed keyboard input for a longer period (for example, when somebody forgot to turn off the gameboy).

Before invoking STOP, it might be required to disable Sound and Video manually (as well as IR-link port in CGB). Much like HALT, the STOP state is terminated by interrupt events. STOP is commonly terminated with a joypad interrupt.


== Disabling the Sound Controller ==

If your program doesn't use sound at all (or during some periods) then write 00h to register FF26 to save 16% or more on GB power consumption.
Sound can be turned back on by writing 80h to the same register, all sound registers must be then re-initialized.
When the gameboy is turned on, sound is enabled by default, and must be turned off manually when not used.


== Not using CGB Double Speed Mode ==

Because CGB Double Speed mode consumes more power, it's recommended to use normal speed when possible.
There's limited ability to switch between both speeds, for example, a game might use normal speed in the title screen, and double speed in the game, or vice versa.
However, during speed switch, the display collapses for a short moment, so it's not a good idea to alter speeds within active game or title screen periods.


== Using the Skills ==

Most of the above power saving methods will produce best results when using efficient and tight assembler code which requires as little CPU power as possible. Using a high level language will require more CPU power and these techniques will not have as big as an effect.</text>
      <sha1>32cfkzo1srrjv7wxrp7fjktt1a8fftw</sha1>
    </revision>
    <revision>
      <id>612</id>
      <parentid>609</parentid>
      <timestamp>2015-12-15T22:36:39Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <minor/>
      <comment>/* Using the STOP Instruction */ Added a precision about the impact of the STOP instruction on user experience.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3821">{{Pandocs|reducingpowerconsumption}}
The following programming techniques can be used to reduce the power consumption of the GameBoy hardware and extend the life of the batteries.

== Using the HALT Instruction ==

The HALT instruction should be used whenever possible to reduce power consumption &amp; extend the life of the batteries. This command stops the system clock, reducing the power consumption of both the CPU and ROM.

The CPU will remain stopped until an interrupt occurs at which point the interrupt is serviced and then the instruction immediately following the HALT is executed.

Depending on how much CPU time is required by a game, the HALT instruction can extend battery life anywhere from 5 to 50% or possibly more.

When waiting for a vblank event, this would be a BAD example:

  @@wait:
   ld   a,(0FF44h)      ;LY
   cp   a,144
   jr   nz,@@wait


A better example would be a procedure as shown below. In this case the vblank interrupt must be enabled, and your vblank interrupt procedure must set vblank_flag to a non-zero value.

   ld   hl,vblank_flag  ;hl=pointer to vblank_flag
   xor  a               ;a=0
  @@wait:               ;wait...
   halt                 ;suspend CPU - wait for ANY interrupt
   cp   a,(hl)          ;vblank flag still zero?
   jr   z,@@wait        ;wait more if zero
   ld   (hl),a          ;set vblank_flag back to zero

The vblank_flag is used to determine whether the HALT period has been terminated by a vblank interrupt, or by another interrupt. In case your program has all other interrupts disabled, then it would be okay to replace the above procedure by a single HALT instruction.


Another possibility is, if your game uses no other interrupt than VBlank (or uses no interrupt), to only enable VBlank interrupts and simply use a halt instruction, which will only resume main code execution when a VBlank occurs.



Remember when using HALT to wait between VBlanks, your interrupt routines MUST enable interrupts (ie with ei during the execution, or better, using the RETI instruction)

== Using the STOP Instruction ==

The STOP instruction is intended to switch the gameboy into VERY low power standby mode. For example, a program may use this feature when it hasn't sensed keyboard input for a longer period (for example, when somebody forgot to turn off the gameboy).

Before invoking STOP, it might be required to disable Sound and Video manually (as well as IR-link port in CGB). Much like HALT, the STOP state is terminated by interrupt events. STOP is commonly terminated with a joypad interrupt.

During STOP mode, the display will turn white, so avoid using it in your game's main loop.

== Disabling the Sound Controller ==

If your program doesn't use sound at all (or during some periods) then write 00h to register FF26 to save 16% or more on GB power consumption.
Sound can be turned back on by writing 80h to the same register, all sound registers must be then re-initialized.
When the gameboy is turned on, sound is enabled by default, and must be turned off manually when not used.


== Not using CGB Double Speed Mode ==

Because CGB Double Speed mode consumes more power, it's recommended to use normal speed when possible.
There's limited ability to switch between both speeds, for example, a game might use normal speed in the title screen, and double speed in the game, or vice versa.
However, during speed switch, the display collapses for a short moment, so it's not a good idea to alter speeds within active game or title screen periods.


== Using the Skills ==

Most of the above power saving methods will produce best results when using efficient and tight assembler code which requires as little CPU power as possible. Using a high level language will require more CPU power and these techniques will not have as big as an effect.</text>
      <sha1>n50rt6bbdlk6ncdtu4ar1t20vsuaqh6</sha1>
    </revision>
    <revision>
      <id>613</id>
      <parentid>612</parentid>
      <timestamp>2015-12-15T22:39:52Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <comment>/* Using the Skills */ Added a link to a wiki page helping finding optimizations, although designed for the Z80 and not for the GBZ80. May still be useful, though.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4047">{{Pandocs|reducingpowerconsumption}}
The following programming techniques can be used to reduce the power consumption of the GameBoy hardware and extend the life of the batteries.

== Using the HALT Instruction ==

The HALT instruction should be used whenever possible to reduce power consumption &amp; extend the life of the batteries. This command stops the system clock, reducing the power consumption of both the CPU and ROM.

The CPU will remain stopped until an interrupt occurs at which point the interrupt is serviced and then the instruction immediately following the HALT is executed.

Depending on how much CPU time is required by a game, the HALT instruction can extend battery life anywhere from 5 to 50% or possibly more.

When waiting for a vblank event, this would be a BAD example:

  @@wait:
   ld   a,(0FF44h)      ;LY
   cp   a,144
   jr   nz,@@wait


A better example would be a procedure as shown below. In this case the vblank interrupt must be enabled, and your vblank interrupt procedure must set vblank_flag to a non-zero value.

   ld   hl,vblank_flag  ;hl=pointer to vblank_flag
   xor  a               ;a=0
  @@wait:               ;wait...
   halt                 ;suspend CPU - wait for ANY interrupt
   cp   a,(hl)          ;vblank flag still zero?
   jr   z,@@wait        ;wait more if zero
   ld   (hl),a          ;set vblank_flag back to zero

The vblank_flag is used to determine whether the HALT period has been terminated by a vblank interrupt, or by another interrupt. In case your program has all other interrupts disabled, then it would be okay to replace the above procedure by a single HALT instruction.


Another possibility is, if your game uses no other interrupt than VBlank (or uses no interrupt), to only enable VBlank interrupts and simply use a halt instruction, which will only resume main code execution when a VBlank occurs.



Remember when using HALT to wait between VBlanks, your interrupt routines MUST enable interrupts (ie with ei during the execution, or better, using the RETI instruction)

== Using the STOP Instruction ==

The STOP instruction is intended to switch the gameboy into VERY low power standby mode. For example, a program may use this feature when it hasn't sensed keyboard input for a longer period (for example, when somebody forgot to turn off the gameboy).

Before invoking STOP, it might be required to disable Sound and Video manually (as well as IR-link port in CGB). Much like HALT, the STOP state is terminated by interrupt events. STOP is commonly terminated with a joypad interrupt.

During STOP mode, the display will turn white, so avoid using it in your game's main loop.

== Disabling the Sound Controller ==

If your program doesn't use sound at all (or during some periods) then write 00h to register FF26 to save 16% or more on GB power consumption.
Sound can be turned back on by writing 80h to the same register, all sound registers must be then re-initialized.
When the gameboy is turned on, sound is enabled by default, and must be turned off manually when not used.


== Not using CGB Double Speed Mode ==

Because CGB Double Speed mode consumes more power, it's recommended to use normal speed when possible.
There's limited ability to switch between both speeds, for example, a game might use normal speed in the title screen, and double speed in the game, or vice versa.
However, during speed switch, the display collapses for a short moment, so it's not a good idea to alter speeds within active game or title screen periods.


== Using the Skills ==

Most of the above power saving methods will produce best results when using efficient and tight assembler code which requires as little CPU power as possible. Using a high level language will require more CPU power and these techniques will not have as big as an effect.

To optimize you code, it might be a good idea to look at [http://wikiti.brandonw.net/index.php?title=Z80_Optimization this page], although it applies to the original Z80 CPU, so one must adapt the optimizations to the GBZ80.</text>
      <sha1>cjn8onxk5clvktmucrelh4vcpnca252</sha1>
    </revision>
  </page>
  <page>
    <title>Sprite RAM Bug</title>
    <ns>0</ns>
    <id>60</id>
    <revision>
      <id>164</id>
      <timestamp>2009-06-28T11:09:13Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: There is a flaw in the GameBoy hardware that causes trash to be written to OAM RAM if the following commands are used while their 16-bit content is in the range of $FE00 to $FEFF:    inc r...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="361">There is a flaw in the GameBoy hardware that causes trash to be written to OAM RAM if the following commands are used while their 16-bit content is in the range of $FE00 to $FEFF:

  inc rr        dec rr          ;rr = bc,de, or hl
  ldi a,(hl)    ldd a,(hl)
  ldi (hl),a    ldd (hl),a

Only sprites 1 &amp; 2 ($FE00 &amp; $FE04) are not affected by these instructions.</text>
      <sha1>mwtwyy0jmlyfh4i72tnwzccj2kxuqme</sha1>
    </revision>
    <revision>
      <id>183</id>
      <parentid>164</parentid>
      <timestamp>2009-06-28T13:04:02Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="386">{{Pandocs|spriterambug}}
There is a flaw in the GameBoy hardware that causes trash to be written to OAM RAM if the following commands are used while their 16-bit content is in the range of $FE00 to $FEFF:

  inc rr        dec rr          ;rr = bc,de, or hl
  ldi a,(hl)    ldd a,(hl)
  ldi (hl),a    ldd (hl),a

Only sprites 1 &amp; 2 ($FE00 &amp; $FE04) are not affected by these instructions.</text>
      <sha1>29sq2hveoe5yse6zlj3is7xyt8w8am7</sha1>
    </revision>
    <revision>
      <id>751</id>
      <parentid>183</parentid>
      <timestamp>2017-05-10T01:27:36Z</timestamp>
      <contributor>
        <username>ISSOtm</username>
        <id>58</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="444">{{Pandocs|spriterambug}}
There is a flaw in the GameBoy hardware that causes trash to be written to OAM RAM if the following commands are used while their 16-bit content is in the range of $FE00 to $FEFF:

  inc rr        dec rr          ;rr = bc,de, or hl
  ldi a,(hl)    ldd a,(hl)
  ldi (hl),a    ldd (hl),a

Only sprites 1 &amp; 2 ($FE00 &amp; $FE04) are not affected by these instructions.

Game Boy Color and Advance are not affected by this bug.</text>
      <sha1>1r62nxag3liounosdxe74jqpxg8l7gd</sha1>
    </revision>
    <revision>
      <id>891</id>
      <parentid>751</parentid>
      <timestamp>2019-07-19T11:05:44Z</timestamp>
      <contributor>
        <username>LIJI</username>
        <id>43</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4836">{{Pandocs|spriterambug}}
There is a flaw in the Game Boy hardware that causes trash to be written to OAM RAM if the following commands are used while their 16-bit content is in the range of $FE00 to $FEFF while the PPU is in mode 2:

  inc rr        dec rr          ;rr = bc,de, or hl
  ldi a,(hl)    ldd a,(hl)
  ldi (hl),a    ldd (hl),a

Sprites 1 &amp; 2 ($FE00 &amp; $FE04) are not affected by this bug.

Game Boy Color and Advance are not affected by this bug.

== Accurate Description ==

The Sprite RAM Bug (or OAM Bug) actually consists  of two different bugs:

* Attempting to read or write from OAM (Including the #FFA0-$FEFF region) while the PPU is in mode 2 (OAM mode) will corrupt it.
* Performing an increase or decrease operation on any 16-bit register (BC, DE, HL, SP or PC) while that register is in the OAM range ($FE00 - $FEFF) will trigger a memory write to OAM, causing a corruption.

=== Affected Operations ===

The following operations are affected by this bug:

* Any memory access instruction, if it accesses OAM
* &lt;code&gt;inc rr&lt;/code&gt;, &lt;code&gt;dec rr&lt;/code&gt; - if &lt;code&gt;rr&lt;/code&gt; is a 16-bit register pointing to OAM, it will trigger a write and corrupt OAM
* &lt;code&gt;ldi [hl], a&lt;/code&gt;, &lt;code&gt;ldd [hl], a&lt;/code&gt;, &lt;code&gt;ldi a, [hl]&lt;/code&gt;, &lt;code&gt;ldd a, [hl]&lt;/code&gt;- these will trigger a corruption twice if &lt;code&gt;hl&lt;/code&gt; points to OAM; once for the usual memory access, and once for the extra write trigger by the inc/dec
* &lt;code&gt;pop rr&lt;/code&gt;, the &lt;code&gt;ret&lt;/code&gt; family - For some reason, pop will trigger the bug only 3 times (instead of the expected 4 times); one read, one glitched write, and another read without a glitched write. This also applies to the ret instructions.
* &lt;code&gt;push rr&lt;/code&gt;, the &lt;code&gt;call&lt;/code&gt; family, &lt;code&gt;rst xx&lt;/code&gt; and interrupt handling - Pushing to the stack will trigger the bug 4 times; two usual writes and two glitched write caused by the decrease. However, since one glitched write occur in the same cycle as a actual write, this will effectively behave like 3 writes.
* Executing code from OAM - If PC is inside OAM (executing FF, i.e.&lt;code&gt;rst $38&lt;/code&gt;) the bug will trigger twice, once for increasing PC inside OAM (triggering a write), and once for reading from OAM. If a multi-byte opcode is executed from $FDFF or $FDFE, and bug will similarly trigger twice for every read from OAM.

=== Corruption Patterns ===

The OAM is split into 20 rows of 8 bytes each, and during mode 2 the PPU reads those rows consecutively; one every 1 M-cycle. The operations patterns rely on type of operation (read/write/both) used on OAM during that M-cycle, as well as the row currently accessed by the PPU. The actual read/write address used, or the written value have no effect. Additionally, keep in mind that OAM uses a 16-bit data bus, so all operations are on 16-bit words.

==== Write Corruption ====

A write corruption corrupts the currently access row in the following manner, as long as it's not the first row (containing the first two sprites):

* The first word in the row is replaced with this bitwise expression: &lt;code&gt;((a ^ c) &amp; (b ^ c)) ^ c&lt;code&gt;, where &lt;code&gt;a&lt;/code&gt; is the original value of that word, &lt;code&gt;b&lt;/code&gt; is the first word in the preceding row, and &lt;code&gt;c&lt;/code&gt; is the third word in the preceding row.
* The last three words are copied from the last three words in the preceding row.

==== Read Corruption ====

A read corruption works similarly to a write corruption, except the bitwise expression is &lt;code&gt;b | (a &amp; c)&lt;/code&gt;.

==== Write During Increase/Decrease ====

If a register is increased or decreased in the same M cycle of a write, this will effectively trigger two writes in a single M-cycle. However, this case behaves just like a single write.

==== Read During Increase/Decrease ====

If a register is increased or decreased in the same M cycle of a write, this will effectively trigger both a read '''and''' a write in a single M-cycle, resulting in a more complex corruption pattern:

* This corruption will not happen if the accessed row is one of the first four, as well as if it's the last row:
** The first word in the row preceding the currently accessed row is replaced with the following bitwise expression: &lt;code&gt;(b &amp; (a | c | d)) | (a &amp; c &amp; d)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the first word two rows before the currently accessed row, &lt;code&gt;b&lt;/code&gt; is the first word in the preceding row (the word being corrupted), &lt;code&gt;c&lt;/code&gt; is the first word in the currently accessed row, and &lt;code&gt;d&lt;/code&gt; is the third word in the preceding row.
** The contents of the preceding row is copied (after the corruption of the first word in it) both to the currently accessed row and to two rows before the currently accessed row
* Regardless of wether the previous corruption occurred or not, a normal read corruption is then applied.</text>
      <sha1>k5plrpf5ws33bhhe2vamlsxx986yva7</sha1>
    </revision>
    <revision>
      <id>892</id>
      <parentid>891</parentid>
      <timestamp>2019-07-19T11:08:42Z</timestamp>
      <contributor>
        <username>LIJI</username>
        <id>43</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4836">{{Pandocs|spriterambug}}
There is a flaw in the Game Boy hardware that causes trash to be written to OAM RAM if the following commands are used while their 16-bit content is in the range of $FE00 to $FEFF while the PPU is in mode 2:

  inc rr        dec rr          ;rr = bc,de, or hl
  ldi a,(hl)    ldd a,(hl)
  ldi (hl),a    ldd (hl),a

Sprites 1 &amp; 2 ($FE00 &amp; $FE04) are not affected by this bug.

Game Boy Color and Advance are not affected by this bug.

== Accurate Description ==

The Sprite RAM Bug (or OAM Bug) actually consists  of two different bugs:

* Attempting to read or write from OAM (Including the $FFA0-$FEFF region) while the PPU is in mode 2 (OAM mode) will corrupt it.
* Performing an increase or decrease operation on any 16-bit register (BC, DE, HL, SP or PC) while that register is in the OAM range ($FE00 - $FEFF) will trigger a memory write to OAM, causing a corruption.

=== Affected Operations ===

The following operations are affected by this bug:

* Any memory access instruction, if it accesses OAM
* &lt;code&gt;inc rr&lt;/code&gt;, &lt;code&gt;dec rr&lt;/code&gt; - if &lt;code&gt;rr&lt;/code&gt; is a 16-bit register pointing to OAM, it will trigger a write and corrupt OAM
* &lt;code&gt;ldi [hl], a&lt;/code&gt;, &lt;code&gt;ldd [hl], a&lt;/code&gt;, &lt;code&gt;ldi a, [hl]&lt;/code&gt;, &lt;code&gt;ldd a, [hl]&lt;/code&gt;- these will trigger a corruption twice if &lt;code&gt;hl&lt;/code&gt; points to OAM; once for the usual memory access, and once for the extra write trigger by the inc/dec
* &lt;code&gt;pop rr&lt;/code&gt;, the &lt;code&gt;ret&lt;/code&gt; family - For some reason, pop will trigger the bug only 3 times (instead of the expected 4 times); one read, one glitched write, and another read without a glitched write. This also applies to the ret instructions.
* &lt;code&gt;push rr&lt;/code&gt;, the &lt;code&gt;call&lt;/code&gt; family, &lt;code&gt;rst xx&lt;/code&gt; and interrupt handling - Pushing to the stack will trigger the bug 4 times; two usual writes and two glitched write caused by the decrease. However, since one glitched write occur in the same cycle as a actual write, this will effectively behave like 3 writes.
* Executing code from OAM - If PC is inside OAM (executing FF, i.e.&lt;code&gt;rst $38&lt;/code&gt;) the bug will trigger twice, once for increasing PC inside OAM (triggering a write), and once for reading from OAM. If a multi-byte opcode is executed from $FDFF or $FDFE, and bug will similarly trigger twice for every read from OAM.

=== Corruption Patterns ===

The OAM is split into 20 rows of 8 bytes each, and during mode 2 the PPU reads those rows consecutively; one every 1 M-cycle. The operations patterns rely on type of operation (read/write/both) used on OAM during that M-cycle, as well as the row currently accessed by the PPU. The actual read/write address used, or the written value have no effect. Additionally, keep in mind that OAM uses a 16-bit data bus, so all operations are on 16-bit words.

==== Write Corruption ====

A write corruption corrupts the currently access row in the following manner, as long as it's not the first row (containing the first two sprites):

* The first word in the row is replaced with this bitwise expression: &lt;code&gt;((a ^ c) &amp; (b ^ c)) ^ c&lt;code&gt;, where &lt;code&gt;a&lt;/code&gt; is the original value of that word, &lt;code&gt;b&lt;/code&gt; is the first word in the preceding row, and &lt;code&gt;c&lt;/code&gt; is the third word in the preceding row.
* The last three words are copied from the last three words in the preceding row.

==== Read Corruption ====

A read corruption works similarly to a write corruption, except the bitwise expression is &lt;code&gt;b | (a &amp; c)&lt;/code&gt;.

==== Write During Increase/Decrease ====

If a register is increased or decreased in the same M cycle of a write, this will effectively trigger two writes in a single M-cycle. However, this case behaves just like a single write.

==== Read During Increase/Decrease ====

If a register is increased or decreased in the same M cycle of a write, this will effectively trigger both a read '''and''' a write in a single M-cycle, resulting in a more complex corruption pattern:

* This corruption will not happen if the accessed row is one of the first four, as well as if it's the last row:
** The first word in the row preceding the currently accessed row is replaced with the following bitwise expression: &lt;code&gt;(b &amp; (a | c | d)) | (a &amp; c &amp; d)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the first word two rows before the currently accessed row, &lt;code&gt;b&lt;/code&gt; is the first word in the preceding row (the word being corrupted), &lt;code&gt;c&lt;/code&gt; is the first word in the currently accessed row, and &lt;code&gt;d&lt;/code&gt; is the third word in the preceding row.
** The contents of the preceding row is copied (after the corruption of the first word in it) both to the currently accessed row and to two rows before the currently accessed row
* Regardless of wether the previous corruption occurred or not, a normal read corruption is then applied.</text>
      <sha1>pbyawivs4xefbhmx94v207x7jja6yg0</sha1>
    </revision>
    <revision>
      <id>893</id>
      <parentid>892</parentid>
      <timestamp>2019-07-19T11:09:12Z</timestamp>
      <contributor>
        <username>LIJI</username>
        <id>43</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4837">{{Pandocs|spriterambug}}
There is a flaw in the Game Boy hardware that causes trash to be written to OAM RAM if the following commands are used while their 16-bit content is in the range of $FE00 to $FEFF while the PPU is in mode 2:

  inc rr        dec rr          ;rr = bc,de, or hl
  ldi a,(hl)    ldd a,(hl)
  ldi (hl),a    ldd (hl),a

Sprites 1 &amp; 2 ($FE00 &amp; $FE04) are not affected by this bug.

Game Boy Color and Advance are not affected by this bug.

== Accurate Description ==

The Sprite RAM Bug (or OAM Bug) actually consists  of two different bugs:

* Attempting to read or write from OAM (Including the $FFA0-$FEFF region) while the PPU is in mode 2 (OAM mode) will corrupt it.
* Performing an increase or decrease operation on any 16-bit register (BC, DE, HL, SP or PC) while that register is in the OAM range ($FE00 - $FEFF) will trigger a memory write to OAM, causing a corruption.

=== Affected Operations ===

The following operations are affected by this bug:

* Any memory access instruction, if it accesses OAM
* &lt;code&gt;inc rr&lt;/code&gt;, &lt;code&gt;dec rr&lt;/code&gt; - if &lt;code&gt;rr&lt;/code&gt; is a 16-bit register pointing to OAM, it will trigger a write and corrupt OAM
* &lt;code&gt;ldi [hl], a&lt;/code&gt;, &lt;code&gt;ldd [hl], a&lt;/code&gt;, &lt;code&gt;ldi a, [hl]&lt;/code&gt;, &lt;code&gt;ldd a, [hl]&lt;/code&gt;- these will trigger a corruption twice if &lt;code&gt;hl&lt;/code&gt; points to OAM; once for the usual memory access, and once for the extra write trigger by the inc/dec
* &lt;code&gt;pop rr&lt;/code&gt;, the &lt;code&gt;ret&lt;/code&gt; family - For some reason, pop will trigger the bug only 3 times (instead of the expected 4 times); one read, one glitched write, and another read without a glitched write. This also applies to the ret instructions.
* &lt;code&gt;push rr&lt;/code&gt;, the &lt;code&gt;call&lt;/code&gt; family, &lt;code&gt;rst xx&lt;/code&gt; and interrupt handling - Pushing to the stack will trigger the bug 4 times; two usual writes and two glitched write caused by the decrease. However, since one glitched write occur in the same cycle as a actual write, this will effectively behave like 3 writes.
* Executing code from OAM - If PC is inside OAM (executing FF, i.e.&lt;code&gt;rst $38&lt;/code&gt;) the bug will trigger twice, once for increasing PC inside OAM (triggering a write), and once for reading from OAM. If a multi-byte opcode is executed from $FDFF or $FDFE, and bug will similarly trigger twice for every read from OAM.

=== Corruption Patterns ===

The OAM is split into 20 rows of 8 bytes each, and during mode 2 the PPU reads those rows consecutively; one every 1 M-cycle. The operations patterns rely on type of operation (read/write/both) used on OAM during that M-cycle, as well as the row currently accessed by the PPU. The actual read/write address used, or the written value have no effect. Additionally, keep in mind that OAM uses a 16-bit data bus, so all operations are on 16-bit words.

==== Write Corruption ====

A write corruption corrupts the currently access row in the following manner, as long as it's not the first row (containing the first two sprites):

* The first word in the row is replaced with this bitwise expression: &lt;code&gt;((a ^ c) &amp; (b ^ c)) ^ c&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is the original value of that word, &lt;code&gt;b&lt;/code&gt; is the first word in the preceding row, and &lt;code&gt;c&lt;/code&gt; is the third word in the preceding row.
* The last three words are copied from the last three words in the preceding row.

==== Read Corruption ====

A read corruption works similarly to a write corruption, except the bitwise expression is &lt;code&gt;b | (a &amp; c)&lt;/code&gt;.

==== Write During Increase/Decrease ====

If a register is increased or decreased in the same M cycle of a write, this will effectively trigger two writes in a single M-cycle. However, this case behaves just like a single write.

==== Read During Increase/Decrease ====

If a register is increased or decreased in the same M cycle of a write, this will effectively trigger both a read '''and''' a write in a single M-cycle, resulting in a more complex corruption pattern:

* This corruption will not happen if the accessed row is one of the first four, as well as if it's the last row:
** The first word in the row preceding the currently accessed row is replaced with the following bitwise expression: &lt;code&gt;(b &amp; (a | c | d)) | (a &amp; c &amp; d)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the first word two rows before the currently accessed row, &lt;code&gt;b&lt;/code&gt; is the first word in the preceding row (the word being corrupted), &lt;code&gt;c&lt;/code&gt; is the first word in the currently accessed row, and &lt;code&gt;d&lt;/code&gt; is the third word in the preceding row.
** The contents of the preceding row is copied (after the corruption of the first word in it) both to the currently accessed row and to two rows before the currently accessed row
* Regardless of wether the previous corruption occurred or not, a normal read corruption is then applied.</text>
      <sha1>j8v4i0knlv584502ibgmcp7vzt8txbb</sha1>
    </revision>
  </page>
  <page>
    <title>External Connectors</title>
    <ns>0</ns>
    <id>61</id>
    <revision>
      <id>165</id>
      <timestamp>2009-06-28T11:09:49Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <comment>New page: ===Cartridge Slot===    Pin   Name    Expl.   1     VDD     Power Supply +5V DC   2     PHI     System Clock   3     /WR     Write   4     /RD     Read   5     /CS     Chip Select   6-21  ...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1142">===Cartridge Slot===

  Pin   Name    Expl.
  1     VDD     Power Supply +5V DC
  2     PHI     System Clock
  3     /WR     Write
  4     /RD     Read
  5     /CS     Chip Select
  6-21  A0-A15  Address Lines
  22-29 D0-D7   Data Lines
  30    /RES    Reset signal
  31    VIN     External Sound Input
  32    GND     Ground


===Link Port===
Pin numbers are arranged as 2,4,6 in upper row, 1,3,5 un lower row; outside view of gameboy socket; flat side of socket upside.
Colors as used in most or all standard link cables, because SIN and SOUT are crossed, colors Red and Orange are exchanged at one cable end.

  Pin Name Color  Expl.
  1   VCC  -      +5V DC
  2   SOUT red    Data Out
  3   SIN  orange Data In
  4   P14  -      Not used
  5   SCK  green  Shift Clock
  6   GND  blue   Ground

Note: The original gameboy used larger plugs (unlike pocket gameboys and newer), linking between older/newer gameboys is possible by using cables with one large and one small plug though.

===Stereo Sound Connector (3.5mm, female)===

  Pin     Expl.
  Tip     Sound Left
  Middle  Sound Right
  Base    Ground


===External Power Supply===
...</text>
      <sha1>r5jinzkapa717lzautmrs38gnzd3v1b</sha1>
    </revision>
    <revision>
      <id>184</id>
      <parentid>165</parentid>
      <timestamp>2009-06-28T13:05:37Z</timestamp>
      <contributor>
        <username>Xzakox</username>
        <id>16</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1173">{{Pandocs|externalconnectors}}
===Cartridge Slot===

  Pin   Name    Expl.
  1     VDD     Power Supply +5V DC
  2     PHI     System Clock
  3     /WR     Write
  4     /RD     Read
  5     /CS     Chip Select
  6-21  A0-A15  Address Lines
  22-29 D0-D7   Data Lines
  30    /RES    Reset signal
  31    VIN     External Sound Input
  32    GND     Ground


===Link Port===
Pin numbers are arranged as 2,4,6 in upper row, 1,3,5 un lower row; outside view of gameboy socket; flat side of socket upside.
Colors as used in most or all standard link cables, because SIN and SOUT are crossed, colors Red and Orange are exchanged at one cable end.

  Pin Name Color  Expl.
  1   VCC  -      +5V DC
  2   SOUT red    Data Out
  3   SIN  orange Data In
  4   P14  -      Not used
  5   SCK  green  Shift Clock
  6   GND  blue   Ground

Note: The original gameboy used larger plugs (unlike pocket gameboys and newer), linking between older/newer gameboys is possible by using cables with one large and one small plug though.

===Stereo Sound Connector (3.5mm, female)===

  Pin     Expl.
  Tip     Sound Left
  Middle  Sound Right
  Base    Ground


===External Power Supply===
...</text>
      <sha1>m1tcxd7ddpv5ntm59vk0yhr53ojx1au</sha1>
    </revision>
  </page>
  <page>
    <title>MBC5</title>
    <ns>0</ns>
    <id>74</id>
    <revision>
      <id>251</id>
      <timestamp>2010-03-15T01:59:09Z</timestamp>
      <contributor>
        <username>Nitro2k01</username>
        <id>1</id>
      </contributor>
      <comment>Created page with '==Overview== MBC5 (Memory Bank Controller 5) is the 4th generation MBC. There apparently was no MBC4, presumably because of the superstition about the number 4 in Japanese cultur…'</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="488">==Overview==
MBC5 (Memory Bank Controller 5) is the 4th generation MBC. There apparently was no MBC4, presumably because of the superstition about the number 4 in Japanese culture. It is the first MBC that is guranteed to work properly with [[CGB-001|GBC]] [[CGB_Registers#FF4D_-_KEY1_-_CGB_Mode_Only_-_Prepare_Speed_Switch|double speed mode]]. It can map up to 64 Mbits (8 MBytes) of ROM. 

==MBC5 Schematic==
[[Image:MBC5.png]]

Source: [http://www.semis.demon.co.uk/Gameboy/Gbmain.htm]</text>
      <sha1>9xkz2wi0iy6nje2re9sqbb6wp37yrew</sha1>
    </revision>
    <revision>
      <id>450</id>
      <parentid>251</parentid>
      <timestamp>2012-05-25T12:16:24Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1463">==Overview==
MBC5 (Memory Bank Controller 5) is the 4th generation MBC. There apparently was no MBC4, presumably because of the superstition about the number 4 in Japanese culture. It is the first MBC that is guranteed to work properly with [[CGB-001|GBC]] [[CGB_Registers#FF4D_-_KEY1_-_CGB_Mode_Only_-_Prepare_Speed_Switch|double speed mode]]. It can map up to 64 Mbits (8 MBytes) of ROM.

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 64kbit, 256kbit and 1mbit.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

==Schematic==
[[Image:MBC5.png]]

Source: [http://www.semis.demon.co.uk/Gameboy/Gbmain.htm]</text>
      <sha1>k81eo1v3221mhh5o973biwf8wjkj452</sha1>
    </revision>
    <revision>
      <id>451</id>
      <parentid>450</parentid>
      <timestamp>2012-05-25T12:18:02Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1497">{{Pandocs|memorybankcontrollers}}
==Overview==
MBC5 (Memory Bank Controller 5) is the 4th generation MBC. There apparently was no MBC4, presumably because of the superstition about the number 4 in Japanese culture. It is the first MBC that is guranteed to work properly with [[CGB-001|GBC]] [[CGB_Registers#FF4D_-_KEY1_-_CGB_Mode_Only_-_Prepare_Speed_Switch|double speed mode]]. It can map up to 64 Mbits (8 MBytes) of ROM.

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 00-1FF (Read Only)===
Same as for MBC1, except that accessing up to bank 1E0h is supported now. Also, bank 0 is actually bank 0.

===A000-BFFF - RAM Bank 00-0F, if any (Read/Write)===
Same as for MBC1, except RAM sizes are 64kbit, 256kbit and 1mbit.

===0000-1FFF - RAM Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM. A value of 00h will disable it.

===2000-2FFF - Low 8 bits of ROM Bank Number (Write Only)===
The lower 8 bits of the ROM bank number goes here. Writing 0 will
indeed give bank 0 on MBC5, unlike other MBCs.

===3000-3FFF - High bit of ROM Bank Number (Write Only)===
The 9th bit of the ROM bank number goes here.

===4000-5FFF - RAM Bank Number (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-0Fh maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.

==Schematic==
[[Image:MBC5.png]]

Source: [http://www.semis.demon.co.uk/Gameboy/Gbmain.htm]</text>
      <sha1>r4x8wr1yo43e0n6z5mkfg8fiag1z8hm</sha1>
    </revision>
  </page>
  <page>
    <title>MBC3</title>
    <ns>0</ns>
    <id>143</id>
    <revision>
      <id>449</id>
      <timestamp>2012-05-25T12:14:17Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>Created page with '== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==  Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Re…'</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3441">== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to read the latched (frozen) time from the RTC registers, while the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.</text>
      <sha1>qbofkib6m5ucrnm1hgwn3p6t65prpuc</sha1>
    </revision>
    <revision>
      <id>452</id>
      <parentid>449</parentid>
      <timestamp>2012-05-25T12:18:58Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3475">{{Pandocs|memorybankcontrollers}}
== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure.
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to read the latched (frozen) time from the RTC registers, while the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.</text>
      <sha1>0z86yssiff08e9fz3vjh0tuvxypif69</sha1>
    </revision>
    <revision>
      <id>573</id>
      <parentid>452</parentid>
      <timestamp>2014-12-29T06:21:20Z</timestamp>
      <contributor>
        <username>Elizafox</username>
        <id>49</id>
      </contributor>
      <comment>Copy from [[Memory Bank Controllers]] page</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3518">{{Pandocs|memorybankcontrollers}}
== MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer) ==

Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM (4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The RTC requires an external 32.768 kHz Quartz Oscillator, and an external battery (if it should continue to tick when the gameboy is turned off).

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
Same as for MBC1, except that accessing banks 20h, 40h, and 60h is supported now.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
===A000-BFFF - RTC Register 08-0C (Read/Write)===
Depending on the current Bank Number/RTC Register selection (see below), this memory space is used to access an 8KByte external RAM Bank, or a single RTC Register.

===0000-1FFF - RAM and Timer Enable (Write Only)===
Mostly the same as for MBC1, a value of 0Ah will enable reading and writing to external RAM - and to the RTC Registers! A value of 00h will disable either.

===2000-3FFF - ROM Bank Number (Write Only)===
Same as for MBC1, except that the whole 7 bits of the RAM Bank Number are written directly to this address. As for the MBC1, writing a value of 00h, will select Bank 01h instead. All other values 01-7Fh select the corresponding ROM Banks.

===4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)===
As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h maps the corresponding external RAM Bank (if any) into memory at A000-BFFF.
When writing a value of 08h-0Ch, this will map the corresponding RTC register into memory at A000-BFFF. That register could then be read/written by accessing any address in that area, typically that is done by using address A000.

===6000-7FFF - Latch Clock Data (Write Only)===
When writing 00h, and then 01h to this register, the current time becomes latched into the RTC registers. The latched data will not change until it becomes latched again, by repeating the write 00h-&gt;01h procedure. This is supposed for &lt;reading&gt; from the RTC registers. This can be proven by reading the latched (frozen) time from the RTC registers, and then unlatch the registers to show the clock itself continues to tick in background.

===The Clock Counter Registers===

  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)

The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC Registers.

===The Day Counter===
The total 9 bits of the Day Counter allow to count days in range from 0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value overflows. In that case the Carry Bit remains set until the program does reset it.
Note that you can store an offset to the Day Counter in battery RAM. For example, every time you read a non-zero Day Counter, add this Counter to the offset in RAM, and reset the Counter to zero. This method allows to count any number of days, making your program Year-10000-Proof, provided that the cartridge gets used at least every 511 days.

===Delays===
When accessing the RTC Registers it is recommended to execute a 4ms delay (4 Cycles in Normal Speed Mode) between the separate accesses.</text>
      <sha1>jgx93zkad1s6xltdiuk4duqmj2hqc7z</sha1>
    </revision>
  </page>
  <page>
    <title>MBC2</title>
    <ns>0</ns>
    <id>142</id>
    <revision>
      <id>448</id>
      <timestamp>2012-05-25T12:13:26Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>Created page with '== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==  ===0000-3FFF - ROM Bank 00 (Read Only)=== Same as for MBC1.  ===4000-7FFF - ROM Bank 01-0F (Read Only)=== Same as for MBC1, but …'</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1394">== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.</text>
      <sha1>fr02ox9c8lm94xffs2r8kgz5h4ui7qe</sha1>
    </revision>
    <revision>
      <id>453</id>
      <parentid>448</parentid>
      <timestamp>2012-05-25T12:19:51Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1428">{{Pandocs|memorybankcontrollers}}
== MBC2 (max 256KByte ROM and 512x4 bits RAM) ==

===0000-3FFF - ROM Bank 00 (Read Only)===
Same as for MBC1.

===4000-7FFF - ROM Bank 01-0F (Read Only)===
Same as for MBC1, but only a total of 16 ROM banks is supported.

===A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)===
The MBC2 doesn't support external RAM, instead it includes 512x4 bits of built-in RAM (in the MBC2 chip itself). It still requires an external battery to save data during power-off though.
As the data consists of 4bit values, only the lower 4 bits of the &quot;bytes&quot; in this memory area are used.

===0000-1FFF - RAM Enable (Write Only)===
The least significant bit of the upper address byte must be zero to enable/disable cart RAM. For example the following addresses can be used to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 1E00-1EFF.
The suggested address range to use for MBC2 ram enable/disable is 0000-00FF.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.

The least significant bit of the upper address byte must be one to select a ROM bank. For example the following addresses can be used to select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.
The suggested address range to use for MBC2 rom bank selection is 2100-21FF.</text>
      <sha1>k4bahj2w112u73oqm60vnkmipzhnsfl</sha1>
    </revision>
  </page>
  <page>
    <title>MBC1</title>
    <ns>0</ns>
    <id>141</id>
    <revision>
      <id>447</id>
      <timestamp>2012-05-25T12:10:58Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <comment>Created page with '== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==  This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a progra…'</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2973">== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.</text>
      <sha1>9g3lxahkpban62u1v5nfuwdwv896rlw</sha1>
    </revision>
    <revision>
      <id>454</id>
      <parentid>447</parentid>
      <timestamp>2012-05-25T12:20:34Z</timestamp>
      <contributor>
        <username>Beannaich</username>
        <id>33</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3007">{{Pandocs|memorybankcontrollers}}
== MBC1 (max 2MByte ROM and/or 32KByte RAM) ==

This is the first MBC chip for the gameboy. Any newer MBC chips are working similiar, so that is relative easy to upgrade a program from one MBC chip to another - or even to make it compatible to several different types of MBCs.

Note that the memory in range 0000-7FFF is used for both reading from ROM, and for writing to the MBCs Control Registers.

===0000-3FFF - ROM Bank 00 (Read Only)===
This area always contains the first 16KBytes of the cartridge ROM.

===4000-7FFF - ROM Bank 01-7F (Read Only)===
This area may contain any of the further 16KByte banks of the ROM, allowing to address up to 125 ROM Banks (almost 2MByte). As described below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the odd amount of 125 banks.

===A000-BFFF - RAM Bank 00-03, if any (Read/Write)===
This area is used to address external RAM in the cartridge (if any). External RAM is often battery buffered, allowing to store game positions or high score tables, even if the gameboy is turned off, or if the cartridge is removed from the gameboy. Available RAM sizes are: 2KByte (at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K banks at A000-BFFF).

===0000-1FFF - RAM Enable (Write Only)===
Before external RAM can be read or written, it must be enabled by writing to this address space. It is recommended to disable external RAM after accessing it, in order to protect its contents from damage during power down of the gameboy. Usually the following values are used:

  00h  Disable RAM (default)
  0Ah  Enable RAM

Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM.

===2000-3FFF - ROM Bank Number (Write Only)===
Writing to this address space selects the lower 5 bits of the ROM Bank Number (in range 01-1Fh). When 00h is written, the MBC translates that to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be always directly accessed by reading from 0000-3FFF.
But (when using the register below to specify the upper ROM Bank bits), the same happens for Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will select Bank 21h, 41h, and 61h instead.

===4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)===
This 2bit register can be used to select a RAM Bank in range from 00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank number, depending on the current ROM/RAM Mode. (See below.)

===6000-7FFF - ROM/RAM Mode Select (Write Only)===
This 1bit Register selects whether the two bits of the above register should be used as upper two bits of the ROM Bank, or as RAM Bank Number.

  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)

The program may freely switch between both modes, the only limitiation is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 00-1Fh can be used during Mode 1.</text>
      <sha1>ao0y6vr73zkhafffhvq00a58ba9kxbk</sha1>
    </revision>
  </page>
</mediawiki>
